---
title: [Leetcode] 88. Merge Sorted Array 
description: 새로운 배열을 생성하지 않고 배열 정렬하기
date: 2025-01-12
tags: leetcode coding algorithm
---

## 문제

[Top Interview 150 : 88. Merge Sorted Array 문제 보러가기](https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)


## Javascript로 풀기
```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1;
    let p2 = n - 1;
    let p = m + n - 1;
    
    while (p2 >= 0) {
        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
            nums1[p] = nums1[p1];
            p1--;
        } else {
            nums1[p] = nums2[p2];
            p2--;
        }
        p--;
    }

};
```

## GPT를 이용해서 C언어로 바꿔보기 

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int p1 = m - 1;        // nums1의 마지막 원소 인덱스
    int p2 = n - 1;        // nums2의 마지막 원소 인덱스
    int p  = m + n - 1;    // 최종 삽입 위치(맨 뒤에서 시작)

    // nums2의 원소를 모두 처리할 때까지 반복
    while (p2 >= 0) {
        // nums1[p1]이 더 크면 nums1[p]에 복사, 아니면 nums2[p2]를 복사
        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
            nums1[p] = nums1[p1];
            p1--;
        } else {
            nums1[p] = nums2[p2];
            p2--;
        }
        p--;
    }
}
```

## GPT를 이용해서 C++로 바꿔보기
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1;           // nums1의 실제 요소 중 마지막 인덱스
        int p2 = n - 1;           // nums2의 마지막 인덱스
        int p  = m + n - 1;       // 병합 결과를 채울 인덱스(맨 뒤에서 시작)

        // nums2가 빌 때까지 반복
        while (p2 >= 0) {
            // nums1[p1]이 더 크면, nums1[p]에 nums1[p1] 대입
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p] = nums1[p1];
                p1--;
            } 
            // 그렇지 않으면 nums2[p2]를 대입
            else {
                nums1[p] = nums2[p2];
                p2--;
            }
            p--;
        }
    }
};
```


## GPT를 이용해서 JAVA로 바꿔보기

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1;
        int p2 = n - 1;
        int p = m + n - 1;
    
        while (p2 >= 0) {
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p] = nums1[p1];
                p1--;
            } else {
                nums1[p] = nums2[p2];
                p2--;
            }
            p--;
        }
    }
}
```

## GPT를 이용해서 RUST로 바꿔보기
```rust
impl Solution {
    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {
         let mut p1 = m - 1;             // nums1의 유효한 마지막 원소 인덱스
        let mut p2 = n - 1;             // nums2의 마지막 원소 인덱스
        let mut p  = (m + n) - 1;       // 병합 후 nums1의 마지막 인덱스

        // nums2를 전부 채울 때까지 반복 (p2가 0 이상일 때)
        while p2 >= 0 {
            // 만약 nums1[p1]이 더 크면 nums1[p]에 nums1[p1]을 복사
            if p1 >= 0 && nums1[p1 as usize] > nums2[p2 as usize] {
                nums1[p as usize] = nums1[p1 as usize];
                p1 -= 1;
            } else {
                // 그렇지 않으면 nums2[p2]를 복사
                nums1[p as usize] = nums2[p2 as usize];
                p2 -= 1;
            }
            p -= 1; 
        }
    }
}
```

## GPT를 이용해서 Python으로 바꿔보기

```Python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        p1, p2, p = m - 1, n - 1, m + n - 1
        
        # nums2의 모든 원소를 처리할 때까지 반복
        while p2 >= 0:
            # nums1의 마지막 유효 원소가 nums2의 마지막 원소보다 크면
            if p1 >= 0 and nums1[p1] > nums2[p2]:
                nums1[p] = nums1[p1]
                p1 -= 1
            else:
                nums1[p] = nums2[p2]
                p2 -= 1
            p -= 1
```
---
title: [CS] 어떤 코드가 더 성능이 좋은 코드일까?
description: 시간 복잡도(time complexity)에 대해서 알아보자.
date: 2023-11-01
tags: computer-science time-complexity
---

예전에 학부시절에 배웠던 개념이지만 복습을 위해 정리해보려고 한다.

## 시간 복잡도(time complexity)란?

> 시간 복잡도(Time Complexity)는 컴퓨터 과학과 알고리즘 분석에서 사용되는 개념으로, 어떤 알고리즘, 함수 또는 프로그램의 실행 시간이 입력 크기에 대한 함수로 표현됩니다. 시간 복잡도는 일반적으로 "Big O 표기법" 또는 다른 표기법을 사용하여 나타내며, 알고리즘이 입력 데이터 크기에 따라 어떻게 성장하는지를 나타내는 방식입니다.

`시간 복잡도`는 정확한 수치를 계산하는 방식은 아니며, 입력값이 `무한`하다는 가정하에 가장 낮은 차수의 항을 제외시키고 표현한다.

즉, 가장 빠르게 증가하는 항만을 고려하는 표기법이다

예를들면 5n^3 + 3n 이라는 식의 경우 `시간복잡도`는 `O(n^3)`이 된다.

## 시간 복잡도의 표

| 시간복잡도 | n           | 1   | 2   | 3    | 4   | 8     | 16             | 32              | 64               | 1000              |
| ---------- | ----------- | --- | --- | ---- | --- | ----- | -------------- | --------------- | ---------------- | ----------------- |
| 1          | 시간/n      | 1   | 1   | 1    | 1   | 1     | 1              | 1               | 1                | 1                 |
| log n      | log(n)      | 0   | 1   | 1.58 | 2   | 3     | 4              | 5               | 6                | 9.97              |
| n          | n           | 1   | 2   | 3    | 4   | 8     | 16             | 32              | 64               | 1000              |
| n log n    | n \* log(n) | 0   | 2   | 4.75 | 8   | 24    | 64             | 160             | 384              | 9966              |
| n^2        | n^2         | 1   | 4   | 9    | 16  | 64    | 256            | 1024            | 4096             | 1000000           |
| n^3        | n^3         | 1   | 8   | 27   | 64  | 512   | 4096           | 32768           | 262144           | 1000000000        |
| 2^n        | 2^n         | 2   | 4   | 8    | 16  | 256   | 65536          | 4294967296      | 약 1.844 x 10^19 | 약 1.07 x 10^301  |
| n!         | n!          | 1   | 2   | 6    | 24  | 40320 | 20922789888000 | 약 2.63 x 10^35 | 약 1.27 x 10^89  | 약 4.02 x 10^2567 |

## 시간 복잡도의 활용

사실 아직 현업에서 개발을 하고 있는 친구들에게 시간 복잡도를 고려하면서 개발을 하는지 물어보면 대부분이 그렇지 않다고 한다.

실제로 방대한 코드에서의 시간복잡도를 고려하면서 개발을 하는 것은 매우 어려운 일이다.

하지만 만약 성능을 개선해야하는 경우가 발생한다면, 상대적으로 시간복잡도가 낮은 방향으로 개선을 할 수 있으므로 개념을 잘 알아두면 좋을 것 같다.

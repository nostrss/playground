---
title: [Leetcode] 27. Remove Element
description: 새로운 배열을 생성하지 않고 필요없는 요소 지우기
date: 2025-01-11
tags: leetcode coding algorithm
---

## 문제

[Top Interview 150 : 27. Remove Element 문제 보러가기](https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)


## Typescript로 풀기
```ts
function removeElement(nums: number[], val: number): number {
    let pointer = 0
    for(let i=0 ; i < nums.length; i++){
        if(nums[i] !== val){
            nums[pointer] = nums[i]
            pointer++
        }
    }
    return pointer
}
```
> 문제풀이
* 문제를 푸는데 가장 핵심적인 요소는 정렬이 될 필요가 없고 남는 요소가 맨앞에 위치하기만 하면 된다는 것이다.
* 그리고 배열의 요소값이 주어진 `val`과 다르다면 배열에 남길 요소이다. 이때 `pointer`라는 변수로 넣어줄 위치를 포인터로 관리하도록 한다.
* 이제 배열을 길이만큼 for문으로 순회를 한다.
* 순회를 하면서 삭제할 `var`값과 배열의 요소를 비교한다.
* 남겨질 요소이면 포인터가 가리키는 배열의 위치에 복사한다.
* 삭제될 요소들은 신경쓸 필요없다. 어차피 남겨질 요소의 개수만큼만 배열의 앞에서부터 채워질 것이다.
* 포인터의 길이 이후의 값은 상관이 없으니 신경쓰지 말자 

## GPT를 이용해서 C언어로 바꿔보기 

```c
int removeElement(int* nums, int numsSize, int val) {
  int pointer = 0;
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] != val) {
            nums[pointer] = nums[i];
            pointer++;
        }
    }
    return pointer; 
}
```

* C는 자바스크립트와 다르게 배열을 직접 파라미터로 넘기지 못하기 때문에 배열을 가리키는 포인터인 `int* nums`를 파라미터로 넘겨주고 있다. 
* 그리고 `numsSize` 파라미터를 주는 것은 문제를 푸는 학생들을 배려한 정보 인것 같다. 만약 `numSize`가 없다면 `nums`를 이용해서 배열의 길이를 구하는 작업을 먼저 했어야 했을 것 같다.
* `int* nums`는 정수형 배열을 가리키는 포인터이다.

### Q: 자료형뒤에 * 가 붙어 있으면 전부 그 자료형 배열의 포인터겠네?
### GPT

결론부터 말하자면, **`자료형* 변수`** 라고 선언했다고 해서 **“무조건 배열의 포인터”** 인 것은 아닙니다.  
C에서 `int* p;` 는 “정수형 변수를 가리키는 포인터”를 의미할 뿐, 그 포인터가 “단일 정수”를 가리킬 수도 있고, “연속된 여러 정수(배열)의 첫 번째 원소”를 가리킬 수도 있습니다.  

---

## C에서 `*`은 “포인터”를 의미
- `int* p;`는 "**p는 int(정수)를 가리키는 포인터**"라는 선언입니다.
- 즉, `p`는 “int형 데이터를 저장해 둔 메모리 주소를 담는 변수”라고 볼 수 있습니다.
- 그 메모리 주소가 **배열**일 수도 있고, **단일 변수**일 수도 있습니다.

### 예시 1) 단일 int 변수 가리키기
```c
int a = 10;
int* p = &a;  // &a = a의 메모리 주소
```

## GPT를 이용해서 C++로 바꿔보기
```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int pointer = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != val) {
                nums[pointer] = nums[i];
                pointer++;
            }
        }
        // pointer가 새 배열의 유효 길이가 됩니다.
        return pointer;
    }
};
```
* C++은 클래스로 풀게 되어 있었다.

### Q: public 키워드에 대해 설명 좀 해줘
### GPT

`C++`에서 클래스 안에 선언된 멤버(변수, 함수 등)는 `접근 지정자(access specifier)` 로 `public`, `private`, `protected` 등을 사용할 수 있습니다.

* public: 클래스 외부에서 객체를 통해 자유롭게 접근이 가능합니다.
* private: 클래스 내부(멤버 함수, friend 함수)에서만 접근할 수 있고, 외부에서는 직접 접근 불가능합니다.
* protected: 주로 상속과 관련되어, 해당 클래스 내부 + 상속받은 자식 클래스에서 접근 가능하지만, 외부에서는 접근 불가능합니다.

### Q: 파라미터 중 `vector<int>& nums` 문법에 대해 설명해줘

함수의 매개변수에 `&`가 붙으면, 이를 `참조(Reference)` 라고 부릅니다.

* `vector<int> nums`라고 쓰면, 함수가 호출될 때 벡터가 통째로 복사되므로 원본에 영향을 주거나 받지 못합니다(비효율적일 수 있음).

* `vector<int>& nums`라고 쓰면, **“벡터(int형)를 참조로 받겠다”**는 의미로, 복사가 일어나지 않고, 함수 내에서 이 벡터를 직접 수정하면 원본 벡터도 함께 수정됩니다.

* 포인터(*)와 달리 참조는 “무조건 유효한 객체”를 가리켜야 하며, 별도의 * 연산 없이 nums[i] 처럼 자연스럽게 사용 가능합니다.
간단히 말하면,

**vector<int>& nums는 “int형 벡터를 ‘참조’로 받는 매개변수”**로서,
함수가 호출될 때 “벡터 복사본”이 아닌 “원본”을 직접 가리키게 됩니다.

## GPT를 이용해서 JAVA로 바꿔보기

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int pointer = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[pointer] = nums[i];
                pointer++;
            }
        }
        return pointer;
    }
}
```

## GPT를 이용해서 RUST로 바꿔보기
```rust
impl Solution {
    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
        let mut pointer = 0;
        for i in 0..nums.len() {
            if nums[i] != val {
                nums[pointer] = nums[i];
                pointer += 1;
            }
        }
        pointer as i32
    }
}
```

### Q: impl, mut 키워드에 대해서 설명해줘
### GPT

#### 1. `impl` 키워드

- `impl`은 **implementation**의 줄임말로, 특정 타입(예: 구조체, 열거형 등)에 대한 **메서드(함수) 구현부**를 작성할 때 사용합니다.  
- `impl Solution { ... }` 내부에서 `pub fn remove_element(...) { ... }` 처럼 함수를 정의하면,  
  `Solution`이라는 타입(또는 구조체)에 속하는 **메서드를 제공**할 수 있게 됩니다.

```rust
impl Solution {
    // 이 블록 안에 Solution 타입의 메서드들을 정의
}
```
#### 2. `mut` 키워드

- Rust에서 **변수나 참조에 `mut`를 붙이면**, 해당 변수나 참조를 통해 **값을 변경할 수 있음**을 나타냅니다.
- 예시:

```rust
let mut pointer = 0;
// pointer라는 변수를 재할당하거나 수정 가능
```


### Q: `.`이 연속해서 두번 쓰이는 문법에 대해서 설명해줘
### GPT

## 1. `for i in 0..nums.len()` 문법

- `0..nums.len()` 은 **Range(범위)** 표기이며, **`a..b`**는 **`a` 이상 `b` 미만**의 구간을 의미합니다.
  - 예: `0..5` → `0, 1, 2, 3, 4` (5는 포함되지 않음)
- 따라서 `for i in 0..nums.len()` 은 `i`를 **0부터 `nums.len()` - 1까지** 순회합니다.
- 이 코드는 `nums`의 모든 인덱스를 확인하며,  
  `nums[i]`가 `val`과 다를 경우(즉, 유지해야 할 값인 경우)에만 **앞으로 옮기는 로직**을 구현합니다.

```rust
for i in 0..nums.len() {
    if nums[i] != val {
        nums[pointer] = nums[i];
        pointer += 1;
    }
}
```

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/nostrss</id>
    <title>Nostrss's Dev Blog</title>
    <updated>2024-05-25T16:04:21.975Z</updated>
    <generator>generate-rss</generator>
    <author>
        <name>Nostrss</name>
        <email>jintagi@gmail.com</email>
        <uri>https://github.com/nostrss</uri>
    </author>
    <link rel="alternate" href="https://github.com/nostrss"/>
    <link rel="self" href="https://nostrss.me/rss-atom.xml"/>
    <subtitle>Nostrss Blog Post List</subtitle>
    <category term="Technologies"/>
    <entry>
        <title type="html"><![CDATA[프론트엔드가 로딩을 최적화 하는 방법]]></title>
        <id>203-front-loading-optimization</id>
        <link href="https://nostrss.me/blog/203-front-loading-optimization"/>
        <updated>2024-03-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[압축, 캐싱 등을 이용해 최적화를 하는 방법에 대해서 알아보자]]></summary>
        <content type="html"><![CDATA[<p>어떤 웹페이지의 로딩 속도를 빠르게 하는 방법엔 어떤 것들이 있을까?</p>
<p>프론트 입장에서 고려해 볼 수 있는 방법들에 대해서 정리해봤다.</p>
<h2>압축</h2>
<h3>Gzip</h3>
<ul>
<li>서버에서 html, javascript, css 등을 압축해서 리소스를 받는 방법</li>
<li>단, 압축효과가 적은 이미지 컨텐츠나, 크기가 작은 컨덴츠는 encoding/decoding 부하가 더 걸리수 있으므로 주의가 필요하다.</li>
</ul>
<h3>이미지, 동영상 압축</h3>
<ul>
<li>리소스의 용량을 줄여 로딩시간을 단축</li>
<li>WebP 또는 프로그레시브 JPEG과 같이 더 작은 파일의 크기로 더 높은 품질을 제공하는 형식 사용</li>
</ul>
<h2>캐싱</h2>
<h3>CDN</h3>
<ul>
<li>정적파일을 여러 위치에 분산하여 둠으로서, 물리적으로 사용자에게 가까운 거리에서 빠른 속도로 컨텐츠를 전송할 수 있다.</li>
</ul>
<h3>브라우저 캐싱</h3>
<ul>
<li>자주 액세스하는 리소스를 사용자 브라우저 로컬에 만료날짜를 지정하여 저장</li>
<li>만료날짜 이전에 재접속하는 경우, 브라우저 캐쉬에 남아있는 리소스를 사용</li>
</ul>
<h3>Preload</h3>
<ul>
<li>tab, Carousel 메뉴 등의 경우 리소스를 미리 pre-load하여 브라우저 캐쉬에 저장</li>
</ul>
<h2>최적화</h2>
<h3>이미지 최적화</h3>
<ul>
<li>화면 size에 적절한 크기의 이미지 사용
<ul>
<li>srcset과 size 속성을 함께 사용</li>
</ul>
</li>
<li>CSS Image Sprites
<ul>
<li>여러개의 이미지를 하나의 이미지로 합쳐서 관리하는 방법</li>
<li>서버에 대한 이미지 요청 회수를 줄일 수 있다.</li>
</ul>
</li>
<li>이미지 품질(quality) 조정하기</li>
</ul>
<h3>Minify</h3>
<ul>
<li>Javascript와 CSS의 불필요한 공백과 줄바꿈(white space)을 제거</li>
<li>변수와 함수명 압축</li>
</ul>
<h3>HTTP 요청 최소화</h3>
<ul>
<li>여러 CSS파일을 병합</li>
<li>Overfetching과 Underfetching 되지 않도록 backend와 협의</li>
</ul>
<h3>ATF(Above-The-Fold)와 lazyloading</h3>
<ul>
<li>스크롤 없이 볼수 있는 영역을 먼저 렌더링 되도록 우선순위 설정</li>
</ul>
<h3>과도한 애니메이션 자제</h3>
<ul>
<li>CSS 애니메이션이 Javascript 애니메이션 보다 빠른 경우가 많다</li>
<li>reflow가 발생하는 애니메이션이 repaint 보다 부하가 많이 발생</li>
</ul>
<h3>Font 최적화</h3>
<ul>
<li>font 렌더링 최적화
<ul>
<li>font의 렌더링 과정
<ul>
<li>브라우저가 HTML을 요청, 응답받은 HTML로 DOM 생성</li>
<li>브라우저가 CSS를 요청, 응답받은 CSS로 CSSOM 생성</li>
<li>브라우저는 CSS 응답 이후 Font요청</li>
<li>브라우저는 Font의 응답을 기다리지 않고 렌더링 시작
<ul>
<li>이때 Font가 준비되지 않을 경우 대체 font로 렌더링하거나 렌더링하지 않음</li>
<li>FOIT(Flash Of Invisible Text), FOUT(Flash Of Unstyled Text)</li>
</ul>
</li>
</ul>
</li>
<li>html파일의 link태그에 Preload 속성을 부여하여 리소스 대기열 우선순위를 높인다.
<ul>
<li>css 파일 요청과 동시에 font 요청이 이루어진다.</li>
</ul>
</li>
</ul>
</li>
<li>Font 용량 최적화
<ul>
<li>WOFF2 폰트 우선 사용
<ul>
<li>기존 WOFF보다 용량이 적으나 호환성이 낮음</li>
</ul>
</li>
<li>사용하지 않은 폰트 삭제</li>
<li>서브셋 폰트 사용</li>
</ul>
</li>
</ul>
<h2>그외</h2>
<ul>
<li>불필요한 라이브러리 삭제, 외부 스크립트 최소화</li>
<li>정적페이지의 경우 빌드 시 SSG 또는 ISR 활용</li>
</ul>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="loading"/>
        <category label="optimization"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Semantic Version(유의적 표현)이란?]]></title>
        <id>202-semantic-version-package</id>
        <link href="https://nostrss.me/blog/202-semantic-version-package"/>
        <updated>2024-03-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[버저닝 관리와 package.json]]></summary>
        <content type="html"><![CDATA[<h2>Semver란?</h2>
<p>Semantic Version의 줄임말이다. 소프트웨어의 버전 형식에 의미를 부여하여, 체계적인 버저닝 관리가 되도록 하기 위한 제안이다.</p>
<p>package.json이나 App을 보다 보면, <code>1.0.1</code>, <code>2.8.2와</code> 같은 형식의 버전을 종종 볼 수가 있다.</p>
<p>이렇게 버전을 표기할 때 보는 사람으로 하여금 버전의 변화만을 보고도 대략적으로 어떤 업데이트인지 알 수 있도록 규칙을 정리한 것이라고 할 수 있다.</p>
<blockquote>
<p>즉, 버전이 변화할 때마다 올바른 의미를 버전에 부여하도록 하는 체계라고 볼 수 있다.</p>
</blockquote>
<h2>Semver의 구조</h2>
<p>Semver에서 버저닝 표기 형식은 아래와 같이 3개의 구조를 가지고 있다.</p>
<blockquote>
<p>[Major].[Minor].[Patch]</p>
</blockquote>
<p>그리고 각 특징을 정리하면 아래와 같다.</p>
<h3>Major</h3>
<ul>
<li>0일 경우 초기 개발 중인 상태를 말한다.</li>
<li>1부터 공개 버전으로 정의합니다.</li>
<li>기존과 호환되지 않는 변화가 있을 때는 반드시 major 버전을 올려야 한다.</li>
<li>major 버전이 증가하면 <code>minor</code>, <code>patch</code>는 <code>0으로 초기화한다.</code></li>
</ul>
<h3>Minor</h3>
<ul>
<li>이전 버전과 호환되는 <code>기능</code>을 추가했을 때 올린다.</li>
<li>공개 API의 일부를 앞으로 <code>제거(deprecate)</code>로 표시한 경우에도 올린다</li>
<li>major 버전이 올라가는 경우 patch는 반드시 <code>0으로 초기화한다.</code></li>
</ul>
<h3>Patch</h3>
<ul>
<li>이전 버전과 호환되는 버그를 수정한 경우에만 올린다.</li>
</ul>
<h2>Semver 구조의 확장</h2>
<blockquote>
<p>[Major].[Minor].[Patch]-[Pre-release]+[Build Metadata]</p>
</blockquote>
<p>위의 3개의 구조에 <code>Pre-release</code>,<code>Build Metadata</code>를 함께 표기 할 수 도 있다.</p>
<h3>Pre-release 버전</h3>
<ul>
<li>patch 바로 뒤에 ‘-’를 붙이고 마침표(.)로 구분된 식별자를 더하여 표기 할 수 있다.</li>
<li>식별자는 반드시 아스키문자, 숫자, 붙임표로만 구성한다.</li>
</ul>
<h3>Build Metadata</h3>
<ul>
<li>patch 또는 pre-release 버전 뒤에 더하기(+) 기호를 붙여 표현할 수 있다.</li>
<li>식별자는 반드시 아스키문자, 숫자, 붙임표로만 구성한다.</li>
</ul>
<p>여기까지 정리된 표기법을 예시로 정리하면 아래와 같다.</p>
<blockquote>
<p>1.0.0-alpha+001
1.0.0+20130313144700
1.0.0-beta+exp.sha.5114f85</p>
</blockquote>
<h2>버전의 우선순위</h2>
<p>Semver에서 우선 순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할 지를 나타낸다.</p>
<ul>
<li>major > minor > patch 순으로 비교한다.</li>
<li>만약 major, minor, patch가 동일하고 pre-release 버전이 있는 경우와 없는 경우가 있다면  pre-release 버전이 있는 버전이 우선순위가 더 낮다.</li>
<li>pre-relase간의 비교
<ul>
<li>마침표(.)로 구분된 식별자를 차례로 비교한다.</li>
<li>숫자로만 구성된 경우
<ul>
<li>수의 크기로 비교한다.</li>
</ul>
</li>
<li>알파벳이나 붙임표가 포함된 경우
<ul>
<li>아스키 문자열 정렬을 한다.</li>
</ul>
</li>
<li>숫자로만 구성된 경우는 알파벳이나 붙임표가 포함된 경우보다 무조건 우선순위가 낮다.</li>
</ul>
</li>
<li>build metadata는 우선순위에 영향을 주지 않는다.</li>
</ul>
<p>위의 규칙대로 우선순위를 정리한 예시는 아래와 같다.</p>
<blockquote>
<p>1.0.0
1.0.0-rc.1
1.0.0-beta.11
1.0.0-beta.2
1.0.0-beta
1.0.0-alpha.beta
1.0.0-alpha.1
1.0.0-alpha</p>
</blockquote>
<h2>package.json에서 Semver</h2>
<p>그동안 package.json 파일을 보다 보면 버전 앞에 아래와 같이 <code>^</code>, <code>~</code> 표기가 되어 있던 것을 볼 수 있었다.
이 기호들의 의미는 무엇일까?</p>
<pre><code class="language-json">	"react-icons": "^4.10.1",
    "react-markdown": "^8.0.7",
    "react-syntax-highlighter": "^15.5.0",
</code></pre>
<h3>캐럿(^)</h3>
<ul>
<li>x.y.z 중 x 이하 하위 호환성이 보장되는 범위내에서 버전 업데이트</li>
<li>같은 major 버전만 npm update 허용</li>
<li>단 공개버전이 아닌 경우(0.x)에는 patch만 증가</li>
</ul>
<h3>틸드(~)</h3>
<ul>
<li>x.y.z 중  x.y 이하 버전만 하위 호환성 보장</li>
<li>major, minor 버전은 고정되고 patch 버전이 달라진 경우 업데이트 허용</li>
</ul>
<p>위의 규칙은 프로젝트의 패키지들을 관리하거나 업데이트할 때 중요하기 때문에 잘 알아둬야 할 것 같다.</p>
<p>모든 규칙을 다 외워둘 수는 없으니, 이러한 내용이 있다는 것을 알아두고 필요할 때 마다 챙겨 보면 좋을 듯 하다.</p>
<h2>Reference</h2>
<p><a href="https://semver.org/lang/ko/">https://semver.org/lang/ko/</a><br>
<a href="https://semver.npmjs.com/">https://semver.npmjs.com/</a></p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="semantic-version"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[웹서버와 WAS]]></title>
        <id>201-webserver-was</id>
        <link href="https://nostrss.me/blog/201-webserver-was"/>
        <updated>2024-02-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[웹서버와 WAS에 대해서 알아보고 비교해보자]]></summary>
        <content type="html"><![CDATA[<h2>웹서버(Web Server)와 WAS(Web Application Server)</h2>
<h3>웹서버</h3>
<ul>
<li>클라이언트의 요청에 대해 정적인 컨텐츠를 제공하는 서버</li>
<li>정적인 컨텐츠: 이미지, HTML, CSS, JS 등</li>
</ul>
<h3>WAS(Web Application Server)</h3>
<ul>
<li>클라이언트의 요청에 대해 비즈니스 로직을 수행하고 동적인 컨텐츠를 제공하는 서버</li>
<li>동적인 컨텐츠: 데이터베이스 조회, 계산 등</li>
</ul>
<h3>웹서버와 WAS의 차이점</h3>
<p>| 특징     | 웹 서버                     | WAS                                            |
| -------- | --------------------------- | ---------------------------------------------- |
| 기능     | 정적 콘텐츠 제공            | 동적 콘텐츠 처리 및 비즈니스 로직 실행         |
| 프로토콜 | HTTP, HTTPS                 | HTTP, HTTPS, TCP/IP 등                         |
| 확장성   | 일반적으로 단일 기능에 특화 | 다양한 비즈니스 요구 사항을 처리하는 기능 제공 |</p>
<h2>웹서버와 WAS의 관계</h2>
<ul>
<li>일반적으로 웹서버와 WAS는 분리되어 있다. 클라이언트 - 웹서버 - WAS - 데이터베이스의 구조로 되어 있다.</li>
<li>이렇게 웹서버와 WAS를 분리하는 이유는 각각의 역할에 맞게 서버를 구성하여 성능을 향상시키기 위함이다.</li>
</ul>
<h2>웹서버와 WAS 분리의 장점</h2>
<h3>보안</h3>
<p>두 개의 서버가 물리적으로 분리되어 있기 때문에 보안이 강화된다. 또한 두개의 서버사이에 방화벽을 설치하여 보안을 더 강화할 수 있다.</p>
<h3>WAS 서버의 부하 분산</h3>
<p>웹서버와 WAS가 분리되어 있기 때문에 WAS 서버의 부하를 분산시킬 수 있다.</p>
<p>WAS 서버의 경우 동적인 컨텐츠를 처리하기 때문에 부하가 많이 걸릴 수 있다. 만약 웹서버와 WAS가 분리되어 있지 않아서, 정적 컨텐츠를 함께 처리하게 되면 WAS 서버의 부하가 더욱 심해질 수 있다.</p>
<h3>무중단 서비스</h3>
<p>웹서버와 WAS가 분리되어 있기 때문에 웹서버의 장애가 발생하더라도 WAS 서버는 정상적으로 동작할 수 있다.</p>
<p>또한 배포 시에도 웹서버와 WAS 서버를 분리하여 무중단 배포를 할 수 있다.</p>
<h3>리버스 프록시 캐싱</h3>
<p>웹서버와 WAS가 분리되어 있기 때문에 리버스 프록시 서버를 사용하여 캐싱을 할 수 있다.</p>
<p>웹서버에서 클라이언트의 요청을 받아 WAS로 전달하기 전에 캐싱을 하여 WAS 서버의 부하를 줄일 수 있다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="web-server"/>
        <category label="web-application-server"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Next] Image 컴포넌트를 이용한 반응형 이미지 만들기]]></title>
        <id>200-next-responsive-image</id>
        <link href="https://nostrss.me/blog/200-next-responsive-image"/>
        <updated>2024-01-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[layout props를 사용하지 않고 Image 컴포넌트를 이용하여 반응형 이미지를 만들어보자]]></summary>
        <content type="html"><![CDATA[<p>Next.js에서는 Image 컴포넌트를 제공한다.</p>
<p>Image 컴포넌트는 일반적으로 쓰는 img 태그와 다르게 몇가지 장점이 있지만 사용하기에 어려움도 있다.</p>
<p>예전에는 layout props를 사용해 반응형 이미지 구현이 가능했었다.</p>
<p>그런데 얼마전에 변경된 내용을 모르고 layout props를 사용해 반응형 이미지를 구현하려고 하니 브라우저 콘솔에 경고가 떴다.</p>
<p>경고의 링크를 확인해 보니 layout props가 13버전에서 deprecated 되었다고 한다.</p>
<p><a href="https://nextjs.org/docs/messages/next-image-upgrade-to-13">📌 next/image changed in version 13📌</a></p>
<p>그래서 변경된 방법으로 이미지를 반응형으로 보여주는 방법을 알아보았다.</p>
<h2>정적 이미지를 import 해서 사용하는 경우</h2>
<p>public 폴더에 이미지를 넣고 import 해서 사용하는 경우가 되겠다.</p>
<p>이 경우에는 아래와 같이 이미지를 import 해서 사용하면 되는데 이때, Image 컴포넌트에 width와 height를 지정해주지 않아도 된다.</p>
<p><a href="https://nextjs.org/docs/app/api-reference/components/image#responsive-images">📌 next/image response images 📌</a></p>
<pre><code class="language-tsx">import Image from 'next/image';
import onerror from '../../../public/onerror.png'; // 정적 이미지를 import 해서 사용하는 경우

export default function Test() {
  return (
    &#x3C;Image
      src={onerror}
      alt='Picture of the author'
      sizes='100vw'
      style={{
        width: '100%',
        height: 'auto',
      }}
    />
  );
}
</code></pre>
<h2>이미지가 동적이거나 외부에서 가져오는 경우</h2>
<p>이런 경우가 대부분일 것 같다. 이 경우에는 위와는 조금 사용방법이 달라진다.</p>
<p><a href="https://nextjs.org/docs/app/api-reference/components/image#responsive-image-with-aspect-ratio">📌 Responsive image with aspect ratio 📌</a></p>
<pre><code class="language-tsx">import Image from 'next/image';

export default function Test() {
  return (
    &#x3C;Image
      src='https://picsum.photos/id/28/4928/3264'
      alt='Picture of the author'
      sizes='100vw'
      style={{
        width: '100%',
        height: 'auto',
      }}
      width={500}
      height={300}
    />
  );
}
</code></pre>
<p>위와 같이 작성하게 되면 외부에서 가져온 이미지를 반응형으로 보여줄 수 있다.</p>
<p>다만 width와 height를 지정해주어야 한다.</p>
<h3>만약 width와 height를 모른다면?</h3>
<p>위와 같이 500, 300 으로 width와 height를 지정해주었는데 만약 이미지의 크기가 거꾸로 300, 500 이라면 어떻게 될까?</p>
<p>그래도 정상적으로 이미지를 보여지게 된다.</p>
<p>하지만 조금더 자세히 살펴보면</p>
<p>최초에 이미지 영역을 500, 300 으로 잡고 이미지를 로딩하고 나서 이미지의 크기에 맞게 이미지 영역을 조정하는 것을 볼 수 있다.</p>
<p>그래서 이미지의 용량이 크거나, Next 이미지의 placeholder에 blur를 지정해두었다면, 최초에는 설정한 width와 height에 맞게 placeholder가 보여지다가 이미지가 로딩되면서 이미지 영역이 조정되는 것을 볼 수 있다.</p>
<h2>이미지의 크기를 모르는 경우 fill을 사용해보자</h2>
<p>Next 공식문서에서는 이미지의 크기를 모르는 경우 fill을 사용하라고 한다.</p>
<p><a href="https://nextjs.org/docs/app/api-reference/components/image#responsive-image-with-fill">📌 next/image fill 📌</a></p>
<p>fill을 사용한 경우의 코드는 아래와 같다.</p>
<pre><code class="language-tsx">import Image from 'next/image';

export default function Test() {
  return (
    &#x3C;div style={{ position: 'relative', width: '500px', height: '300px' }}>
      &#x3C;Image
        src='https://picsum.photos/id/28/2000/3264'
        alt='Picture of the author'
        sizes='100px'
        fill
        style={{
          objectFit: 'contain', // 또는 objectFit: 'cover'
        }}
      />
    &#x3C;/div>
  );
}
</code></pre>
<p>주의 할 점은 fill을 사용할 경우 Image 태그에 position : absolute 속성이 자동으로 추가된다는 것이다.</p>
<p>그래서 Image 태그를 감싸고 있는 부모 태그에 relative 속성을 추가해주어야 한다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="react"/>
        <category label="image"/>
        <category label="responsive"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Turborepo] 모노레포에 Next.js에 테스트 환경 추가하기]]></title>
        <id>199-monorepo-jest-testing</id>
        <link href="https://nostrss.me/blog/199-monorepo-jest-testing"/>
        <updated>2024-01-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[모노레포에 Jest를 이용한 테스팅 환경을 만들어보자]]></summary>
        <content type="html"><![CDATA[<p>이제 모노레포에 testing 환경을 구축해보려고 한다.</p>
<h2>구축 실패 사례</h2>
<p>처음에는 packages에 jest를 비롯한 테스트 환경을 구축하고, 각 프로젝트에서 의존성을 추가하여 진행하려고 했다.</p>
<p>그러나 테스트를 실행하면 test 파일을 찾지 못한다는 오류가 발생했다.</p>
<p>tsconfig와 설정을 여러가지 변경해보았지만 해결되지 않았다.</p>
<p>환경 구축에 너무 시간이 오래 걸리는 것 같아서 일단 각 Next.js 프로젝트 별로 테스트 환경을 구축하기로 했다.</p>
<h2>jest 설치하기</h2>
<p>아래의 문서를 참고하여 진행하였다.</p>
<p><a href="https://nextjs.org/docs/app/building-your-application/testing/jest">📌 Setting up Jest with Next.js 📌</a></p>
<pre><code class="language-bash">cd front-admin
yarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom

</code></pre>
<p>위의 명령어로 필요한 패키지를 설치해줬다. 뒤에 테스트 과정에서 몇몇 패키지가 추가로 필요할 수 있다.</p>
<h3>jest.config.ts 생성하기</h3>
<pre><code class="language-ts">import type { Config } from 'jest';
import nextJest from 'next/jest.js';

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

// Add any custom config to be passed to Jest
const config: Config = {
  coverageProvider: 'v8',
  testEnvironment: 'jsdom',
  // Add more setup options before each test is run
  // setupFilesAfterEnv: ['&#x3C;rootDir>/jest.setup.ts'],
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
export default createJestConfig(config);
</code></pre>
<h3>package.json 수정하기</h3>
<pre><code class="language-json">// apps/front-admin/package.json
{
  "scripts": {
    "test": "jest", // 추가
    "test:watch": "jest --watch" // 추가
    // ...
  }
}
</code></pre>
<h3>root package.json 수정하기</h3>
<pre><code class="language-json">//package.json
{
  "scripts": {
    "test": "turbo test", // 추가
    "test:watch": "turbo test:watch" // 추가
    // ...
  }
}
</code></pre>
<h3>turbo.json 수정하기</h3>
<pre><code class="language-json">{
  "pipeline": {
    // 추가
    "test": {
      "cache": false
    },
    "test:watch": {
      "cache": false
    }
    // ...
  }
}
</code></pre>
<h2>test 해보기</h2>
<pre><code class="language-js">// apps/front-admin/src/__test__/Text.test.js
import React from 'react';
import { render, screen } from '@testing-library/react';
import Home from '@/app/page';
import '@testing-library/jest-dom';

describe('HomePage 컴포넌트', () => {
  it('"환영합니다!" 텍스트가 포함되어 있는지 확인한다', () => {
    render(&#x3C;Home />);
    const linkElement = screen.getByText(/테스트/i);
    expect(linkElement).toBeInTheDocument();
  });
});
</code></pre>
<p>테스트가 정상적으로 실행되는 것을 확인할 수 있다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="turborepo"/>
        <category label="monorepo"/>
        <category label=""/>
        <category label="next"/>
        <category label="jest"/>
        <category label="testing"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Turborepo] 모노레포에 스토리북 추가하기]]></title>
        <id>198-monorepo-storybook</id>
        <link href="https://nostrss.me/blog/198-monorepo-storybook"/>
        <updated>2024-01-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[모노레포에 내가 원하는 디자인 시스템을 세팅해보자]]></summary>
        <content type="html"><![CDATA[<p>이제 모노레포에 내가 원하는 디자인 시스템, Storybook을 추가해보자.</p>
<h2>Storybook 설치하기</h2>
<p>아래의 공식문서를 참고해 진행했다.</p>
<p><a href="https://turbo.build/repo/docs/handbook/tools/storybook">📌 Using Storybook with Turborepo 📌</a></p>
<p>크게 어려움은 없었으나, 나 같은 경우 yarn 으로 설치시 오류가 발생하여 npm으로 설치를 진행했던 기억이 난다.</p>
<p>공식문서에서 vite를 사용하도록 되어 있어서 한번 살펴보았다.</p>
<h2>Vite란?</h2>
<p><a href="https://ko.vitejs.dev/guide/why.html">📌 Vite 공식문서 📌</a></p>
<p>공식문서를 읽어보니 vite는 Webpack과 같은 번들링을 하는 도구인 것 같다.</p>
<p>기존의 번들러보다 서버구동이 빠르고 여러가지 이점이 있다고 한다.</p>
<p>일단 현재는 스토리북을 설치하기 위함이니 가볍고 읽고 넘어갔다.</p>
<blockquote>
<p>참고로 Vite는 node.js 18 또는 20 이상의 버전을 요구한다.
나 같은 경우 현재 18+ 버전을 사용하고 있어서 문제는 없었다.</p>
</blockquote>
<h3>package.json 수정하기</h3>
<p>이번에도 turbo repo 환경에 맞게 package.json 을 일부 수정해주었다.</p>
<ul>
<li>turbo build 명령어 실행 시 스토리북도 빌드가 되게 하기 위해 build 명령어에 스토리북 빌드 명령어를 추가해줬다.</li>
<li>React 컴포넌트를 공통으로 사용하기 위해 <code>의존성</code>을 추가해줬다.</li>
</ul>
<pre><code class="language-json">//apps/storybook/package.json
{
  "scripts": {
    "build": "storybook build" // 스토리북 빌드 명령어 수정
    // ...
  },
  "dependencies": {
    "@repo/ui": "*" // packages/ui를 추가
    // ...
  }
}
</code></pre>
<h3>turbo.json 수정</h3>
<p><code>turbo.json</code>의 pipeline에 스토리북의 빌드 경로를 추가해줬다.</p>
<pre><code class="language-json">{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [
        ".next/**",
        "!.next/cache/**",
        "dist/**",
        "storybook-static/**" // 스토리북 빌드 경로 추가
      ]
    }
    // ...
  }
}
</code></pre>
<h2>스토리북 테스트 해보기</h2>
<p>이제 잘 작동하는지 아래와 같이 코드를 작성해 보았다.</p>
<pre><code class="language-ts">//apps/storybook/src/stories/Button.stories.ts
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from '@repo/ui/button';

const meta = {
  title: 'Example/Button',
  component: Button,
  // This component will have an automatically generated Autodocs entry: https://storybook.js.org/docs/writing-docs/autodocs
  tags: ['autodocs'],
  parameters: {
    // More on how to position stories at: https://storybook.js.org/docs/configure/story-layout
    layout: 'fullscreen',
  },
} satisfies Meta&#x3C;typeof Button>;

export default meta;
type Story = StoryObj&#x3C;typeof meta>;

export const DefaultButton: Story = {
  args: {
    children: 'Button',
    appName: 'Default',
  },
};
</code></pre>
<p>정상적으로 스토리북이 작동하는 것을 확인할 수 있었다.</p>
<p>컴포넌트를 만들때마다 스토리북을 통해 확인하면서 개발하면 좋을 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="turborepo"/>
        <category label="monorepo"/>
        <category label="storybook"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Turborepo] 모노레포에 새로운 Next.js 프로젝트 추가하기]]></title>
        <id>197-monorepo-new-nextjs</id>
        <link href="https://nostrss.me/blog/197-monorepo-new-nextjs"/>
        <updated>2024-01-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[모노레포에 내가 원하는 환경을 세팅해보자]]></summary>
        <content type="html"><![CDATA[<h2>Monorepo 생성하기</h2>
<p>이전 글과 동일하게 Turborepo를 사용해서 모노레포를 생성해주었다.</p>
<pre><code class="language-bash">npx create-turbo@latest
</code></pre>
<p>위와 같이 모노레포를 생성하면 <code>apps</code> 워크스페이스에 <code>web</code>과 <code>docs</code>라는 next.js 프로젝트가 생성된다.</p>
<h2>Apps 워크스페이스에 Next.js 프로젝트 추가하기</h2>
<p>신규 프로젝트를 추가한다고 가정하고 새로운 next.js 프로젝트를 <code>apps</code>워크스페이스에 추가해보자.</p>
<pre><code class="language-bash">cd apps
npx create-next-app@latest front-admin
</code></pre>
<p>정상적으로 프로젝트가 생성되었다면 <code>apps</code> 워크스페이스에 <code>front-admin</code>이라는 디렉토리가 생성되었을 것이다.</p>
<p>그리고 몇가지 설정을 수정해주어야 한다.</p>
<h3>package.json 수정하기</h3>
<ul>
<li><code>turbo dev</code> 명령어 실행 시 <code>port</code>가 겹치지 않도록 <code>dev</code> 명령어에 포트를 추가해줬다.</li>
<li><code>packages/ui</code>에 공통으로 사용할 React 컴포넌트가 있다. 이를 사용하기 위해 <code>의존성</code>을 추가해줬다.</li>
<li><code>eslint</code>와 <code>typescript</code> 설정을 공통으로 사용하기 위해 <code>dev 의존성</code>을 추가해줬다.</li>
</ul>
<pre><code class="language-json">// apps/front-admin/package.json

{
  "scripts": {
    "dev": "next dev --port 3004" // 포트 추가
    // ...
  },
  "dependencies": {
    "@repo/ui": "*" // packages/ui를 추가
    // ...
  },
  "devDependencies": {
    "@repo/eslint-config": "*", // packages/eslint-config를 추가
    "@repo/typescript-config": "*" // packages/typescript-config를 추가
    // ...
  }
}
</code></pre>
<h3>tsconfig.json 수정하기</h3>
<p>typescript 설정을 공통으로 사용하기 위해 <code>tsconfig.json</code>을 아래와 같이 수정해줬다.</p>
<pre><code class="language-json">//apps/backend/tsconfig.json

{
  "extends": "@repo/typescript-config/nextjs.json", // 공통 설정 추가
  "compilerOptions": {
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.js",
    "**/*.jsx",
    ".next/types/**/*.ts",
    ".env"
  ],
  "exclude": ["node_modules"]
}
</code></pre>
<h3>.eslintrc.js 수정하기</h3>
<p>eslint 설정을 공통으로 사용하기 위해 <code>.eslintrc.js</code>를 아래와 같이 수정해줬다.</p>
<pre><code class="language-js">//apps/front-admin/.eslintrc.js

/** @type {import("eslint").Linter.Config} */
module.exports = {
  root: true,
  extends: ['@repo/eslint-config/next.js'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: true,
  },
  ignorePatterns: ['**/*.test.js', '**/__tests__/**'],
};
</code></pre>
<h2>실행하기</h2>
<p>root 경로에서 <code>turbo dev</code> 명령어를 실행했을 때, 기존에 있던 web과 docs 프로젝트와 함께 front-admin 프로젝트도 정상적으로 실행되는 것을 확인할 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="turborepo"/>
        <category label="monorepo"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Turborepo] 모노레포에 있는 2개의 Next.js 프로젝트를 Vercel에 각각 배포하기]]></title>
        <id>196-monorepo-vercel-deploy</id>
        <link href="https://nostrss.me/blog/196-monorepo-vercel-deploy"/>
        <updated>2024-01-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Turborepo를 이용해 Monorepo를 생성하고 Vercel로 배포해보자]]></summary>
        <content type="html"><![CDATA[<p>최근 프론트엔드에서 monorepo 구조를 많이 도입하는 것 같다.</p>
<p>예전에 멀티레포 형태로 서비스를 유지/보수 했던 경험이 있었는데,</p>
<p>그때 여러가지 문제점을 겪었었다. 그때 느낀 점은 아래와 같다.</p>
<ul>
<li>공통으로 사용하는 컴포넌트를 공유하기 어려웠다. 그래서 각 프로젝트마다 중복되는 컴포넌트를 만들어야 했다.</li>
<li>패키지 버전 관리가 어려웠다. 각 프로젝트마다 패키지 버전이 달라지면서 다양한 오류가 발생하고, 버전에 따라 달라진 문법을 사용해야 하는 경우가 생겼다. 특히 react의 버전이 달라지면서 발생하는 문제가 많았다.</li>
<li>서비스의 기능이 추가 될 경우 Repo의 개수가 많아지게 된다. 그러다 보니 어느 순간 repo의 개수가 16개가 넘어가는 경우가 생겼고 이를 관리하기가 어려웠다.</li>
</ul>
<p>최근 포트폴리오용 서비스가 하나 생각나서 개발 환경을 구축중 이었다.</p>
<p>예전에는 로컬 터미널에서 내가 직접 빌드하고 배포하는 명령어를 실행해줘야 했었는데,</p>
<p>이런 멀티레포의 단점을 극복하기 위해 최근에 사용하는 아키텍쳐가 <code>monorepo</code>이다.</p>
<h2>모노레포란?</h2>
<p>모노레포에 대한 개념은 인터넷에 좋은 글들이 있어서 링크로 대신하였다.</p>
<p><a href="https://d2.naver.com/helloworld/0923884">📌 Naver D2 : 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편 📌</a></p>
<p><a href="https://blog.hwahae.co.kr/all/tech/11962">📌 화해 : 모노레포 적용부터 yarn berry까지 📌</a></p>
<p><a href="https://green-labs.github.io/monorepo-microfrontend">📌 그린랩스 : 모노레포 - 마이크로 아키텍처를 지향하며 📌</a></p>
<h2>Turborepo</h2>
<p>모노레포를 구축하기 위해 여러가지 방법이 있었는데, 나는 <code>turborepo</code>를 사용했다.</p>
<p><a href="https://turbo.build/repo">📌 Turborepo 홈페이지 바로가기📌</a></p>
<p>터보레포를 선택한 이유는 Vercel에서 인수하고 직접 개발 중인 서비스라 Next.js와 Vercel과 잘 호환될 것 같아서 선택했다.</p>
<h2>새로운 프로젝트 생성</h2>
<p><a href="https://turbo.build/repo/docs/getting-started/create-new">📌 Turborepo를 이용해 모노레포 생성하기📌</a></p>
<pre><code class="language-bash">npx create-turbo@latest
</code></pre>
<p>위의 명령어를 실행하고 원하는 설정을 선택하면 모노레포가 생성된다.</p>
<p>생성된 모노레포의 구조를 살펴보면 아래와 같다.</p>
<ul>
<li><code>apps</code>와 <code>packages</code>라는 2개의 워크스페이스를 가지고 있다.</li>
<li><code>apps</code> 워크스페이스에는 <code>web</code>,<code>docs</code>라는 이름의 2개의 <code>nextjs</code> 프로젝트가 생성되어 있다</li>
</ul>
<h2>Vercel로 배포하기</h2>
<p>이제 생성된 모노레포를 <code>Vercel</code>로 배포해보자.</p>
<p>그냥 무작정 배포하기 보다는 회사를 다닌다면 모노레포를 어떻게 사용하고 배포할지 생각해봤다.</p>
<p>예를 들면 docs는 회사의 기술 문서를 작성하는 곳이고, web은 회사의 서비스 프로젝트라고 생각을 해보자.</p>
<p>그렇다면 아마 docs는 <code>docs.도메인.com</code>, web은 <code>web.도메인.com</code>으로 배포를 할 것이다.</p>
<p>이렇게 배포를 하고 싶었다.</p>
<p>그래서 Vercel에 깃허브 repo를 등록하였다.</p>
<p>Vercel을 사용해본 사람은 알겠지만 위의 사진처럼 등록하면 나머지 과정은 거의 자동으로 진행되어 배포가 진행된다.</p>
<h3>문제점 발견</h3>
<p>배포가 완료되고 확인을 해봤는데, 문제가 발견되었다.</p>
<p><code>docs</code>는 정상적으로 배포가 되었지만, <code>web</code>은 배포가 되지 않았다.</p>
<p>Vercel에서 모노레포를 인식하고 2개의 Next.js 프로젝트를 인식하지 못한 것 같다.</p>
<p>그래서 setting에서 추가 설정을 해줘야 하는지 찾아보았다.</p>
<p>그런데 Root Directory가 <code>apps/docs</code>로 설정되어 있었다.</p>
<p>그렇다면 Vercel에 Root Directory가 <code>apps/web</code>로 설정된 배포단을 하나 더 만들면 되지 않을까? 라는 생각이 들었다.</p>
<h2>Vercel에 배포단 추가하기(Web)</h2>
<p>새로운 프로젝트를 추가하여 위에서 등록한 동일한 github repo를 등록하였다.</p>
<p>그리고 그 과정에서 Root Directory를 <code>apps/web</code>로 설정하였다.</p>
<p>그리고 배포가 완료하니 아래와 같이 2개의 배포단이 생성되었다.</p>
<p>이제 각각의 배포단위에 도메인 설정을 해준다면</p>
<p>최초에 의도한대로 <code>docs.도메인.com</code>, <code>web.도메인.com</code>으로 배포가 가능할 것이다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="turborepo"/>
        <category label="monorepo"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Storybook 빌드 파일 Github Actions으로 자동 배포하기]]></title>
        <id>195-storybook-github-actions</id>
        <link href="https://nostrss.me/blog/195-storybook-github-actions"/>
        <updated>2023-11-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[github에 push만 하면 storybook이 자동으로 똭!!]]></summary>
        <content type="html"><![CDATA[<p>최근 포트폴리오용 서비스가 하나 생각나서 개발 환경을 구축중 이었다.</p>
<p>예전에는 로컬 터미널에서 내가 직접 빌드하고 배포하는 명령어를 실행해줘야 했었는데,</p>
<p>이번에는 <code>github actions</code>을 이용해서 자동으로 빌드하고 배포되는 환경을 구축해보았다.</p>
<h2>준비</h2>
<h3>storybook-deployer 설치</h3>
<p>먼저 아래 패키지를 설치해준다.</p>
<p><a href="https://www.npmjs.com/package/@storybook/storybook-deployer">📌 npm @storybook/storybook-deployer 보러가기 📌</a></p>
<h3>package.json 스크립트 추가</h3>
<p>그리고 package.json에 아래와 같이 스크립트를 추가해준다.</p>
<pre><code class="language-json">{
  "scripts": {
    "deploy-storybook": "storybook-to-ghpages"
  }
}
</code></pre>
<h3>github personal access token 발급</h3>
<p><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">📌 github personal access token 발급 보러가기 📌</a></p>
<p>github actions에서 github에 접근하기 위해서는 <code>token</code>이 필요하다.</p>
<p><code>github developer setting</code>에서 발급 받을 수 있다.</p>
<h3>Secrets and variables에 token 추가</h3>
<p>그리고 해당 프로젝트 <code>repository</code>의 <code>Settings</code> -> <code>Secrets and variables</code> 에서 발급 받은 token을 추가해준다.</p>
<h3>github actions workflow 파일 추가</h3>
<p>나는 아래와 같이 작성을 했다.</p>
<p>처음에는 몇번 build, deploy에서 실패했었으나</p>
<p>log를 확인해보면서 진행하니 성공적으로 빌드, 배포가 되었다.</p>
<pre><code class="language-yml">name: Build and Deploy Storybook

on:
  push:
    branches:
      - main

jobs:
  storybook-build-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install dependencies
        run: npm install

      - name: Build-deploy Storybook
        run: npm run deploy-storybook -- --ci
        env:
          GH_TOKEN: ${{ github.actor }}:${{ secrets.ACCESS_TOKEN }}
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="storybook"/>
        <category label="github-actions"/>
        <category label="build"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[코딩테스트와 코딩과제가 이런 것이구나..]]></title>
        <id>194-review-coding-test</id>
        <link href="https://nostrss.me/blog/194-review-coding-test"/>
        <updated>2023-11-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[시험을 보면서도 배우는 것이 많았던 것 같다.]]></summary>
        <content type="html"><![CDATA[<p>최근 총 3곳에서 <code>코딩테스트</code>와 <code>과제</code>를 진행했다.</p>
<p>물론 입사를 위해 어쩔수 없이 치르게 된 것이지만, 그 과정중에서 배운 것도 있고 느낀 것도 있어서 정리해보려고 한다.</p>
<h2>A사 코딩 과제</h2>
<p>A사는 스타트업이었고, 서류 통과자에게 코딩 과제를 부여 하였는데, 상당히 인상적인 과제였다.</p>
<p>과제는 총 <code>3개</code>의 문제로 구성되어 있었고, 문제는 다음과 같았다.</p>
<ol>
<li><code>Next.js</code>를 이용한 간단한 웹 페이지 만들기</li>
<li><code>Bun</code>을 이용한 파일 입출력 프로그램 만들기</li>
<li><code>Python</code>을 이용한 간단한 api 서버 만들기</li>
</ol>
<p>프론트엔드를 지원했기 때문에, 1번 문제는 당연하다고 생각을 했지만, 2,3번 문제는 상당히 의외였다. 다만, 과제를 제시한 취지를 제시해주고 있었는데, 새로운 기술을 학습하고 적용하는 능력을 보려는 것이었다.</p>
<p>덕분에 <code>Bun</code>, <code>Python</code>도 처음 사용해보는 좋은 기회가 되었다.</p>
<p>다만, 1~3번 문제의 기술적인 난이도는 높지 않아서, 금방 제출 할 수 있었고 통과하여 면접까지 진행하였다.</p>
<h2>B사 코딩 테스트</h2>
<p>B사는 나름 인지도가 있는 기업이었고, 대기업? 최소 중견기업 정도 규모의 회사였다.</p>
<p>처음 보는 기업 코딩테스트이기에, 어떤 문제가 나올지 예상이 되지 않았다.</p>
<p>프로그래머스에서 자료구조, 알고리즘 관련 문제를 찾아서 풀면서 준비했다.</p>
<p><a href="https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit">📌 프로그래머스 코딩테스트 고득점 문제 Kit 문제 보러가기 📌</a></p>
<p>시험 당일 <code>2문제</code>, <code>5시간</code> 제한으로 진행되었고, 프로그래머스에서 진행되었다.</p>
<p>1문제는 풀었고, 다른 1문제는 뒤늦게 방법을 찾았는데.. 시간이 부족해서 풀지 못했다.</p>
<p>지금 돌이켜 보니 이런 코딩테스트를 준비하려면 몇가지 준비를 해야 할 것 같다.</p>
<ol>
<li>최적화</li>
</ol>
<ul>
<li>500,000만 길이의 배열, 1,000,000만 길이의 문자열 등등.. 이런 데이터를 <code>효율성</code> 높게 처리해야 하기 때문에, <code>시간복잡도</code>를 고려해야한다. 이때, <code>자료구조</code>, <code>알고리즘</code> 이론이 필요하다. DFS, BFS, DP, Greedy 등등.. 이런 것들을 잘 알고 있어야 풀 수 있을 것 같다.</li>
</ul>
<ol start="2">
<li>경험</li>
</ol>
<ul>
<li>알고리즘을 알고 있더라도 문제에 적용하는 방법을 알아야 한다. 근의 공식을 알고 있다해도 문제에 적용하지 못하면 못풀듯이 말이다. 이런 <code>경험</code>을 위해서는 많은 문제를 풀어봐야 할 것 같다.</li>
</ul>
<h2>C사 코딩 테스트</h2>
<p>C사는 대기업이었고, 개인적으로 욕심이 많아서 꼭 들어가고 싶은 회사였다.</p>
<p>총 <code>4문제</code>, 최대 <code>8시간</code>까지의 시간이 부여 되었다. 다만, 문제별로 부여되는 시간이 달랐다.</p>
<p>완전 오픈 북이었으면, 구글, ChatGpt등을 사용할 수 있었고 개인 IDE를 사용할 수 있었다.</p>
<ol>
<li>Typescript 관련 문제</li>
<li>Typescript 관련 문제</li>
<li>Javascript 관련 문제</li>
<li>Javascript 관련 문제</li>
</ol>
<p>시험은 <code>testdome</code>이라는 해외 사이트에서 진행되었고 상당히 생소한 환경이었다.</p>
<p>결과적으로 제대로 문제를 풀지 못했다. 아쉬웠던 건 3문제는 풀긴 했는데, 테스트를 통과하지 못했다는 것이다. 다만, <code>testdome</code> 문제가 설명히 좀 부족하고, 테스트 케이스가 부족한 것 같았다.</p>
<p>문제를 분석해보면, <code>비동기</code> 처리를 중요시 하는 것 같았다. <code>비동기</code>를 완벽하게 처리 할 줄 알아야만 풀 수 있는 문제들이 많았다.</p>
<p>그리고 <code>처음</code> 보는 객체를 다루는 문제가 나왔을 때, 이를 검색 등을 통해 해결하는 능력을 보려고 하는 것 같았다.</p>
<blockquote>
<p>아쉬움이 많이 남는 시험들 이었지만, 이 경험을 통해 내가 부족한 점도 알게 되고 배우는 것도 많았던 것 같다. 시험에서 도출된 나의 부족한 점을 잘 채워나가야 할 것 같다.</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="coding-test"/>
        <category label="review"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[testdome] Two Sum 문제]]></title>
        <id>193-testdome-56606</id>
        <link href="https://nostrss.me/blog/193-testdome-56606"/>
        <updated>2023-11-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이제는 해외 사이트 알고리즘 문제다..]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.testdome.com/questions/javascript/two-sum/56606">📌 Two Sum 문제 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<p>일단 해외 사이트라서 그런지 먼가 익숙치 않다.</p>
<p>예시도 자세히 알려주지 않고, 문제도 간단하게만 나와있다.</p>
<pre><code class="language-js">function findTwoSum(numbers, sum) {
  // Your code goes here
  for (let i = 0; i &#x3C; numbers.length - 1; i++) {
    for (let j = i + 1; j &#x3C; numbers.length; j++) {
      if (numbers[i] + numbers[j] === sum) return [i, j];
    }
  }
  return null;
}

const indices = findTwoSum([3, 1, 5, 7, 5, 9], 10);
console.log(indices);
</code></pre>
<p>위와 같이 풀었는데 다수의 숫자 배열을 이용하면 효율적이지 않다며 테스트 케이스가 통과하지 못하고
75점을 맞았다..</p>
<h2>나의 풀이 2</h2>
<p>100점을 맞기 위해 검색을 하다 해시맵을 사용하는 경우를 발견해서 수정했다.</p>
<p>수정한 코드는 아래와 같다.</p>
<pre><code class="language-js">function findTwoSum(numbers, sum) {
  const numMap = {};

  for (let i = 0; i &#x3C; numbers.length; i++) {
    const complement = sum - numbers[i];
    if (numMap.hasOwnProperty(complement)) {
      return [numMap[complement], i];
    }
    numMap[numbers[i]] = i;
  }
  return null;
}

const indices = findTwoSum([3, 1, 5, 7, 5, 9], 10);
console.log(indices);
</code></pre>
<p>이렇게 할 경우 numMap에는 이렇게 데이터가 저장된다.</p>
<pre><code>{}
{ '3': 0 }
{ '1': 1, '3': 0 }
{ '1': 1, '3': 0, '5': 2 }
</code></pre>
<p>10의 보수를 키값으으로 하고 인덱스를 값으로 저장하면서, 10의 보수가 있는지 확인하면 된다.</p>
<p>이렇게 하니 100점으로 통과가 되었다.</p>
<p>해시테이블.. 알아두면 좋은 방법 같다..</p>
<p>그런데 이거랑 DP랑 뭐가 다른거지..?</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="testdome,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="hash"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 완전탐색 - 최소직사각형]]></title>
        <id>189-programmers-86491</id>
        <link href="https://nostrss.me/blog/189-programmers-86491"/>
        <updated>2023-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[내 코드가 허접하게 보이는 다른 사람의 풀이]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/86491">📌 완전탐색 - 최소직사각형 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(sizes) {
  var answer = 0;
  const wallet = {
    width: 0,
    height: 0,
  };

  const isWalletFit = (size) => {
    if (wallet.width >= size[0] &#x26;&#x26; wallet.height >= size[1]) return true;
    else if (wallet.width >= size[1] &#x26;&#x26; wallet.height >= size[0]) return true;
    else return false;
  };

  const returnWalletSize = (size) => {
    return {
      normalSize:
        Math.max(wallet.width, size[0]) * Math.max(wallet.height, size[1]),
      rotationSize:
        Math.max(wallet.width, size[1]) * Math.max(wallet.height, size[0]),
    };
  };

  const compareWallet = (size) => {
    const { normalSize, rotationSize } = returnWalletSize(size);
    if (normalSize >= rotationSize) {
      wallet.width = Math.max(wallet.width, size[1]);
      wallet.height = Math.max(wallet.height, size[0]);
    } else {
      wallet.width = Math.max(wallet.width, size[0]);
      wallet.height = Math.max(wallet.height, size[1]);
    }
  };

  sizes.forEach((size) => {
    if (!isWalletFit(size)) {
      compareWallet(size);
    }
  });

  return (answer = wallet.width * wallet.height);
}
</code></pre>
<h2>풀이 설명</h2>
<p>사실 문제는 어렵지 않았다.</p>
<p>금방 풀었는데, 다른 사람의 풀이를 보고 깜짝 놀랐다.</p>
<pre><code class="language-js">function solution(sizes) {
  const [hor, ver] = sizes.reduce(
    ([h, v], [a, b]) => [
      Math.max(h, Math.max(a, b)),
      Math.max(v, Math.min(a, b)),
    ],
    [0, 0]
  );
  return hor * ver;
}
</code></pre>
<p>이렇게 간단히 푸신 분이 계셨는데.. 정말이지 나의 30줄을 10줄도 안되게 간단하게 풀어버리셨다.</p>
<p><code>reduce</code>와 <code>구조분해할당</code>을 이용해서 이렇게 풀다니..</p>
<p>아직 갈길이 멀다..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 동적계획법(Dynamic Programming) - 정수 삼각형]]></title>
        <id>192-programmers-43105</id>
        <link href="https://nostrss.me/blog/192-programmers-43105"/>
        <updated>2023-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[DP 문제.. 드디어 풀었다..!]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/43105">📌 동적계획법(Dynamic Programming) - 정수 삼각형 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(triangle) {
  var answer = 0;
  const height = triangle.length;

  for (i = height - 1; i > 0; i--) {
    for (j = 0; j &#x3C; triangle[i - 1].length; j++) {
      const left = triangle[i][j] + triangle[i - 1][j];
      const right = triangle[i][j + 1] + triangle[i - 1][j];
      triangle[i - 1][j] = Math.max(left, right);
    }
  }

  return (answer = triangle[0][0]);
}
</code></pre>
<h2>풀이 설명</h2>
<p>일단.. 삼각형을 위에서 아래로 내려오면서, 각각의 위치에서 최대값을 구현하려고 했다.</p>
<p>그런데 구현이 좀 어려워서 막혔다가, 삼각형을 <code>거꾸로</code> 돌려서 생각해봤다.</p>
<p>내가 생각한 방식을 그림으로 표현하면 이렇다.</p>
<pre><code>4 5 2 6 5
 2 7 4 4
  8 1 0
   3 8
    7
</code></pre>
<p>위에서 밑으로 내려오면서 겹치는 구간이 있는데, 이땐 더 큰수를 선택하면 된다.</p>
<p>그리고 별도의 dp 배열은 만들지 않고 triangle 배열에 바로 값을 넣어주었다.</p>
<p>triangle 베열의 값은 아래와 같이 시간이 지날수록 갱신되어 최종적으로는 최대값만 남게된다.</p>
<pre><code>[
  [ 7 ],
  [ 3, 8 ],
  [ 20, 13, 0 ],
  [ 7, 12, 10, 10 ],
  [ 4, 5, 2, 6, 5 ]
]
[
  [ 7 ],
  [ 3, 8 ],
  [ 20, 13, 10 ],
  [ 7, 12, 10, 10 ],
  [ 4, 5, 2, 6, 5 ]
]
[
  [ 7 ],
  [ 23, 8 ],
  [ 20, 13, 10 ],
  [ 7, 12, 10, 10 ],
  [ 4, 5, 2, 6, 5 ]
]
[
  [ 7 ],
  [ 23, 21 ],
  [ 20, 13, 10 ],
  [ 7, 12, 10, 10 ],
  [ 4, 5, 2, 6, 5 ]
]
[
  [ 30 ],
  [ 23, 21 ],
  [ 20, 13, 10 ],
  [ 7, 12, 10, 10 ],
  [ 4, 5, 2, 6, 5 ]
]
</code></pre>
<p>DP 문제에 대해 조금은 감을 잡은 듯한데.. 실전에서 잘 풀수 있을려나..?</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="dynamic,"/>
        <category label="dp"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 깊이/너비 우선 탐색(DFS/BFS) - 타겟 넘버]]></title>
        <id>190-programmers-43165</id>
        <link href="https://nostrss.me/blog/190-programmers-43165"/>
        <updated>2023-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[처음 풀어본 DFS 문제, 재귀는 어렵다..]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/43165">📌 깊이/너비 우선 탐색(DFS/BFS) - 타겟 넘버 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(numbers, target) {
  var answer = 0;

  const dfs = (arr, index, sum) => {
    if (index === arr.length - 1) {
      if (target === sum + arr[index]) answer = answer + 1;
      if (target === sum - arr[index]) answer = answer + 1;
      return;
    }

    dfs(arr, index + 1, sum + -1 * arr[index]);
    dfs(arr, index + 1, sum + arr[index]);
  };

  dfs(numbers, 0, 0);
  return answer;
}
</code></pre>
<h2>풀이 설명</h2>
<p>처음 풀어본 DFS 문제였다.</p>
<p>풀고나서 이제 보니.. 쉬워보이는데, 처음에는 재귀적으로 푸는 연습을 많이 해보지 않아서</p>
<p>처음에 시작이 어려웠다..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="dfs"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 깊이/너비 우선 탐색(DFS/BFS) - 게임 맵 최단거리]]></title>
        <id>191-programmers-1844</id>
        <link href="https://nostrss.me/blog/191-programmers-1844"/>
        <updated>2023-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이번엔 BFS 문제다.. x,y가 너무 헷갈렸다..]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/1844">📌 깊이/너비 우선 탐색(DFS/BFS) - 게임 맴 최단거리 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(maps) {
  var answer = -1;
  let user = [0, 0];

  const n = maps.length;
  const m = maps[0].length;

  const goal = [n - 1, m - 1];
  const queue = new Queue();

  const dx = [-1, 1, 0, 0];
  const dy = [0, 0, 1, -1];

  queue.enq([0, 0, 1]);
  maps[0][0] = 0;
  while (queue.length !== 0) {
    const [deqx, deqy, count] = queue.deq();
    if (deqx === goal[0] &#x26;&#x26; deqy === goal[1]) return count;

    for (let i = 0; i &#x3C; 4; i++) {
      const newx = deqx + dx[i];
      const newy = deqy + dy[i];

      if (newx > -1 &#x26;&#x26; newx &#x3C; n &#x26;&#x26; newy > -1 &#x26;&#x26; newy &#x3C; m) {
        if (maps[newx][newy] === 1) {
          queue.enq([newx, newy, count + 1]);
          maps[newx][newy] = 0;
        }
      }
    }
  }

  return answer;
}

class Queue {
  constructor() {
    this.items = {};
    this.headIndex = 0;
    this.tailIndex = 0;
    this.length = 0;
  }

  enq(item) {
    this.items[this.tailIndex] = item;
    this.tailIndex++;
    this.length = this.getLength();
  }

  deq() {
    const deqItem = this.items[this.headIndex];
    this.headIndex++;
    this.length = this.getLength();
    return deqItem;
  }

  getLength() {
    return this.tailIndex - this.headIndex;
  }
}
</code></pre>
<h2>풀이 설명</h2>
<p>x,y가 너무 헷갈렸다.. 한참 헤맸는데.. 생각해보니.. 전혀 필요가 없었던 것 같다..</p>
<p><code>Queue</code> 같은 경우에는 배열이 아닌 객체를 이용해서 구현했다.</p>
<p>객체로 구현하는 것이 시간 복잡도에 유리하다고 해서 연습해봤다.</p>
<p>생각보다 시간이 너무 오래 걸렸다.. ㅠㅠ</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="dfs,"/>
        <category label="bfs"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 이분탐색(Binary-Search) - 입국심사]]></title>
        <id>188-programmers-43238</id>
        <link href="https://nostrss.me/blog/188-programmers-43238"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Binary Search를 알아도 적용을 못하면 의미가 없다.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/43238">📌 이분탐색(Binary-Search) - 입국심사 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(n, times) {
  let low = 1;
  let high = Math.max(...times) * n; // 가장 오래 걸리는 시간

  while (low &#x3C;= high) {
    const mid = Math.floor((low + high) / 2);
    const people = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);
    if (people &#x3C; n) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return low;
}
</code></pre>
<h2>풀이 설명</h2>
<p>풀이를 위한 코딩 시간보다.. 풀이방법을 찾아내는데 한참 시간이 걸렸던 문제였다.</p>
<pre><code>제한사항
- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.
</code></pre>
<p>문제의 주제가 <code>이분탐색(binary-search)</code> 이었기 때문에</p>
<p>위의 주어진 제한 사항을 보고 이분탐색을 심사관 배열에 적용해서 풀어야 겠다는 생각을 해버렸고</p>
<p>거기에서 한참을 막혀 나오질 못했다.</p>
<p>그러다 생각한 방법은 거꾸로 생각해보는 것이었다.</p>
<p><code>이분탐색</code>을 심사관 배열이 아닌 <code>시간</code>에 적용해보자는 생각이었다.</p>
<p>그래서 <code>시간</code>을 기준으로 <code>이분탐색</code>을 적용했고 그 시간 내에 <code>심사관</code>들이 <code>심사</code>할 수 있는 <code>사람</code>의 수를 구했다.</p>
<p>어찌보면.. 시간을 대입하여 최소의 시간이 맞나?</p>
<p>아니면 또 다른 시간을 대입해서 맞나?</p>
<p>이렇게 문제를 푼 느낌이긴 하다.</p>
<p>풀고난뒤 다른분들의 풀이를 봐도 비슷한 걸로 봐서는 이 방식이 맞는 것 같다..</p>
<p>이론을 알아도.. 문제풀이에 적용을 못하면 의미가 없다는.. 느낌이 들었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="binary-search"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 탐욕법(Greedy) - 섬 연결하기]]></title>
        <id>187-programmers-42861</id>
        <link href="https://nostrss.me/blog/187-programmers-42861"/>
        <updated>2023-11-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[최소 신장 트리로 섬을 연결하자. (Feet. 크루스칼 알고리즘, Union-Find)]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42861">📌 탐욕법(Greedy) - 섬 연결하기 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(n, costs) {
  var answer = 0;
  let edges = 0;

  costs.sort((a, b) => a[2] - b[2]);

  // n개 만큼 인덱스를 원소로 같은 배열 생성
  const unionArr = Array.from({ length: n }, (_, i) => i);

  const findParent = (child) => {
    if (unionArr[child] === child) return child;
    return (unionArr[child] = findParent(unionArr[child]));
  };

  const insertParent = (small, bigger) => {
    unionArr[bigger] = small;
  };

  for (let i = 0; i &#x3C; costs.length; i++) {
    const [leftVertex, rightVertex] = costs[i];
    const minParent = Math.min(findParent(leftVertex), findParent(rightVertex));
    const maxParent = Math.max(findParent(leftVertex), findParent(rightVertex));

    if (minParent !== maxParent) {
      insertParent(minParent, maxParent);
      answer = answer + costs[i][2];
      edges = edges + 1;
    }
    // 선택한 간선의 개수가 n-1일때 종료
    if (edges === n - 1) break;
  }
  return answer;
}
</code></pre>
<h2>풀이 설명</h2>
<p>먼저 이 문제는 <code>크루스칼</code> 알고리즘으로 풀었다.</p>
<p><a href="https://ko.wikipedia.org/wiki/%ED%81%AC%EB%9F%AC%EC%8A%A4%EC%BB%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">📌 크루스칼(Kruskal) 알고리즘 보러가기 📌</a></p>
<p><code>크루스칼</code> 알고리즘은 <code>최소 신장 트리</code>를 만드는 알고리즘으로 이 문제를 푸는데 제격이다.</p>
<p><code>크루스칼</code> 알고리즘의 원리는 이렇다.</p>
<ul>
<li><code>간선</code>의 <code>가중치</code>를 기준으로 오름차순 정렬한다.</li>
<li>가중치가 가장 작은 간선부터 선택한다.</li>
<li>선택한 간선이 <code>사이클</code>을 만들지 않는다면 선택한다.</li>
<li>선택한 간선의 개수가 <code>n-1</code>개가 될 때까지 반복한다.</li>
</ul>
<p>이렇게 알고리즘을 작성하면 최소 신장 트리가 완성된다.</p>
<p>이때 사이클을 판별하는 방법은 <code>Union-Find</code> 알고리즘을 사용하는데..</p>
<p>오히려 이부분에서 시간을 많이 잡아먹었다.</p>
<p>좋은 글을 하나 찾아서 이 블로그를 참고하여 풀었다.</p>
<p><a href="https://wikidocs.net/207012">📌 참고링크 📌</a></p>
<p>이런 문제는 몇 번 더 연습을 해서 숙달해야 할 것 같다.</p>
<p>면접도 준비해야하는데.. 알고리즘만 풀고 있네..ㅠ</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="greedy,"/>
        <category label="mst,"/>
        <category label="kruskal,"/>
        <category label="union-find"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 탐욕법(Greedy) - 단속카메라]]></title>
        <id>186-programmers-42884</id>
        <link href="https://nostrss.me/blog/186-programmers-42884"/>
        <updated>2023-11-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[과속은 탐욕이다. 탐욕법으로 과속차량 단속하기]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42884">📌 탐욕법(Greedy) - 단속카메라 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(routes) {
  var answer = 0;
  // 겹치는 배열원소끼리 묶고 그 묶음의 개수를 구하자
  // 겹침 판별
  // [a,b] [c,d] a&#x3C;c&#x3C;b 면 겹친다
  // 겹침 구간 [c, Min(b,d)]

  routes.sort((a, b) => a[0] - b[0]);

  const isCross = (routeA, routeB) => {
    if (routeA[0] &#x3C;= routeB[0] &#x26;&#x26; routeB[0] &#x3C;= routeA[1])
      return {
        area: [routeB[0], Math.min(routeA[1], routeB[1])],
        cross: true,
      };
    else
      return {
        area: [0, 0],
        cross: false,
      };
  };
  let crossArea = routes[0];

  for (let i = 0; i &#x3C; routes.length - 1; i++) {
    const result = isCross(crossArea, routes[i + 1]);
    if (result.cross) {
      crossArea = result.area;
    } else {
      answer += 1;
      crossArea = routes[i + 1];
    }
  }
  return answer + 1;
}
</code></pre>
<h2>나의 풀이 설명</h2>
<ol>
<li>
<p>예시의 배열을 [[-20,-15], [-14,-5], [-18,-13], [-5,-3]], 오름차순으로 아래와 같이 정렬해주었다.</p>
</li>
<li>
<p>정렬결과 : [[-20,-15], [-18,-13], [-14,-5], [-5,-3]]</p>
</li>
<li>
<p>그리고 아래와 같이 알고리즘을 정리했다.</p>
</li>
</ol>
<ul>
<li>겹침 판별 : [-20,-15], [-18,-13]의 겹침 구간은 [-18,-15]이다.</li>
<li>그리고 다음 원소[-14,-5]와 이전 겹침구간[-18,-15]과 다시 겹침 판별했다.</li>
<li>겹침 판별이 false 일 때까지 이전까지 겹쳤던 원소들은 단속카메라가 필요하기 때문에 answer +1 을 해주고, 겹침구간을 다시 [-14,-5]로 초기화해준다.</li>
<li>이렇게 반복하면서 answer를 구한다.</li>
</ul>
<p>즉, 겹치는 구간이 없을때까지 원소들을 Index 0부터 진행해 나간다.</p>
<p>그러다 겹치는 구간이 없는 경우가 발생하면 단속카메라를 설치하고, 다시 다음 원소부터 이 방법을 반복하면 문제가 풀렸다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="greedy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 정렬 - 가장 큰 수]]></title>
        <id>184-programmers-42746</id>
        <link href="https://nostrss.me/blog/184-programmers-42746"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[때론 감으로 풀어서 맞는 경우도 있다...]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42746">📌 정렬 - H-Index 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(numbers) {
  var answer = '';

  const result = numbers
    .map((number) => String(number))
    .sort((a, b) => b + a - (a + b))
    .join('');

  return result[0] === '0' ? '0' : result;
}
</code></pre>
<p>솔직히 감으로 맞춰서 풀어본 문제이다.</p>
<p>모든 케이스를 다 테스트 통과할 거라고 생각치는 안았는데..</p>
<p>['1','2','3','10','11','12'].sort((a,b) => (b+a)-(a+b)) 이렇게 했을 때</p>
<p>['3','2','12','1','11','10'] 이렇게 나오는 것을 보고 감으로 풀어봤다.</p>
<p>... 이렇게 풀면 안되는데.. 통과가 되었다....</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="sort"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 정렬 - k번째 수]]></title>
        <id>183-programmers-42748</id>
        <link href="https://nostrss.me/blog/183-programmers-42748"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[원본배열을 변경하는 메소드를 조심하자.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42748">📌 정렬 - k번째 수 문제 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(array, commands) {
  var answer = [];

  answer = commands.map((command) => {
    const result = array
      .slice(command[0] - 1, command[1])
      .sort((a, b) => a - b);
    return result[command[2] - 1];
  });

  return answer;
}
</code></pre>
<p>문제는 크게 어렵지 않다.</p>
<p>다만, <code>sort</code> 메소드의 경우 원본 배열을 수정하기 때문에 주의해야 한다.</p>
<p>실제 코테시.. 검색을 할 수 없을 경우 원본 데이터를 변경하는 메소드인지 아닌지..</p>
<p>이런 것들을 기억하고 있어야 할 것 같다.</p>
<p>매번 MDN을 통해서 확인하면서 개발을 했었는데.. 숙지하고 보지않고 푸는 버릇을 들여야겠다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="sort"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 정렬 - H-Index]]></title>
        <id>185-programmers-42747</id>
        <link href="https://nostrss.me/blog/185-programmers-42747"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[때론 무식하게 푸는 것도 방법이다...]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42747">📌 정렬 - H-Index 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(citations) {
  const countArr = [];

  for (let i = 0; i &#x3C;= 10000; i++) {
    if (citations.filter((item) => item >= i).length >= i) countArr.push(i);
  }

  return countArr.sort((a, b) => b - a)[0];
}
</code></pre>
<p>이렇게 풀어도 되는건지.. 모르겠다..</p>
<p>푸는 방법이 도대체 떠오르지 않아서.. 무식하게 풀어봤다.</p>
<p>제한사항</p>
<ul>
<li>과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.</li>
<li>논문별 인용 횟수는 0회 이상 10,000회 이하입니다.</li>
</ul>
<p>배열의 길이가 그리 크지 않아서.. 모든 H-Index의 경우의 수를 구해서 가장 큰 H-Index를 구했다.</p>
<p>이렇게 해도 되는 걸까.. 수학적인 공식이 있을 것 같은데..</p>
<h2>다른 풀이</h2>
<p>chat Gpt를 통해서 다른 풀이를 구해보았다.</p>
<pre><code class="language-js">function solution(citations) {
  citations.sort((a, b) => b - a);
  let hIndex = 0;

  for (let i = 0; i &#x3C; citations.length; i++) {
    if (citations[i] >= i + 1) {
      hIndex = i + 1;
    } else {
      break;
    }
  }
  return hIndex;
}
</code></pre>
<p>생각해보니 굳이 1부터 10,000까지 비교할 필요는 없었다..
왜 이 생각을 못했을까..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="sort"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 스택/큐 - 주식거래]]></title>
        <id>182-programmers-42584</id>
        <link href="https://nostrss.me/blog/182-programmers-42584"/>
        <updated>2023-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[100,000개의 배열문제 효율성 통과하기]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42584">📌 스택/큐 - 주식거래 문제 보러가기 📌</a></p>
<h2>나의 풀이 1 - 효율성 통과 X</h2>
<pre><code class="language-js">function solution(prices) {
  var answer = [];

  answer = prices.map((stock, index) => {
    const pricesArray = prices.slice(index, prices.length);
    const findResult = pricesArray.findIndex((items) => items &#x3C; pricesArray[0]);
    return findResult === -1 ? pricesArray.length - 1 : findResult;
  });

  return answer;
}
</code></pre>
<p>처음 문제를 보고 쉽게 생각하고 위와 같이 풀었다.</p>
<p><code>정확성</code> 테스트는 통과했으나.. <code>효율성</code> 테스트를 전부 실패한 것을 볼 수 있다..</p>
<p>아무래도 <code>map</code>을 사용하고, 그안에서 <code>배열</code>을 또 생성하고, <code>findIndex</code>를 사용하는 것이 문제인 것 같다.</p>
<p>배열의 <code>최대 크기</code>가 <code>100,000</code> 이기 때문에 문제가 될 것 같아 배열을 생성하지 않고 다시 풀어보았다.</p>
<h2>나의 풀이 2 - 효율성 통과 O</h2>
<pre><code class="language-js">function solution(prices) {
  var answer = [];

  answer = prices.map((stock, index) => {
    let findResult = 0;
    for (let i = index + 1; i &#x3C; prices.length; i++) {
      if (stock > prices[i]) {
        findResult = i - index;
        return findResult;
      }
      findResult = i - index;
    }
    return findResult;
  });
  return answer;
}
</code></pre>
<p>배열을 새로 생성하지 않고 for문을 사용해서 불필요한 연산을 줄였더니 <code>효율성</code> 테스트를 통과할 수 있었다.</p>
<h2>다른 풀이</h2>
<p>지인이 문제를 보더니 풀어준 답안이다</p>
<pre><code class="language-js">function solution(prices) {
  const n = prices.length;
  const answer = new Array(n).fill(0);

  const stack = [];

  for (let i = 0; i &#x3C; n; i++) {
    while (stack.length > 0 &#x26;&#x26; prices[i] &#x3C; prices[stack[stack.length - 1]]) {
      const top = stack.pop();
      answer[top] = i - top;
    }
    stack.push(i);
  }

  while (stack.length > 0) {
    const top = stack.pop();
    answer[top] = n - 1 - top;
  }

  return answer;
}
</code></pre>
<p>스택을 이용해서 풀었는데, 이렇게 풀어도 효율성 테스트를 통과할 수 있었다.</p>
<p>풀이방법이 이해하기 조금 난해한데.. 다시 한번 더 공부해봐야겠다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="stack,"/>
        <category label="queue"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 스택/큐 - 프로세스]]></title>
        <id>181-programmers-42583</id>
        <link href="https://nostrss.me/blog/181-programmers-42583"/>
        <updated>2023-11-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Queue를 이용해서 프로세스를 구현해보자]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42587">📌 스택/큐 - 프로세스 문제 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(priorities, location) {
  var answer = 0;
  const queue = priorities.map((item, index) => ({ index, item }));

  while (queue.length > 0) {
    const peek = queue.shift();
    const isBigNumber = queue.findIndex((queueItem) => {
      return queueItem.item > peek.item;
    });

    if (isBigNumber > -1) {
      queue.push(peek);
    } else {
      answer = answer + 1;
      if (peek.index === location) break;
    }
  }

  return answer;
}
</code></pre>
<p>처음에 문제를 보고 우선순위큐를 이용한 문제로 판단해서 <code>우선순위큐</code>를 구현하려고 했다.</p>
<p>그러나 계속 결과가 틀려서 문제를 다시 읽어보니 굳이 <code>우선순위큐</code>를 사용하지 않아도 되는 문제였다..</p>
<p>문제를 잘못 읽어서 시간을 많이 낭비했다.</p>
<h2>문제 이해하기</h2>
<p>[2, 1, 3, 2] 라는 배열이 있고, location이 2라고 가정하자.</p>
<p>이 경우 프로세스는 다음과 같이 진행된다.</p>
<ol>
<li>2꺼냄, [1,3,2] : 3이라는 숫자가 더 큰 숫자가 있으므로 다시 넣음</li>
<li>[1,3,2,2]</li>
<li>1꺼냄 [3,2,2] : 3이라는 숫자가 더 큰 숫자가 있으므로 다시 넣음</li>
<li>[3,2,2,1]</li>
<li>3꺼냄 [2,2,1] : 더 큰 숫자가 없고, location이 2에 해당하므로 종료</li>
<li>3은 더이상 큐에 들어가지 않고 1번째로 실행되므로 1을 리턴</li>
</ol>
<p>꺼냈던 priorities 배열의 원소가 다시 큐에 삽입되는 경우가 있는데, 이를 고려해야 했었다.</p>
<blockquote>
<p>문제를 끝까지 제대로 이해하고 풀자!</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="stack,"/>
        <category label="queue"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 스택/큐 - 다리를 지나는 트럭]]></title>
        <id>180-programmers-42587</id>
        <link href="https://nostrss.me/blog/180-programmers-42587"/>
        <updated>2023-11-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Queue와 메소드를 이용해서 풀어보자]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42583">📌 스택/큐 - 다리를 지나는 트럭 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(bridge_length, weight, truck_weights) {
  var answer = 0;

  const queue = new Queue(bridge_length);
  const completeValue = truck_weights.reduce((acc, cur) => acc + cur);
  let overTruckValue = 0;

  while (overTruckValue &#x3C; completeValue) {
    // 현재 건너고 있는 트럭의 무게가 weight를 초과하는지 검사
    if (
      weight >=
      queue.weightSum + (truck_weights[0] === undefined ? 0 : truck_weights[0])
    ) {
      overTruckValue = overTruckValue + queue.enqueue(truck_weights.shift());
    } else {
      if (weight >= queue.sum() - queue.peek() + truck_weights[0]) {
        overTruckValue = overTruckValue + queue.enqueue(truck_weights.shift());
      } else {
        overTruckValue = overTruckValue + queue.enqueue(0);
      }
    }
    answer = answer + 1;
  }

  return answer;
}

class Queue {
  constructor(length) {
    this.items = new Array(length);
    this.items.fill(0);
    this.weightSum = 0;
  }
  enqueue(item) {
    const shiftValue = this.items.shift();
    this.items.push(item === undefined ? 0 : item);
    this.weightSum = this.sum();
    return shiftValue;
  }
  sum() {
    return (this.weightSum = this.items.reduce((acc, cur) => acc + cur));
  }
  peek() {
    return this.items[0];
  }
}
</code></pre>
<p>스택과 큐를 클래스로 미리 정의를 해두고 푸는 방법에 조금씩 익숙해지는 것 같다.</p>
<p>메소드도 문제에 필요한데로 정의를 해서 사용하니깐 훨씬 문제 풀기에 용이해 지는 것 같다.</p>
<p>빨리 코테 감을 잡자 시간이 부족하다!</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="stack,"/>
        <category label="queue"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 스택/큐 - 올바른 괄호 문제 풀이]]></title>
        <id>179-programmers-12909</id>
        <link href="https://nostrss.me/blog/179-programmers-12909"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[스택을 이용해서 괄호 검사를 해보자]]></summary>
        <content type="html"><![CDATA[<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/12909">📌 스택/큐 - 올바른 괄호 문제 보러가기 📌</a></p>
<h2>나의 풀이</h2>
<pre><code class="language-js">function solution(s) {
  const stack = new Stack();

  if (s[0] === ')') {
    return false;
  }

  for (let i = 0; i &#x3C; s.length; i++) {
    if (stack.top() === '(' &#x26;&#x26; s[i] === ')') stack.pop();
    else stack.push(s[i]);
  }

  return stack.isEmpty();
}

class Stack {
  constructor(stackArr) {
    this.stackArr = [];
  }

  push(item) {
    this.stackArr.push(item);
  }

  pop(item) {
    this.stackArr.pop(item);
  }

  top() {
    return this.stackArr[this.stackArr.length - 1];
  }

  isEmpty() {
    return this.stackArr.length === 0;
  }
}
</code></pre>
<p>Stack 클래스를 선언하고, push, pop, top, isEmpty 메소드를 구현하여 문제 풀이에 사용하였다.</p>
<p>이렇게 굳이 안풀어도 방법은 있겠지만, 이 문제의 의도에 맞게 풀려고 Stack 클래스를 구현하였다.</p>
<h2>개선 및 문제점</h2>
<p>문제를 풀다보니 <code>효율성</code> 이라는 항목이 있는 걸 발견했다.</p>
<p>예전엔 이런 항목이 있는지 몰랐는데..</p>
<p><code>시간복잡도</code>나 <code>공간복잡도</code>를 평가하는 항목인 것 같다.</p>
<p>앞으로는 이런 부분도 고려해서 문제를 풀어야 고득점을 받을 수 있을 것 같다....</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="stack,"/>
        <category label="queue"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[프로그래머스] 스택/큐 - 기능개발 문제 풀이]]></title>
        <id>178-programmers-42586</id>
        <link href="https://nostrss.me/blog/178-programmers-42586"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[스택이나 큐를 사용하여 풀어야 하는데 사용하지 않고 풀었다. 언제 어떻게 사용해야 하는걸까..]]></summary>
        <content type="html"><![CDATA[<p>코테 준비를 위해 <code>프로그래머스</code> 문제를 풀고 있다.</p>
<p><code>자료구조</code>의 기본인 <code>스택과큐</code> 관련된 문제를 먼저 풀어보려고 한다.</p>
<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42586">📌 스택/큐 - 기능개발 문제 보러가기 📌</a></p>
<h2>풀이</h2>
<p>일단 나의 문제풀이는 이렇다.</p>
<pre><code class="language-js">function solution(progresses, speeds) {
  var answer = [];

  let copyProgresses = [...progresses];
  let copySpeeds = [...speeds];

  const addProgress = () => {
    const result = copyProgresses.map((progress, index) => {
      return progress + copySpeeds[index];
    });
    copyProgresses = [...result];
  };

  const countDeploy = () => {
    const tmpArray = [...copyProgresses];
    const length = tmpArray.length;
    let count = 0;
    for (let i = 0; i &#x3C; length; i++) {
      if (tmpArray[i] >= 100) {
        copyProgresses.shift();
        copySpeeds.shift();
        count = count + 1;
      } else break;
    }

    if (count !== 0) {
      answer.push(count);
    }
  };

  while (copyProgresses.length > 0) {
    addProgress();
    countDeploy();
  }

  return answer;
}
</code></pre>
<p>일단 함수 2개를 선언하였다.</p>
<ul>
<li>addProgress : progresses에 speeds를 더해주는 함수</li>
<li>countDeploy : 100이 넘는 progresses를 제거하고, answer에 넣어주는 함수</li>
</ul>
<p>그리고 while문을 통해 progresses의 길이가 0이 될 때까지 반복하도록 하였다.</p>
<p>이렇게 문제를 풀었더니 일단 모든 테스트와 채점에서 통과하였다.</p>
<h2>개선 및 문제점</h2>
<h3>개선할 사항</h3>
<p>일단, progresses, speeds 파라미터를 받아서 새로운 변수에 할당하는 부분이 있다.</p>
<p>원본 데이터 정보가 필요할 수도 있을 것 같고, 파라미터를 직접 조작하는 것을 꺼리는 습관 때문에 일단은 이렇게 작업을 했다.</p>
<h3>스택/큐 문제인데 스택이나 큐를 사용하지 않았다.</h3>
<p>이 문제는 스택/큐를 사용하여 풀이하라는 문제인데.. 사용하지를 않고 풀었다.
어떻게 스택과 큐를 적용해야할지 고민해야 할 것 같다.</p>
<h2>chatgpt 풀이</h2>
<pre><code class="language-js">function solution(progresses, speeds) {
  const answer = [];

  while (progresses.length > 0) {
    // 진행상황 업데이트
    progresses = progresses.map((progress, index) => progress + speeds[index]);

    // 배포 가능한 작업 수 계산
    let count = 0;
    while (progresses.length > 0 &#x26;&#x26; progresses[0] >= 100) {
      progresses.shift();
      speeds.shift();
      count++;
    }

    if (count > 0) {
      answer.push(count);
    }
  }

  return answer;
}
</code></pre>
<p>비슷한듯 좀 더 간결한데.. 파라미터를 직접 조작하고 있다. while문을 2번 사용하고 있다.</p>
<p>문제가 배열의 길이가 100개로 제한되어 있어서 그런지 while문을 2번 사용하더라도 효율성 테스트에서 통과하였다.</p>
<p>일단 풀리긴 해서 기분은 좋은데, 먼가 만족스럽게 풀지 못해서 아쉽다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="programmers,"/>
        <category label="algorithm,"/>
        <category label="javascript,"/>
        <category label="stack,"/>
        <category label="queue"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[JS] Array.from() 사용하기]]></title>
        <id>177-javascript-array-from</id>
        <link href="https://nostrss.me/blog/177-javascript-array-from"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[아직도 모르는 것이 많은 자바스크립트. Array.from() 메소드를 사용해보자.]]></summary>
        <content type="html"><![CDATA[<p>자바스크립트에서 많이 사용하는 배열(Array)에는 여러 메소드가 있다.</p>
<p>오늘은 그중 하나인 <code>Array.from(arrayLike, mapFn, thisArg)</code> 메소드를 학습해보려고 한다.</p>
<h2>Array.from(arrayLike, mapFn, thisArg) 메소드란?</h2>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from">📌 MDN 공식 문서 보러가기 📌</a></p>
<blockquote>
<p>Array.from() 정적 메서드는 순회 가능 또는 유사 배열 객체에서 얕게 복사된 새로운 Array 인스턴스를 생성합니다.</p>
</blockquote>
<p>직접 사용해보면서 익혀 보자.</p>
<p>먼저 유사배열 객체가 무엇인지 알아보자.</p>
<pre><code class="language-js">const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
};
</code></pre>
<p>위와 같이 배열은 아니지만 키값이 인덱스로 되어 있고, 길이를 나타내는 length 속성을 가진 객체를 유사배열 객체라고 한다.</p>
<p>Array.from() 메소드는 배열 뿐만 아니라 이런 유사 배열 객체에도 사용할 수 있다.</p>
<h2>Array.from() 메소드 사용하기</h2>
<h3>문자열을 배열로 만들기</h3>
<pre><code class="language-js">console.log(Array.from('foo')); // ['f', 'o', 'o']
</code></pre>
<h3>유사 배열 객체</h3>
<pre><code class="language-js">const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
};

const array = Array.from(arrayLike);
console.log(array); // ['a', 'b', 'c']
</code></pre>
<h3>Set 객체</h3>
<pre><code class="language-js">const set = new Set(['foo', 'bar', 'baz', 'foo']);
console.log(Array.from(set)); // ['foo', 'bar', 'baz']
</code></pre>
<h2>mapFn 사용하기</h2>
<pre><code class="language-js">// 화살표 함수를 map 함수로 사용하여 요소 조작
Array.from([1, 2, 3], (x) => x + x);
// [2, 4, 6]
</code></pre>
<pre><code class="language-js">// 숫자 시퀀스 생성하기
// 배열의 각 위치가 `undefined`로 초기화되므로
// 아래 'v'의 값은 `undefined`가 됩니다.
Array.from({ length: 5 }, (v, i) => i);
// [0, 1, 2, 3, 4]
</code></pre>
<h3>2차원 배열 초기화 하기</h3>
<pre><code class="language-js">let arr2 = new Array(3);

for (let i = 0; i &#x3C; arr2.length; i++) {
  arr2[i] = Array.from({ length: 4 }, (_, j) => i * 4 + j);
}

console.log(arr2);

//[
//  [ 0, 1, 2, 3 ],
//  [ 4, 5, 6, 7 ],
//  [ 8, 9, 10, 11 ]
//]
</code></pre>
<p>아직 사용법이 익숙하지 않지만 알아두면 코딩테스트에서 배열을 초기화 할때, 또는 객체를 배열로 바꿀때 등에서 유용하게 사용할 수 있을 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="javascript"/>
        <category label="array"/>
        <category label="from"/>
        <category label="method"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CS] 어떤 코드가 더 성능이 좋은 코드일까?]]></title>
        <id>176-time-complexity</id>
        <link href="https://nostrss.me/blog/176-time-complexity"/>
        <updated>2023-11-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[시간 복잡도(time complexity)에 대해서 알아보자.]]></summary>
        <content type="html"><![CDATA[<p>예전에 학부시절에 배웠던 개념이지만 복습을 위해 정리해보려고 한다.</p>
<h2>시간 복잡도(time complexity)란?</h2>
<blockquote>
<p>시간 복잡도(Time Complexity)는 컴퓨터 과학과 알고리즘 분석에서 사용되는 개념으로, 어떤 알고리즘, 함수 또는 프로그램의 실행 시간이 입력 크기에 대한 함수로 표현됩니다. 시간 복잡도는 일반적으로 "Big O 표기법" 또는 다른 표기법을 사용하여 나타내며, 알고리즘이 입력 데이터 크기에 따라 어떻게 성장하는지를 나타내는 방식입니다.</p>
</blockquote>
<p><code>시간 복잡도</code>는 정확한 수치를 계산하는 방식은 아니며, 입력값이 <code>무한</code>하다는 가정하에 가장 낮은 차수의 항을 제외시키고 표현한다.</p>
<p>즉, 가장 빠르게 증가하는 항만을 고려하는 표기법이다</p>
<p>예를들면 5n^3 + 3n 이라는 식의 경우 <code>시간복잡도</code>는 <code>O(n^3)</code>이 된다.</p>
<h2>시간 복잡도의 표</h2>
<p>| 시간복잡도 | n           | 1   | 2   | 3    | 4   | 8     | 16             | 32              | 64               | 1000              |
| ---------- | ----------- | --- | --- | ---- | --- | ----- | -------------- | --------------- | ---------------- | ----------------- |
| 1          | 시간/n      | 1   | 1   | 1    | 1   | 1     | 1              | 1               | 1                | 1                 |
| log n      | log(n)      | 0   | 1   | 1.58 | 2   | 3     | 4              | 5               | 6                | 9.97              |
| n          | n           | 1   | 2   | 3    | 4   | 8     | 16             | 32              | 64               | 1000              |
| n log n    | n * log(n) | 0   | 2   | 4.75 | 8   | 24    | 64             | 160             | 384              | 9966              |
| n^2        | n^2         | 1   | 4   | 9    | 16  | 64    | 256            | 1024            | 4096             | 1000000           |
| n^3        | n^3         | 1   | 8   | 27   | 64  | 512   | 4096           | 32768           | 262144           | 1000000000        |
| 2^n        | 2^n         | 2   | 4   | 8    | 16  | 256   | 65536          | 4294967296      | 약 1.844 x 10^19 | 약 1.07 x 10^301  |
| n!         | n!          | 1   | 2   | 6    | 24  | 40320 | 20922789888000 | 약 2.63 x 10^35 | 약 1.27 x 10^89  | 약 4.02 x 10^2567 |</p>
<h2>시간 복잡도의 활용</h2>
<p>사실 아직 현업에서 개발을 하고 있는 친구들에게 시간 복잡도를 고려하면서 개발을 하는지 물어보면 대부분이 그렇지 않다고 한다.</p>
<p>실제로 방대한 코드에서의 시간복잡도를 고려하면서 개발을 하는 것은 매우 어려운 일이다.</p>
<p>하지만 만약 성능을 개선해야하는 경우가 발생한다면, 상대적으로 시간복잡도가 낮은 방향으로 개선을 할 수 있으므로 개념을 잘 알아두면 좋을 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="computer-science"/>
        <category label="time-complexity"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[아니 벌써 Next.js 14가 나왔다고?]]></title>
        <id>175-nextjs-14</id>
        <link href="https://nostrss.me/blog/175-nextjs-14"/>
        <updated>2023-10-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Vercel님들 너무 열심히 하시는 거 아니오? 천천히 좀 합시다.]]></summary>
        <content type="html"><![CDATA[<p><img src="https://github.com/nostrss/next13-blog/assets/56717167/1574a313-a414-4cba-a34e-469ce0044319" alt="twitter-card"></p>
<p>Vercel에서 Next.js 14가 나왔다고 한다.</p>
<p><a href="https://nextjs.org/blog/next-14">📌 Next.js 14 공식 블로그 📌</a>
<a href="https://nextjs.org/conf">📌 Next.js 14 Conf 보러가기 📌</a></p>
<p>정말 너무 빠른 속도로 새로운 버전들이 쏟아 지는 것 같다. 이제 13버전이 나온지 얼마 안된 것 같은데 벌써 14버전이 나왔다니...</p>
<p>어쨌든 <code>Next.js 14</code>는 무엇이 달라졌는지 알아보자.</p>
<p>위의 블로그를 살펴보면 <code>4가지</code> 주요 업데이트가 있다고 한다.</p>
<ul>
<li>Turbopack</li>
<li>Server Actions</li>
<li>Partial Prerendering(preview)</li>
<li>Next.js Learn</li>
</ul>
<h2>Turbopack</h2>
<p><a href="https://nextjs.org/blog/next-14#nextjs-compiler-turbocharged">📌 Next.js 14 Turbopack 공식 문서 보러가기 📌</a></p>
<p>공식문서를 번역기로 돌려서 확인해봤다.</p>
<blockquote>
<p>Next.js 13부터 우리는 페이지와 앱 라우터 모두에서 Next.js의 로컬 개발 성능을 개선하기 위해 노력해 왔습니다.</p>
</blockquote>
<blockquote>
<p>next dev이전에는 이러한 노력을 지원하기 위해 Next.js의 다른 부분을 다시 작성했습니다 . 이후 우리는 접근 방식을 좀 더 점진적으로 변경했습니다. 이는 우리가 먼저 모든 Next.js 기능을 지원하는 데 다시 집중했기 때문에 Rust 기반 컴파일러가 곧 안정성에 도달할 것임을 의미합니다.</p>
</blockquote>
<blockquote>
<p>next dev이제 Turbopack을 통해 5,000개의 통합 테스트를 통과했습니다., 우리의 기본 Rust 엔진입니다. 이 테스트에는 7년간의 버그 수정 및 재현이 포함됩니다.</p>
</blockquote>
<blockquote>
<p>vercel.com대규모 Next.js 애플리케이션을 테스트하는 동안 우리는 다음을 확인했습니다.</p>
</blockquote>
<blockquote>
<ul>
<li>최대 53.3% 더 빠른 로컬 서버 시작</li>
<li>빠른 새로 고침으로 최대 94.7% 더 빠른 코드 업데이트</li>
</ul>
</blockquote>
<blockquote>
<p>이 벤치마크는 대규모 애플리케이션(및 대규모 모듈 그래프)에서 기대할 수 있는 성능 향상의 실제 결과입니다. 현재 테스트의 90%가 next dev통과되었으므로 next dev --turbo.</p>
</blockquote>
<blockquote>
<p>테스트를 100% 통과하면 향후 마이너 릴리스에서 Turbopack을 안정 버전으로 이동할 예정입니다. 또한 사용자 정의 구성 및 생태계 플러그인을 위해 webpack 사용을 계속 지원할 예정입니다.</p>
</blockquote>
<h2>Server Actions</h2>
<p>Next.js 13 에서 소개 된 <code>Server Actions</code> 의 안정화 단계에 들어갔다.</p>
<p>그리고 14 버전에서는 아래과 같은 변화가 있다.</p>
<ul>
<li>통합된 캐싱 및 재검증</li>
<li>간단한 함수 호출 또는 기본적으로 form에서 작동</li>
</ul>
<p>2번째 기능은 새로 추가된 것 같은데 <code>form</code> 태그를 사용할 떄 처리방식에서 변화가 있는 것으로 예상된다.</p>
<h2>Partial Prerendering(preview)</h2>
<p><a href="https://nextjs.org/blog/next-14#partial-prerendering-preview">📌 Next.js 14 Partial Prerendering 공식 문서 보러가기 📌</a></p>
<p>이번에도 번역기로 간단히 살펴보았다.</p>
<blockquote>
<p>우리는 Next.js를 위해 작업 중인 부분 사전 렌더링(빠른 초기 정적 응답을 갖춘 동적 콘텐츠에 대한 컴파일러 최적화)의 미리 보기를 공유하고 싶습니다.</p>
</blockquote>
<blockquote>
<p>부분 사전 렌더링은 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 및 증분 정적 재검증(ISR)에 대한 10년 간의 연구 개발을 기반으로 구축되었습니다.</p>
</blockquote>
<blockquote>
<p>동기 부여
우리는 귀하의 의견을 들었습니다. 현재 고려해야 할 런타임, 구성 옵션 및 렌더링 방법이 너무 많습니다. 귀하는 정적 속도와 안정성을 원하면서도 완전히 동적이고 개인화된 응답을 지원하기를 원합니다.</p>
</blockquote>
<blockquote>
<p>전 세계적으로 뛰어난 성능 과 개인화 기능을 갖추려면 복잡성이 희생되어서는 안 됩니다.</p>
</blockquote>
<blockquote>
<p>우리의 과제는 개발자가 배울 수 있는 새로운 API를 도입하지 않고 기존 모델을 단순화하여 더 나은 개발자 환경을 만드는 것이었습니다. 서버 측 콘텐츠의 부분 캐싱이 존재했지만 이러한 접근 방식은 여전히 ​​우리가 목표로 하는 개발자 경험과 구성 가능성 목표를 충족해야 합니다.</p>
</blockquote>
<blockquote>
<p>부분 사전 렌더링에는 학습하는 데 새로운 API가 필요하지 않습니다.</p>
</blockquote>
<p><code>Partial Prerendering</code>의 경우 <code>React</code> <code>Suspend</code>를 기반으로 구현된 것 같은데 아직은 개발중인 것으로 보여서, 실제로 사용하려면 조금 더 기다려야 할 것 같다.</p>
<h2>Next.js Learn</h2>
<p><a href="https://nextjs.org/learn">📌 Next.js learn 페이지 바로가기 📌</a></p>
<p>공식 홈페이지에 Next.js를 배울 수 있는 페이지가 생겼다.</p>
<blockquote>
<p>내가 보기엔 Next 12에서 13으로 넘어갈 때 만큼의 큰 변화는 없는 것 같다. 이번 업데이트는 Next.js를 사용하고 있는 개발자에게 더 좋은 성능과 개발경험을 제공하려는 업데이트 인 것 같다.</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="vercel"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[모노레포란 무엇인가?]]></title>
        <id>173-concept-monorepo</id>
        <link href="https://nostrss.me/blog/173-concept-monorepo"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[여러분은 어떤 구조로 프로젝트를 진행하고 계신가요?]]></summary>
        <content type="html"><![CDATA[<p>요새 프런트엔드 기술과 공고를 보다 보면 아래와 같은 내용을 자주 볼 수 있었다.</p>
<blockquote>
<p>우대사항 : 모노레포 관련 경험 자</p>
</blockquote>
<p>면접때도 한번 질문을 받은 경험이 있었는데, 경험해보지 못했다고 말하고 넘어갔었는데 이번에 한번 알아보려고 한다.</p>
<h2>등장 배경</h2>
<p><a href="https://d2.naver.com/helloworld/0923884">📌 (참고) 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편 📌</a></p>
<p>일단 <code>모노레포</code>가 등장한 배경을 알아보자.</p>
<p><code>모노레포</code>가 등장하기전 소프트웨어 애플리케이션은 모듈화가 되지 않은 상태로 개발되었다.</p>
<p>아래의 그림을 살펴보자.</p>
<p><img src="https://github.com/nostrss/next13-blog/assets/56717167/cb60cd81-a94c-40e2-a469-3f1ad93c3de5" alt="0a710ba9-7e47-1064-817f-86e0ae025d1b"></p>
<p>위의 구조는 <code>모놀리식</code>이라 불리는 <code>모노레포</code> 이전의 소프트웨어의 모습이다.</p>
<p>블로그와 같은 작은 프로젝트라면 위의 구조가 괜찮을 수 있지만, 만약 구글, 페이스북, 인스타그램과 같이 거대 프로젝트라면 어떨까?</p>
<p>내가 생각하기에 일단 아래와 같은 문제가 발생할 것 같다.</p>
<ul>
<li>로컬에 소스코드 클론 시 그 용량이 어마 무시 할 것 같다.</li>
<li>빌드 시간이 오래 걸리고 배포의 단위가 매우 커질 것 같다.</li>
</ul>
<p>이런 한계를 극복하기 위한 방법중에 하나로 <code>멀티레포(폴리레포)</code>의 구조도 존재한다.</p>
<p><img src="https://github.com/nostrss/next13-blog/assets/56717167/5436e609-7090-494e-817d-ad31e310a0cd" alt="0a710ba9-7e47-1064-817f-86e13d875e4e (1)"></p>
<p>각 기능, 관심사별로 구분된 독자적인 저장소(레포지토리)를 가지고 있는 구조이다.</p>
<p>그렇기 때문에 각 프로젝트별로 <code>자율성</code>이 매우 높고, <code>독립</code>적인 개발, `빌드`` 등이 가능한 구조이다.</p>
<p>내가 회사는 일했던 멀티레포를 변형한 구조로 운영이 되었었다.</p>
<p>개인적으로 느꼈던 멀티레포의 장,단점 아래와 같다.</p>
<ul>
<li>
<p>장점</p>
<ul>
<li>각 프로젝트별로 자율성이 높다.</li>
<li>각 프로젝트별의 규모가 작아진다.</li>
<li>빌드, 테스트, 배포의 범위가 작아진다.</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>중복코드가 존재하게 된다.</li>
<li>관리 포인트가 많아진다.</li>
<li>일관성 없는 코드 컨벤션이 발생할 수 있다.</li>
<li>패키지 버전의 일관성이 없을 수 있다.</li>
</ul>
</li>
</ul>
<p>나는 멀티레포의 <code>단점</code>들이 더 크게 다가왔었는데, 레포의 개수가 10개가 넘어가는 서비스를 혼자 관리하다 보니 어려움이 많았다.</p>
<p>특히 <code>React</code>의 버전이 15부터 17까지 다양하게 존재해서 hooks를 쓸 수 없는 프로젝트도 있었고, 어떤 프로젝트는 Typescript를 적용한 프로젝트도 있었다.</p>
<p>거기에 상태관리 라이브러리도 redux, mobx, redux-toolkit등 다양하게 버전별로 존재하다 보니 개발하기 매우 어려웠다.</p>
<blockquote>
<p>개인적인 생각이지만 멀티레포의 경우 규모가 큰 회사에서 팀별로 레포를 하나씩 담당할때 적합한 구조인 것 같다.</p>
</blockquote>
<h2>모노레포란?</h2>
<blockquote>
<p>모노레포(monorepo) 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략이다. 앞선 예시의 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만 저장소는 같은 곳을 사용한다.</p>
</blockquote>
<p><img src="https://github.com/nostrss/next13-blog/assets/56717167/320c8923-f1fd-44b3-ba16-839d5f55fdc1" alt="0a710ba9-7e47-1064-817f-86e20998613f"></p>
<p>단순히 개념을 잡아보면 하나의 깃허브 저장소에 로그인 프로젝트, 회원가입 프로젝트, 게시글 프로젝트 등등 여러 프로젝트를 모아놓은 구조이다.</p>
<p>하지만 여기서 추가적인 모노레포의 특징이 있다. 바로 <code>프로젝트 간의 관계</code>이다.</p>
<p>흔히 모노레포에서는 프로젝트 사이에 의존성이 존재하거나 같은 제품군이거나 하는 정의된 관계가 존재한다고 한다.</p>
<p>그리고 관계를 관리할 수 있는 모노레포 관리 도구도 존재하는데 <code>Lerna</code>, <code>Yarn</code>, <code>npm</code>, <code>pnpm</code>, <code>Nx</code>을 많이 사용한다고 한다.</p>
<p>이런 <code>모노레포</code>는 멀티레포의 문제를 이렇게 해결한다.</p>
<ul>
<li>쉬운 프로젝트 생성</li>
<li>쉬운 의존성 관리</li>
<li>단일화된 관리 포인트</li>
<li>일관된 개발자 경험 제공</li>
<li>테스트 및 빌드 시간 단축</li>
</ul>
<p>요즘들어 프론트엔드 개발자가 javascript, react, next를 잘 하는 것도 알아야 하지만</p>
<p>상황과 인력구조에 따라 개발환경이나 프로제팅 구조를 변경하는 능력도 필요하다고 느껴진다.</p>
<blockquote>
<p>알아야 할 게 너무 많다..</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="monorepo"/>
        <category label="multi-repo"/>
        <category label="monolithic"/>
        <category label="frontend"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Babylon.js를 이용한 3D 페이지 만들어보기]]></title>
        <id>174-first-babylonjs</id>
        <link href="https://nostrss.me/blog/174-first-babylonjs"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[브라우저에서도 3D를 구현할 수 있다는 것을 알고 계셨나요?]]></summary>
        <content type="html"><![CDATA[<p>예전에 우연히 정말 <code>아름답다</code>고 생각한 <code>프랑스</code>의 웹페이지를 본적이 있었다.</p>
<p><a href="https://chartogne-taillet.com/fr">📌 그림과 배경음악이 아름다운 페이지 📌</a></p>
<blockquote>
<p>와 이런 페이지는 어떻게 만든걸까? 정말 대단하다.</p>
</blockquote>
<p>라는 생각이 절로 들게 했던 웹페이지였다. 그리고 이런 페이지를 만들려면 어떻게 해야할까 라는 생각이 들었었다. <code>3D</code>를 이용한 것 같은데, 구체적으로는 어떤 기술을 사용했을지 감이 잘 오지 않았다.</p>
<p>마치 마을하나 전체를 렌더링하고 클릭할 경우 그 마을로 이동하는 효과가 아주 압권이었다.</p>
<p>그런데 위의 웹페이지를 구현할 수 있을 것 같은 기술을 하나 찾은 것 같아 알아 보려고 한다.</p>
<p>바로 <code>Babylon.js</code>이다. 요새 <code>three.js</code>와 같이 브라우저에서 3D를 구현하는 기술들이 자주 언급이 되고 있는데 그 중에 하나이다.</p>
<h2>Babylon.js란?</h2>
<p><a href="https://www.babylonjs.com/">📌 Babylon.js 공식 홈페이지 바로가기 📌</a></p>
<p><code>Babylon.js</code>는 <code>마이크로소프트</code>에서 개발했고 <code>구글팀</code>도 협력하여 만든 3D 렌더링 엔진이다. 마이크로소프트가 만들었기 때문에 <code>Typescript</code>를 지원하는 장점이 있고 그만큼 <code>신뢰도</code>가 높다고 생각한다.</p>
<p>하지만 <code>three.js</code> 만큼 아직 커뮤니티가 활성화 되어있지는 않아서 인지 검색 시 예제가 많이 부족한 것 같았다.</p>
<p>그리고 자세하게는 모르지만 <code>webGPU</code>를 지원하기 때문에 <code>webGL</code>보다 더 빠른 렌더링이 가능하다고 한다.</p>
<h2>Babylon.js를 이용한 3D 페이지 만들어보기</h2>
<p>Next.js 프로젝트를 생성하고 <code>Babylon.js</code>를 설치해 줬다.</p>
<p><a href="https://doc.babylonjs.com/setup/frameworkPackages/es6Support#application-creation-summary">📌 Babylon.js 설치 문서 보기 📌</a></p>
<p><a href="https://doc.babylonjs.com/communityExtensions/Babylon.js+ExternalLibraries/BabylonJS_and_ReactJS">📌 Babylon.js + React 문서 보기 📌</a></p>
<p>그리고 react 관련 공식 문서를 참고하여 렌더링 될 컴포넌트를 아래처럼 생성해주었다.</p>
<pre><code class="language-tsx">import { useEffect, useRef } from 'react';
import {
  Engine,
  FreeCamera,
  HemisphericLight,
  MeshBuilder,
  Scene,
  Vector3,
} from '@babylonjs/core';

let box: any;
let sphere: any;

const SceneComponent = ({
  antialias,
  engineOptions,
  adaptToDeviceRatio,
  sceneOptions,
  cameraPosition,
  ...rest
}: any) => {
  // canvas요소를 참조할 ref 생성
  const reactCanvas = useRef(null);

  // set up basic engine and scene
  useEffect(() => {
    const { current: canvas } = reactCanvas;

    // canvas가 없으면 종료
    if (!canvas) return;

    // Babylon.js engine 생성
    const engine = new Engine(
      canvas,
      antialias,
      engineOptions,
      adaptToDeviceRatio
    );

    const scene = new Scene(engine, sceneOptions);

    // scene.isReady()가 true이면 onSceneReady() 호출
    if (scene.isReady()) {
      onSceneReady(scene, cameraPosition);
    } else {
      // scene.isReady()가 false이면 scene.onReadyObservable에 onSceneReady()를 추가
      scene.onReadyObservable.addOnce((scene) =>
        onSceneReady(scene, cameraPosition)
      );
    }

    engine.runRenderLoop(() => {
      if (typeof onRender === 'function') onRender(scene);
      scene.render();
    });

    const resize = () => {
      scene.getEngine().resize();
    };

    if (window) {
      window.addEventListener('resize', resize);
    }

    return () => {
      scene.getEngine().dispose();

      if (window) {
        window.removeEventListener('resize', resize);
      }
    };
  }, [
    antialias,
    engineOptions,
    adaptToDeviceRatio,
    sceneOptions,
    cameraPosition,
  ]);

  return &#x3C;canvas style={{ width: '100%' }} ref={reactCanvas} {...rest} />;
};

const onSceneReady = (scene: any, cameraPosition: any) => {
  // This creates and positions a free camera (non-mesh)
  const camera = new FreeCamera('camera1', cameraPosition, scene);

  // This targets the camera to scene origin
  camera.setTarget(Vector3.Zero());

  const canvas = scene.getEngine().getRenderingCanvas();

  // This attaches the camera to the canvas
  camera.attachControl(canvas, true);

  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
  const light = new HemisphericLight('light', new Vector3(0, 1, 0), scene);

  // Default intensity is 1. Let's dim the light a small amount
  light.intensity = 0.7;

  // Our built-in 'box' shape.
  box = MeshBuilder.CreateBox('box', { size: 2 }, scene);
  // Move the box upward 1/2 its height
  box.position.y = 0;

  sphere = MeshBuilder.CreateSphere('sphere', { diameter: 2 }, scene);

  sphere.position.x = 4;
  sphere.position.y = 2;

  // Our built-in 'ground' shape.
};

const onRender = (scene: any) => {
  if (box !== undefined) {
    const deltaTimeInMillis = scene.getEngine().getDeltaTime();

    const rpm = 10;
  }
};

export default SceneComponent;
</code></pre>
<p>다음에는 아래와 같이 import 해주어 위에서 생성한 컴포넌트를 사용해주었다.
그리고 useState 사용하여 버튼을 클릭하면 3D 환경에서의 <code>카메라 뷰</code>의 위치를 변경해도록 수정하였다.</p>
<pre><code class="language-tsx">import { Vector3 } from '@babylonjs/core';
import SceneComponent from '@/components/SceneComponents';
import { useState } from 'react';
import styled from '@emotion/styled';

export default function Home() {
  const [cameraPosition, setCameraPosition] = useState(new Vector3(0, 3, -5));

  const boxPosition = new Vector3(0, 3, -3);
  const spherePosition = new Vector3(7, 4, 0);

  const moveToBox = () => {
    setCameraPosition(boxPosition);
  };

  const moveToSpehere = () => {
    setCameraPosition(spherePosition);
  };

  return (
    &#x3C;>
      &#x3C;main>
        &#x3C;Button onClick={moveToBox}>Goto Box&#x3C;/Button>
        &#x3C;Button onClick={moveToSpehere}>Goto Sphere&#x3C;/Button>
        &#x3C;SceneComponent
          antialias
          id='my-canvas'
          cameraPosition={cameraPosition}
        />
      &#x3C;/main>
    &#x3C;/>
  );
}

const Button = styled.button`
  padding: 5px;
  background-color: hotpink;
  font-size: 24px;
  border-radius: 4px;
  color: black;
  font-weight: bold;
  &#x26;:hover {
    color: white;
  }
`;
</code></pre>
<h2>결과</h2>
<p><a href="https://babylon-sample.vercel.app/">📌 결과보기 📌</a></p>
<h3>초기화면</h3>
<h3>Box 클릭 시</h3>
<h3>Sphere 클릭 시</h3>
<p>처음에 본 웹페이지처럼 아직 아름답지는 않지만 박스와 구가 마을이라고 가정하면 마을을 이동하는 원리는 구현된 것 같은 느낌이다.</p>
<blockquote>
<p>3D 재밌는데?</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="babylonjs"/>
        <category label="3d"/>
        <category label="nextjs"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서버(Nest.js)와 Front(Next)가 Type을 공유하는 방법(openapi-tools).]]></title>
        <id>172-nestjs-openapi-codegen</id>
        <link href="https://nostrss.me/blog/172-nestjs-openapi-codegen"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이제 Front에서 type을 서버에서 다운받아 사용하자.]]></summary>
        <content type="html"><![CDATA[<p>Front에서 작업을 하다보면 Type을 지정하는 일이 제법 손이 많이 간다.</p>
<p>특히 data의 내용이 큰 경우에는 더더욱 그렇다.</p>
<p>그러다가 예전에 <code>codegen</code>을 사용했던 기억이 났다. 그때는 <code>graphql</code>을 사용했었고, 서버에서 <code>type</code>을 받아 프론트에서 생성해서 사용할 수 있었다.</p>
<p><code>rest api</code>에서도 사용할 수 있지 않을까 해서 찾아보았다.</p>
<h2>Nest.js Server</h2>
<p>먼저 Nest.js에 <code>nestjs-openapi-tools</code>를 설치해주자.</p>
<p><a href="https://www.npmjs.com/package/nest-openapi-tools/v/4.0.0">📌 nest-openapi-tools npm 페이지 바로가기 📌</a></p>
<p>그리고 <code>main.ts</code>에 아래와 같이 추가해주자.</p>
<pre><code class="language-ts">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder } from '@nestjs/swagger';
import { HttpExceptionFilter } from './exceptions/http.exceoptions';
import { OpenApiNestFactory } from 'nest-openapi-tools';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalFilters(new HttpExceptionFilter());

  await OpenApiNestFactory.configure(
    app,
    new DocumentBuilder()
      .setTitle('My API')
      .setDescription('An API to do awesome things')
      .addBearerAuth(),
    {
      webServerOptions: {
        enabled: true,
        path: 'api-docs',
      },
      fileGeneratorOptions: {
        enabled: true,
        outputFilePath: './openapi.yaml',
      },
      clientGeneratorOptions: {
        enabled: true,
        type: 'typescript-axios',
        outputFolderPath: '../typescript-api-client/src',
        additionalProperties:
          'apiPackage=clients,modelPackage=models,withoutPrefixEnums=true,withSeparateModelsAndApi=true',
        openApiFilePath: './openapi.yaml',
        skipValidation: true,
      },
    },
    {
      operationIdFactory: (c: string, method: string) => method,
    }
  );

  await app.listen(3000);
}
bootstrap();
</code></pre>
<p>그리고 nest 서버를 실행시켜보자.</p>
<pre><code class="language-bash">yarn start:dev
</code></pre>
<p>그러면 <code>openapi.yaml</code>과 <code>openapitools.json</code> 파일이 생성된 것을 확인할 수 있다.</p>
<p>이렇게 하면 서버측 준비는 끝나게 된다.</p>
<h2>Front-end(Next.js)</h2>
<p>이제 front에서 <code>openapi.yaml</code>을 받아서 사용해보자.</p>
<p>나는 Next.js 프로젝트를 생성해서 사용했다.</p>
<p>그리고 <code>@openapitools/openapi-generator-cli</code> 패키지를 설치해주자.</p>
<p><a href="https://www.npmjs.com/package/@openapitools/openapi-generator-cli">📌 @openapitools/openapi-generator-cli npm 페이지 바로가기 📌</a></p>
<pre><code class="language-bash">yarn add @openapitools/openapi-generator-cli
</code></pre>
<p>그리고 package.json에 아래와 같이 추가해주자.</p>
<blockquote>
<p>openapi.yaml 파일을 서버에 올리지 않고 테스트만 하는 거라, nest.js에서 생성된 openapi.yaml 파일을 복사해서 프론트 프로젝트의 루트에 붙여넣었다.</p>
</blockquote>
<pre><code class="language-json">{
  "scripts": {
    "codegen": "npx @openapitools/openapi-generator-cli generate -i openapi.yaml -g typescript-axios --additional-properties apiPackage=apis,modelPackage=models,withoutPrefixEnums=true,withSeparateModelsAndApi=true --global-property models -o ./src/openapi --skip-validate-spec "
  }
}
</code></pre>
<p>그리고 <code>yarn codegen</code>을 실행시켜주자.</p>
<p>그러면 터미널에서 아래와 같이 실행이 되는 것을 확인할 수 있다.</p>
<p>완료가 되면 <code>src/openapi</code> 폴더가 생성되고 그 안에 <code>models</code> 폴더가 생성된 것을 확인할 수 있다.</p>
<p>그리고 여러 <code>ts</code> 파일들이 생성된 것을 확인할 수 있는데, 파일의 내용을 살펴보면 <code>nest.js</code> 서버에서 작성한 <code>openapi.yaml</code> 파일을 기반으로 <code>type</code>들이 생성되어 있는 것을 확인할 수 있다.</p>
<p>이제 프론트에서는 이렇게 생성된 <code>type</code>들을 사용하여 개발을 하면 된다!</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="openapi"/>
        <category label="codegen"/>
        <category label="type"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nest.js에 Postgres DB를 연결해보자.]]></title>
        <id>171-nestjs-postgres</id>
        <link href="https://nostrss.me/blog/171-nestjs-postgres"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docker Container에 Postgres를 설치하고 typeorm으로 Nest.js와 연동해보자]]></summary>
        <content type="html"><![CDATA[<p>이제 <code>Nest.js</code>에서 사용할 DB를 설치 및 연결해보려고 한다.</p>
<p>DB는 <code>Postgres</code>를 사용할 것이다. 이유는 딱히 정해진 것은 없는데, 왜인지 내가 찾은 블로그나 글들을 보면 <code>postgres</code>를 사용한 경우가 많았다.</p>
<p><a href="https://www.postgresql.org/">📌 Postgres 홈페이지 바로가기 📌</a></p>
<p><code>Postgres</code>가 <code>Nest.js</code>와 궁합이 잘 맞는건지 아직은 잘 모르겠다. 일단 <code>postgres</code>를 사용해보고 추후에는 <code>MySQL</code>로도 작업을 한번 해봐야 할 것 같다.</p>
<h2>Docker Container에 Postgres 설치하기</h2>
<h3>Docker 설치하기</h3>
<p>먼저 아래 링크로 이동하여 <code>Docker Desktop</code>을 설치해준다.</p>
<p><a href="https://www.docker.com/get-started/">📌 Docker 설치 페이지 바로가기📌</a></p>
<h3>.docker-compose 파일을 작성, Container 생성하기</h3>
<p>프로젝트 root 경로에 <code>.docker-compose.yml</code> 파일을 생성하고 아래와 같이 작성해주었다.</p>
<pre><code class="language-text">version: '3.1'

volumes:
  postgres_data:

services:
  postgres:
    image: postgres:14.7
    container_name: postgres
    ports:
      - '5434:5432'
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: always

</code></pre>
<h3>Container 실행하기(띄우기)</h3>
<p>터미널에서 아래 명령어를 입력하여 <code>Container</code>를 실행해준다.</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<blockquote>
<p>이때 docker desktop이 실행되어 있어야 한다.</p>
</blockquote>
<p>그러면 <code>docker-compose.yml</code> 파일에 작성한대로 <code>postgres</code>가 <code>pull</code> 되고, <code>Container</code>가 생성된다.</p>
<p><code>Container</code>를 내리기 위해서는 아래 명령어를 입력해주면 된다.</p>
<pre><code class="language-bash">docker-compose down
</code></pre>
<h3>생성된 Container 확인하기</h3>
<p>터미널에서 아래 명령어를 입력하여 <code>Container</code>가 잘 생성되었는지 확인해보자.</p>
<pre><code class="language-bash">docker ps --all
</code></pre>
<p>터미널이 아니라 좀 전에 설치한 <code>Docker Desktop</code>에서도 확인할 수 있다.</p>
<h2>typeorm 설치 및 설정하기</h2>
<h3>typeorm 설치하기</h3>
<p>이제 Nest.js에서 postgres를 사용하기 위해 <code>typeorm</code>을 설치하여 설정해주어야 한다.</p>
<p>아래와 같이 3개의 패키지를 설치해주자.</p>
<pre><code class="language-bash">yarn add @nestjs/typeorm typeorm pg
</code></pre>
<h3>postgres.config.ts 파일 작성하기</h3>
<p><code>config</code>폴더를 생성하여 <code>postgres.config.ts</code> 파일을 생성해주고 아래와 같이 작성해주었다.</p>
<pre><code class="language-ts">// src/config/postgres.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('postgres', () => ({
  host: process.env.POSTGRES_HOST || 'localhost',
  port: process.env.POSTGRES_PORT ? Number(process.env.POSTGRES_PORT) : 5434,
  database: process.env.POSTGRES_DATABASE || 'postgres',
  username: process.env.POSTGRES_USERNAME || 'postgres',
  password: process.env.POSTGRES_PASSWORD || 'postgres',
}));
</code></pre>
<h3>app.module.ts 파일 수정하기</h3>
<pre><code class="language-ts">import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule, TypeOrmModuleOptions } from '@nestjs/typeorm';
import postgresConfig from './config/postgres.config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [postgresConfig],
    }),
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const obj: TypeOrmModuleOptions = {
          type: 'postgres',
          host: configService.get('postgres.host'),
          port: configService.get('postgres.port'),
          database: configService.get('postgres.database'),
          username: configService.get('postgres.username'),
          password: configService.get('postgres.password'),
          autoLoadEntities: true,
          logging: true,
          // prod에서는 사용하지 않는 것이 좋다.가급적이면 끄고 사용하길 추천한다.
          synchronize: false,
        };
        return obj;
      },
    }),
  ],
})
export class AppModule {}
</code></pre>
<p>여기서 <code>TypeOrmModuleOptions</code>의 <code>synchronize</code> 속성은 주의가 필요하다.</p>
<p>왜냐하면 <code>synchronize</code> 속성을 <code>true</code>로 설정하면 <code>Nest.js</code>가 실행될 때 수정된 <code>entity</code>를 자동으로 DB에 반영해주기 때문이다.</p>
<p>이로인해 예기치 않은 data의 손실과 에러가 발생할 수 있으므로, prod에서는 사용하지 않는 것이 좋다고 한다.</p>
<p>몇몇 글을 보면 개발 단계에서도 아예 <code>false</code>로 끄고 개발을 하는 것이 좋다고 한다.</p>
<blockquote>
<p>이제 <code>Nest.js</code>에서 <code>postgres</code>를 사용할 준비가 끝났다.</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="docker"/>
        <category label="postgres"/>
        <category label="typeorm"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nest.js에 swagger 적용하기]]></title>
        <id>170-nestjs-swagger</id>
        <link href="https://nostrss.me/blog/170-nestjs-swagger"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[백엔드 문서화의 시작, swagger를 사용해보자]]></summary>
        <content type="html"><![CDATA[<p>프론트 작업을 할때 api 문서를 <code>postman</code> 또는 <code>swagger</code>로 백엔드와 소통하며 작업을 진행한적이 있었다. 이번에는 내가 그 문서를 설정하는 작업을 해보려고 한다.</p>
<p><a href="https://docs.nestjs.com/openapi/introduction#document-options">📌 Nest.js 문서 바로가기 📌</a></p>
<h2>@nestjs/swagger 설치하기</h2>
<p><code>swagger</code> 문서를 만들기 위해서는 <code>@nestjs/swagger</code> 패키지가 필요하다.</p>
<pre><code class="language-bash">yarn add @nestjs/swagger
</code></pre>
<h2>main.ts에 설정하기</h2>
<p>그리고 아래와 같이 <code>main.ts</code>에 코드를 추가해주었다.</p>
<pre><code class="language-ts">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import {
  DocumentBuilder,
  SwaggerCustomOptions,
  SwaggerModule,
} from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // swagger 설정 시작
  const swaggerConfig = new DocumentBuilder()
    .setTitle('FetchApi') // 문서 제목
    .setDescription('FetchApi project API description') // 문서 설명
    .setVersion('1.0') // 문서 버전
    .addBearerAuth() // Authorization 버튼 활성화
    .build();

  // Authorization 유지 설정(새로고침해도 토큰이 날아가지 않도록)
  const swaggerCustomOptions: SwaggerCustomOptions = {
    swaggerOptions: {
      persistAuthorization: true,
    },
  };

  const swaggerDocument = SwaggerModule.createDocument(app, swaggerConfig);
  SwaggerModule.setup('docs', app, swaggerDocument, swaggerCustomOptions);

  // swagger 설정 끝

  await app.listen(3000);
}
bootstrap();
</code></pre>
<p>그리고 http://localhost:3000/docs에 접속하면 swagger 문서를 확인할 수 있다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="docker"/>
        <category label="swagger"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nest.js + docker + AWS + Github Actions를 이용한 배포 자동화]]></title>
        <id>169-nestjs-deploy-aws-actions</id>
        <link href="https://nostrss.me/blog/169-nestjs-deploy-aws-actions"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이제 백엔드도 배포를 해보자]]></summary>
        <content type="html"><![CDATA[<p>최근 Nest.js를 공부하면서 AWS에 배포를 하면서 Docker를 다룰 수 있는 기회가 있었고, Github Actions를 이용한 배포 자동화도 해보았다.</p>
<p>강의를 따라서 진행했었지만, 나혼자 직접 배포를 하는 연습도 해볼겸 정리해보려고 한다.</p>
<p><a href="https://github.com/nostrss/nestjs-study">📌 깃허브 레파지토리 바로가기 📌</a></p>
<h2>Nest.js 프로젝트 생성하기</h2>
<p>배포할 Nest.js 프로젝트를 하나 생성해서 준비하자.</p>
<p><a href="https://docs.nestjs.com/first-steps">📌 Nest.js 공식문서 바로가기 📌</a></p>
<pre><code class="language-bash">$ npm i -g @nestjs/cli
$ nest new project-name
</code></pre>
<p>이번엔 배포에 중점을 둘 것이기 때문에 일단 간단히 프로젝트만 생성하고 별도의 추가 코드는 작성하지 않았다.</p>
<p>프로젝트를 생성하면 github 레파지토리와 연결하여 push 해두자.</p>
<h2>Dockerfile 작성하기</h2>
<p>위에서 생성한 프로젝트의 root위치에 아래와 같이 Dockerfile을 작성했다.</p>
<pre><code class="language-Dockerfile">FROM node:18.14.2 AS builder
RUN mkdir -p /app
WORKDIR /app
ADD . .

RUN npm install
RUN npm run build

CMD npm run start:prod
</code></pre>
<p>각 명령어에 대해서도 설명을 하고 싶지만 오늘은 배포 자동화를 기록으로 남기기 위함이니 간단히만 설명하고 넘어가야 할 것 같다.</p>
<p>그리고 추가로 .dockerignore 파일도 작성해줬다.</p>
<pre><code>node_module/
dist/
</code></pre>
<h2>github 토큰 생성하기(Classic)</h2>
<p>github에 접속해서 Personal access tokens를 생성한다.</p>
<p><a href="https://github.com/settings/tokens">📌 github token 발행하기 바로가기 📌</a></p>
<ul>
<li>
<p>Note는 개인이 식별할 수 있도록 작성하면 될 듯하고, 하단의 권한은 이미지와 같이 repo, workflow, write:packages, read:packages를 선택해줬다.</p>
<blockquote>
<p>그리고 생성된 토큰은 별도로 복사해두자.</p>
</blockquote>
</li>
</ul>
<h3>github token을 Secrets에 등록하기</h3>
<p>이제 위에서 생성한 github token을 Nest.js 프로젝트의 Secrets에 등록해줘야 한다.</p>
<p>Nest.js 깃허브 레파지토리로 이동하자.</p>
<p>그리고 settings -> Secrets and variables --> Actions로 이동한다.</p>
<p>그리고 New repository secret을 클릭해서 등록을 진행하자.</p>
<p>나 같은 경우 Name은 GHCR_TOKEN로 작성했고, Secret에는 위에서 생성한 github token을 넣어줬다.</p>
<h2>AWS EC2 인스턴스 생성하기</h2>
<p>비용은 최대한 아끼는 것이 좋으니 무료 free-tier 계정으로 생성하였다.</p>
<p>인스턴스 생성은 아래와 같이 진행하였다.</p>
<blockquote>
<p>키-페어 생성</p>
</blockquote>
<p>키-페어를 생성하면 마치 공인인증서와 같이 생긴 .pem 파일이 자동으로 다운로드 된다. 이 파일은 나중에 ssh 접속할 때 필요하니 잘 보관해두자.</p>
<blockquote>
<p>네트워크 설정, 스토리지(볼륨)</p>
</blockquote>
<p>free-tier 계정으로 생성하면 30GB까지 무료로 사용할 수 있다. 이왕 쓰는거 최대한 다 쓰도록 설정해봤다.</p>
<p>인스턴스 시작 버튼을 누르고 잠시 기다리면 인스턴스가 생성된다.</p>
<h3>AWS 인스턴스에 ssh 접속하기</h3>
<p>이제 내가 만든 인스턴스 우분투 서버에 접속을 해보자.</p>
<p>터미널을 열고 아래와 같이 명령어를 입력한다.</p>
<pre><code class="language-bash">$ ssh -i {키-페어 파일 경로.pem} ubuntu@{인스턴스 퍼블릭 IP}
</code></pre>
<p>이때 만약 bad permissions 에러가 발생한다면 아래와 같이 명령어를 입력해주고 위의 명령어를 다시 입력해주면 된다.</p>
<pre><code class="language-bash">$ chmod 400 {키-페어 파일 경로.pem}
</code></pre>
<p>아래와 같이 접속이 성공하면 성공이다.</p>
<h3>AWS 인스턴스에 docker 설치하기</h3>
<p>이제 Ubuntu 인스턴스에 docker를 설치해줄 차례이다.</p>
<p><a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">📌 우분투에 도커 설치하기 공식 문서 바로가기 📌</a></p>
<p>위 문서를 참고하여 아래와 같이 명령어를 입력해준다.</p>
<h3>AWS 인스턴스에 github runner 설치하기</h3>
<p>이제는 인스턴스에 github runner를 설치해줘야 한다.</p>
<p>이를 위해 잠시 아까 생성한 nest.js 깃허브 레파지토리로 다시 이동하자.</p>
<blockquote>
<p>settings -> Actions -> Runners -> New self-hosted runner 버튼 클릭</p>
</blockquote>
<p>그러면 아래와 같이 우분투에 github runner를 설치 할 수 있도록 아래와 같이 명령어들을 설명해준다.</p>
<ul>
<li>인스턴스에 OS로 우분투를 설치했으니 Linus를 선택해주자.</li>
<li>그리고 인스턴스 생성시 x64 아키텍쳐로 진행했으니 x64를 선택해주자.</li>
<li>설치 명령어는 붉은색 박스의 명령어 까지만 복사해서 터미널에 입력해주었다.</li>
<li>그리고 ./run.sh 명령어 대신 나는 백그라운드에서도 계속 실행되도록 아래와 같은 명령어를 입력해줬다.</li>
</ul>
<pre><code class="language-bash"> nohup ./run.sh &#x26;
</code></pre>
<h2>github Actions 작성하기</h2>
<p>이제 github Actions를 작성해보자.</p>
<p>소스코드에 .github/workflows 폴더를 생성하고 아래와 같이 main.yml 파일을 생성해준다.</p>
<p>그리고 링크와 같이 yml 파일을 작성해 주었다.</p>
<p><a href="https://github.com/nostrss/nestjs-study/blob/main/.github/workflows/main.yml">📌 build &#x26; deploy yml 파일 바로가기 📌</a></p>
<blockquote>
<p>자 이제 모든 준비가 끝났다!</p>
</blockquote>
<h2>배포하기</h2>
<p>이제 Nest.js 소스코드가 github에 푸쉬 되기만 하면 알아서 빌드, 배포가 되어야 한다. 테스트를 해보자.</p>
<p>Nest,js 소스코드를 깃허브에 푸쉬를 해보자.</p>
<p>그리고 프로젝트 레파지토릭에서 Actions 탭으로 이동하면 아래와 같이 빌드가 진행되는 것을 확인 할 수 있다.</p>
<p>나의 경우 최초에 테스트할 때 실패를 했고 2번째에는 성공을 했다. workflow를 클릭해서 확인해보자.</p>
<p>단계별로 workflow가 어떻게 실행되고 있는지 확인 할 수 있다.</p>
<p>약 2분정도 시간이 걸렸다. 이제는 브라우저에서 배포 결과물을 확인해보자.</p>
<blockquote>
<p>성공이다!!</p>
</blockquote>
<p>좀 전에 인스턴스에 연결해둔 ssh 접속을 통해서도 확인해보자.</p>
<p>도커가 정상적으로 실행되고 있음을 확인 할 수 있었다. 앞으로는 이제 Nest.js 소스코드를 푸쉬만 하면 자동으로 빌드, 배포가 될 것이다!!.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="docker"/>
        <category label="aws"/>
        <category label="github-actions"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그도 구독이 가능하다]]></title>
        <id>168-rss-atom-json</id>
        <link href="https://nostrss.me/blog/168-rss-atom-json"/>
        <updated>2023-09-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Next.js 블로그에 RSS, Atom, JSON Feed를 추가하기]]></summary>
        <content type="html"><![CDATA[<p>블로그의 컨텐츠를 우리가 검색하거나 직접 방문하여 볼수도 있지만, 구독처럼 새로운 컨텐츠가 발행되면 받아서 볼 수 있는 기능이 존재한다. 이를 가능케 하는게 <code>RSS</code>, <code>Atom</code>, <code>JSON-Feed</code>이다.</p>
<p>위 3개를 직접 전부 구현하기엔 너무 어려울 것 같아서 외부 패키지를 사용해서 구현해보았다.</p>
<h2>패키지 설치</h2>
<p><code>RSS</code>를 구현하기 위해 2가지 방법을 고민했다.</p>
<ol>
<li>동적으로 api를 호출해서 데이터를 가져오는 방법</li>
<li>빌드시 정적 파일을 생성하는 방법</li>
</ol>
<p>아무래도 이미 파일로 생성이 되어 있으면, 조금더 속도에서 빠르지 않을까 싶어서 2번의 방법으로 구현하기로 했다. 그리고 서버 리소스도 사용하지 않아도 되는 장점도 있을 것 같다.</p>
<p>구현에 사용할 패키지는 아래 2개이다.</p>
<p><a href="https://www.npmjs.com/package/feed">📌 Feed NPM 페이지 바로가기 📌</a></p>
<p><a href="https://www.npmjs.com/package/ts-node">📌 ts-node 페이지 바로가기 📌</a></p>
<h2>구현 코드</h2>
<pre><code class="language-ts">import { Feed } from 'feed';
import { writeFileSync } from 'fs';
import {
  BASE_URL,
  DEFAULT_META_AUTHOR_EMAIL,
  DEFAULT_META_AUTHOR_NAME,
  DEFAULT_META_AUTHOR_URL,
  DEFAULT_META_DESCRIPTION,
  DEFAULT_META_TITLE,
} from './constant';

import fetch from 'node-fetch';

const master = {
  name: DEFAULT_META_AUTHOR_NAME,
  email: DEFAULT_META_AUTHOR_EMAIL,
  link: DEFAULT_META_AUTHOR_URL,
};

const feed = new Feed({
  title: DEFAULT_META_TITLE,
  description: DEFAULT_META_DESCRIPTION,
  id: DEFAULT_META_AUTHOR_URL,
  link: DEFAULT_META_AUTHOR_URL,
  language: 'ko',
  image: '',
  favicon: '',
  copyright: '',
  generator: 'generate-rss',
  feedLinks: {
    json: `${BASE_URL}/feed.json`,
    atom: `${BASE_URL}/rss-atom.xml`,
    rss: `${BASE_URL}/rss.xml`,
  },
  author: master,
});

const getAllPostData = async () => {
  const data = await fetch(`${BASE_URL}/api/post/all`, {
    method: 'GET',
  });

  const jsonData: any = await data.json();
  jsonData.data.forEach((json: JsonPost) => {
    feed.addItem({
      title: json.title,
      id: json.currentPostId,
      link: `${BASE_URL}/${json.currentPostId}`,
      description: json.description,
      content: json.content.toString(),
      author: [master],
      contributor: [master],
      date: new Date(json.date),
      // image: post.image,
      category: json.tags.split(' ').map((tag: string) => ({ name: tag })),
    });
  });

  // Output: RSS 2.0
  writeFileSync('public/rss.xml', feed.rss2(), 'utf-8');
  // Output: Atom 1.0
  writeFileSync('public/rss-atom.xml', feed.atom1(), 'utf-8');
  // Output: JSON Feed 1.0
  writeFileSync('public/feed.json', feed.json1(), 'utf-8');
};

getAllPostData();
feed.addCategory('Technologies');

type JsonPost = {
  currentPostId: string;
  title: string;
  description: string;
  date: string;
  tags: string;
  content: string;
};
</code></pre>
<blockquote>
<p>feed 변수는 변하지 rss,atom,json-feed를 생성하는데 공통으로 사용되는 상수이다.</p>
</blockquote>
<blockquote>
<p>getAllPostData 함수는 모든 포스트 데이터를 가져와서 feed에 추가하는 함수이다.</p>
</blockquote>
<blockquote>
<p>getAllPostData 함수 안에서 rss, atom, json-feed를 생성하는 각각 메서드를 실행하여 파일로 저장한다.</p>
</blockquote>
<blockquote>
<p>파일의 생성 경로는 public 폴더이며, public에 생성된 파일은 추후 {도메인}/rss.xml, {도메인}/rss-atom.xml, {도메인}/feed.json으로 접근이 가능하다.</p>
</blockquote>
<h2>빌드 및 파일 생성</h2>
<p>packacge.json에 아래 스크립트를 추가한다.</p>
<pre><code class="language-json">{
  "rss": "ts-node --project tsconfig.node.json ./src/generate-rss.ts",
  "build": "next build &#x26;&#x26; yarn rss"
}
</code></pre>
<p>로컬에서 <code>yarn rss</code> 커맨드를 실행하면 <code>public</code> 폴더에 <code>rss.xml</code>, <code>rss-atom.xml</code>, <code>feed.json</code> 파일이 생성되는 것을 확인 할 수 있다.</p>
<p>로컬에서 생성하지 않아도 <code>vercel</code>에 배포시 자동으로 <code>rss</code>도 빌드가 되도록 스크립트를 추가해두었다.</p>
<h2>결과확인</h2>
<p><a href="https://www.nostrss.me/rss.xml">📌 rss 확인하기 📌</a></p>
<p><a href="https://www.nostrss.me/rss-atom.xml">📌 rss-atom 확인하기 📌</a></p>
<p><a href="https://www.nostrss.me/feed.json">📌 feed.json 확인하기 📌</a></p>
<p>모두 정상적으로 생성되었음을 확인 할 수 있다.</p>
<p>실제 위의 feed를 구독할 때도 잘 보이는지 Rss 리더를 통해 확인해야겠다.</p>
<p><code>feedly</code>라는 rss 리더를 사용해서 구독해보았다.</p>
<p><a href="https://feedly.com/">📌 feedly 바로가기 📌</a></p>
<blockquote>
<p>된다!! 아주 잘나온다!!</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="blog"/>
        <category label="rss"/>
        <category label="atom"/>
        <category label="json-feed"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[리액트를 벗어나 순수한 프로젝트를 만들어보자]]></title>
        <id>167-webpack-typescript</id>
        <link href="https://nostrss.me/blog/167-webpack-typescript"/>
        <updated>2023-09-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[바닐라 타입스크립트에 웹팩을 설정한 템플릿 만들기]]></summary>
        <content type="html"><![CDATA[<p>처음 프론트엔드를 배울때 React로 배우고 계속 사용하다보니 리액트 없이는 프론트엔드를 할 수 없는 느낌이 들었다. 그래서 리액트를 벗어나 순수한 프로젝트를 만들어보고 싶었다. 바닐라 자바스크립트에 타입스크립트만 추가한 템플릿을 만들어보았다.</p>
<p><a href="https://github.com/nostrss/webpack-template">📌 깃허브에서 소스코드 보기 📌</a></p>
<h2>npm init</h2>
<p>먼저 폴더를 생성하고 <code>npm init</code>을 실행해준다.</p>
<p>몇가지 질문이 진행되고 완료되면 <code>package.json</code>이 생성되게 된다.</p>
<h2>테스트를 위한 파일 생성</h2>
<pre><code>📦src
 ┣ 📜about.html
 ┣ 📜about.js
 ┣ 📜index.html
 ┣ 📜index.ts
 ┣ 📜style.css
 ┗ 📜word.js
</code></pre>
<p>웹팩을 설치하고 빌드하기 전에 테스트를 위한 파일들을 위와 같이 생성해주었다.</p>
<h2>웹팩 설치(v5)</h2>
<p><a href="https://webpack.kr/guides/getting-started/#creating-a-bundle">📌 웹팩 공식문서 바로가기 📌</a></p>
<pre><code class="language-bash">npm install webpack webpack-cli --save-dev
</code></pre>
<h2>webpack.config.js 기본 설정하기</h2>
<pre><code class="language-js">const path = require('path');

module.exports = {
  mode: 'production',
  entry: { index: '/src/index.ts', about: '/src/about.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
  },
};
</code></pre>
<h3>mode</h3>
<p><a href="https://webpack.kr/configuration/mode/#root">📌 웹팩 Mode 문서 바로가기 📌</a></p>
<p>mode의 경우 Default로는 production으로 설정되어 있다.</p>
<p>production 모드의 경우 최적화가 되어 빌드가 되며, 이로 인해 빌드파일의 크기가 development 모드에 비해 작아진다.</p>
<p>production과 development의 빌드 결과는 아래와 같은 차이가 있다.</p>
<blockquote>
<p>development 인 경우</p>
</blockquote>
<p>사람이 조금은 알아볼 수 있는 형태로 빌드가 된다.</p>
<ul>
<li>production 인 경우</li>
</ul>
<p>사람이 알아볼 수 없을 정도로 최적화가 되어 빌드가 된다.</p>
<h3>Entry Points</h3>
<p><a href="https://webpack.kr/concepts/entry-points/#root">📌 웹팩 Entry Points 문서 바로가기 📌</a></p>
<p>webpack이 빌드할 파일을 지정해주는 부분이다.</p>
<p>테스트로 파일을 2개 생성했기 때문에 2개의 파일을 지정해주었다.</p>
<h3>Output</h3>
<p><a href="https://webpack.kr/concepts/output/">📌 웹팩 Output 문서 바로가기 📌</a></p>
<p>빌드된 파일을 어디에 어떻게 저장할지 지정해주는 부분이다.</p>
<p><code>path</code>는 빌드된 파일을 저장할 경로를 지정해주고, <code>filename</code>은 빌드된 파일의 이름을 지정해준다.</p>
<p><code>filename</code>의 경우 <code>[name]</code>을 사용하면 <code>entry</code>에 지정한 Key값(index, about)을 파일명으로 빌드하게 된다.</p>
<p>다만 이렇게 빌드하여 배포가 될 경우, 빌드 결과 파일의 이름이 기존과 동일하기 브라우저 캐쉬로 인해 변경사항이 유저에게 전달되지 않았던 경험이 있다.</p>
<p>그래서 아래와 같이 다시 수정해서 빌드를 해봤다.</p>
<pre><code class="language-js">const path = require('path');

module.exports = {
  mode: 'production',
  entry: { index: '/src/index.ts', about: '/src/about.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
  },
};
</code></pre>
<p>빌드할 때 마다 <code>hash</code> 값이 계속 달라지게 되고 브라우저에서는 이전과 파일명이 다르기 때문에 캐쉬를 사용하지 않고 새로 빌드된 파일을 사용하게 된다.</p>
<h2>문제점</h2>
<p>js파일은 빌드가 되는 것은 확인이 되었다.</p>
<p>그리고 js파일을 html과 연결 후 브라우저를 통해 확인해보니 정상적으로 보인다.</p>
<p>하지만 몇가지 문제점이 보였다.</p>
<ol>
<li>
<p>CSS 파일이 별도로 로딩이 되고 있었다.
</p>
</li>
<li>
<p>js파일을 html에 연결해야하는 번거로움이 있다.</p>
</li>
</ol>
<ul>
<li>현업에서 만약 이렇게 사용하면 빌드 후 배포할때, 빌드 할때마다 HTML파일에 새로 생성된 js파일을 HTML에 연결해주는 번거로움이 존재한다.</li>
</ul>
<p>하나씩 해결해보자.</p>
<h2>Loader를 사용하여 CSS를 JS파일과 함께 빌드하고 DOM에 반영하기</h2>
<p><a href="https://webpack.kr/concepts/loaders/">📌 웹팩 로더 문서 바로가기 📌</a></p>
<p>이를 위해 2개의 패키지를 추가로 설치해주자.</p>
<pre><code class="language-bash">npm install css-loader style-loader -D
</code></pre>
<p>그리고 <code>webpack.config.js</code>를 아래와 같이 수정했다.</p>
<pre><code class="language-js">const path = require('path');

module.exports = {
  mode: 'production',
  entry: { index: '/src/index.js', about: '/src/about.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // injects the css into the DOM
          { loader: 'style-loader' },
          // translates CSS into JS
          {
            loader: 'css-loader',
          },
        ],
      },
    ],
  },
};
</code></pre>
<p>그리고 다시 빌드 후 HTML 파일에 link css를 삭제하고 빌드 파일을 연결해 주었다.</p>
<p>결과물도 정상적으로 나오고 이제는 css 파일을 별도로 로딩하지 않는 것을 확인할 수 있었다.</p>
<h2>Plugins를 이용해 html 파일 생성하기</h2>
<p><a href="https://webpack.kr/plugins/html-webpack-plugin/">📌 웹팩 HtmlWebpackPlugin 문서 바로가기 📌</a></p>
<p>현재 js파일에 css를 추가하여 빌드하는 것까지는 성공했다.</p>
<p>이제 빌드시 html파일을 생성하고 여기에 js파일을 자동으로 연결해주는 작업을 해보자. 이를 위해 아래의 패키지를 설치해 주자.</p>
<pre><code class="language-bash">npm install -D html-webpack-plugin
</code></pre>
<p>그리고 webpack.config.js를 아래와 같이 수정해주자.</p>
<pre><code class="language-js">const path = require('path');
// ----> 추가
const HtmlWepackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: { index: '/src/index.js', about: '/src/about.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // injects the css into the DOM
          { loader: 'style-loader' },
          // translates CSS into JS
          {
            loader: 'css-loader',
          },
        ],
      },
    ],
  },
  // ----> 추가
  plugins: [
    new HtmlWepackPlugin({
      template: './src/index.html',
      filename: './index.html',
      chunks: ['index'],
    }),
    new HtmlWepackPlugin({
      template: './src/about.html',
      filename: './about.html',
      chunks: ['about'],
    }),
  ],
};
</code></pre>
<p>그리고 html파일에서 js파일을 추가해주는 script를 삭제해주자.</p>
<blockquote>
<p>즉 이제 html파일에 css와 js파일을 link, script로 삽입해주지 않아도 된다.</p>
</blockquote>
<p>이제 빌드를 해보자.</p>
<p>dist 폴더 안에 html파일이 함께 생성된 것을 볼 수 있다.</p>
<h2>Typescript 설정하기</h2>
<p><a href="https://webpack.kr/guides/typescript/">📌 웹팩 Typescript 문서 바로가기 📌</a></p>
<p>나는 타입스크립트를 사용할 것이기 때문에 또 추가적인 설정이 필요하다.</p>
<p>일단 나는 타입스크립트가 글로벌로 설치가 되어 있기 때문에 아래의 패키지만 설치를 해주었다.</p>
<pre><code class="language-bash">npm install -D ts-loader
</code></pre>
<p>설치 후에는 tsconfig.json 파일을 아래와 같이 생성해주었다.</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "outDir": "./dist/",
    "noImplicitAny": true,
    "module": "es6",
    "target": "es5",
    "jsx": "react",
    "allowJs": true,
    "moduleResolution": "node"
  }
}
</code></pre>
<p>타입스크립트 파일이 빌드가 되는지 테스트를 위해 indext.js파일의 확장자를 indext.ts로 변경해주었다.</p>
<p>그리고 webpack.config.js를 아래와 같이 수정해주었다.</p>
<pre><code class="language-js">const path = require('path');
const HtmlWepackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'production',
  // ----> ts 파일로 수정
  entry: { index: '/src/index.ts', about: '/src/about.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // injects the css into the DOM
          { loader: 'style-loader' },
          // translates CSS into JS
          {
            loader: 'css-loader',
          },
        ],
      },
      // ----> 추가
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  // ----> 추가
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  plugins: [
    new HtmlWepackPlugin({
      template: './src/index.html',
      filename: './index.html',
      chunks: ['index'],
    }),
    new HtmlWepackPlugin({
      template: './src/about.html',
      filename: './about.html',
      chunks: ['about'],
    }),
  ],
};
</code></pre>
<p>빌드를 해보니 이전과 동일하게 정상적으로 빌드가 성공하는 것을 확인할 수 있었다.</p>
<h2>빌드시 이전 결과물 삭제하기</h2>
<p>이제 기본적인 설정은 끝난 것 같다.</p>
<p>그러나 빌드할 때마다 hash값이 변하다 보니 빌드 결과물에 이전 js파일들이 남아 있는 것을 확인할 수 있었다.</p>
<p>이건 추가 설정으로 간단히 해결 할 수 있었다.</p>
<pre><code class="language-js">output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash].js',
    // ----> 추가
    clean: true,
  },
</code></pre>
<p>위와 같이 clean 옵션을 추가해주면 빌드시 이전 결과물을 삭제해준다.</p>
<p>이렇게 만들고 나니 기존의 react가 얼마나 편한 라이브러리인지 체감하게 됐다.</p>
<p>위의 설정등을 하지 않고 바로 최적화 빌드가 가능한 지금, 과거 프론트엔드 개발자들은 얼마나 힘들게 개발을 했을까 싶다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="webpack"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[들어는 봤니? 커링함수(currying function)]]></title>
        <id>166-curring-function</id>
        <link href="https://nostrss.me/blog/166-curring-function"/>
        <updated>2023-09-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[근데 React에서 커링함수는 언제 사용해야 할까?]]></summary>
        <content type="html"><![CDATA[<p>커링함수란 여러개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인처럼 연결하는 것을 말한다.</p>
<p>그렇기 때문에 원칙적으로 하나의 파라미터만을 전달하는 것을 원칙으로 한다.</p>
<h2>커링함수의 예시 살펴보기</h2>
<pre><code class="language-js">const curry3 = function (func) {
  return function (a) {
    return function (b) {
      return func(a, b);
    };
  };
};

const getMaxWith10 = curry3(Math.max)(100);
console.log(getMaxWith10(51)); // 100
console.log(getMaxWith10(122)); // 122
</code></pre>
<p>위의 코드는 커링함수의 예시이다. 함수를 인자로 받고, 후속으로 받는 인자 2개에 대해 인자로 받은 함수를 실행한 값을 리턴한다.</p>
<p>위의 코드 실행과정을 아래와 같이 정리해봤다.</p>
<ol>
<li><code>curry3(Math.max)</code> : 아래의 익명함수를 리턴한다.</li>
</ol>
<pre><code>ƒ (a) {
    return function (b) {
      return Math.max(a, b);
    };
}
</code></pre>
<ol start="2">
<li><code>curry3(Math.max)(100)</code> : 위의 익명함수를 실행하고 새로운 익명함수를 리턴한다.</li>
</ol>
<pre><code>ƒ (b) {
  return Math.max(100, b);
}

</code></pre>
<ol start="3">
<li><code>const getMaxWith10 = curry3(Math.max)(100)</code></li>
</ol>
<ul>
<li>위의 익명함수가 getMaxWith10에 할당된다.</li>
</ul>
<ol start="4">
<li><code>getMaxWith10(51)</code></li>
</ol>
<ul>
<li>getMaxWith10이 실행되고, 51이 인자로 전달되고, Math.max(100, 51)이 실행된다.</li>
</ul>
<pre><code>ƒ (51) {
  return Math.max(100, 51);
}
</code></pre>
<h2>커링함수와 화살표 함수</h2>
<p>위의 커링함수의 인자가 많아지거나, 길이가 길어지면 가독성이 떨어지는 단점이 있다. 이때 아래와 같이 화살표 함수를 사용하면 가독성을 높일 수 있다.</p>
<pre><code class="language-js">const curry3 = (func) => (a) => (b) => func(a, b);
</code></pre>
<h2>커링함수 언제? 왜 사용하는가?</h2>
<p>커링함수는 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들오면 전달하는 방식으로 사용할 수가 있다.</p>
<p>이를 함수형 프로그래밍에서는 <code>지연 실행(lazy execution)</code>이라고 한다.</p>
<p><code>React</code>에서 실제로 위의 커링함수를 언제 사용할 수 있을지 고민을 해봤다.</p>
<pre><code class="language-js">// 커링함수를 사용하지 않은 경우
const getInformation = (baseUrl, path, id) => fetch(`${baseUrl}${path}/${id}`);

// 커링함수
const getInformation = (baseUrl) => (path) => (id) =>
  fetch(`${baseUrl}${path}/${id}`);
</code></pre>
<p>위의 코드는 api를 호출하는 함수이다. 커링을 사용한 경우와 사용하지 않은 경우 결과값을 동일할 것이다.</p>
<p>이것만 봐서는 커링을 사용하는 명확한 가치를 느끼지는 못하겠다.</p>
<p>하지만 과거 공부했던 <code>HOC(Higher Order Component)</code>의 개념과 커링은 매우 비슷하게 느껴진다.</p>
<p>커링은 프로젝트에서 내가 실제로 의도해서 사용해본적은 없는 것 같다.</p>
<p>이후 프로젝트에서 커링을 사용해볼 수 있는 기회가 생긴다면 사용해보면서 익혀가야 할 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="javascript"/>
        <category label="currying"/>
        <category label="function"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[복사 제대로 하고 있니?]]></title>
        <id>165-copy-shallow-deep</id>
        <link href="https://nostrss.me/blog/165-copy-shallow-deep"/>
        <updated>2023-09-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[얕은 복사, 깊은 복사 복습하기]]></summary>
        <content type="html"><![CDATA[<p>처음 자바스크립트를 공부할 때, 참조값을 복사하면 얕은 복사인 것으로 간단히 알고 넘어갔었다. 이에 대해 조금은 심도있게 알아보려고 한다.</p>
<h2>얕은 복사(shallow copy)</h2>
<p>MDN에서는 얕은 복사를 다음과 같이 정의하고 있다.</p>
<blockquote>
<p>객체의 얕은 복사는 복사본의 속성이 복사본이 만들어진 원본 객체와 같은 참조 (메모리 내의 같은 값을 가리킴)를 공유하는 복사입니다. 따라서 원본이나 복사본을 변경하면, 다른 객체 또한 변경될 수 있습니다. 이러한 동작은 원본과 복사본이 완전히 독립적인 깊은 복사의 동작과 대조적입니다.</p>
</blockquote>
<p>이를 코드를 통해 이해해보자.</p>
<pre><code class="language-js">const user = {
  name: 'John',
  url: {
    twitter: 'https://twitter.com/john',
    facebook: 'https://facebook.com/john',
  },
};

const copyObject = (target) => {
  let result = {};
  for (let key in target) {
    result[key] = target[key];
  }
  return result;
};

const user2 = user;
const user3 = copyObject(user);
console.log(user === user2); // 1. ??
console.log(user === user3); // 2. ??
</code></pre>
<ol>
<li>답은 True이다.</li>
</ol>
<ul>
<li>우리가 가장 흔하게 볼 수 있는 얕은 복사의 형태이다.</li>
</ul>
<ol start="2">
<li>답은 False이다.</li>
</ol>
<ul>
<li><code>copyObject</code> 함수를 통해 새로운 객체를 만들었기 때문에 새로운 참조값을 가지게 된다.</li>
</ul>
<blockquote>
<p>그렇다면 user3의 경우에는 깊은 복사가 이루어진 것인가?</p>
</blockquote>
<p>user3의 하위 프로퍼티들의 값을 변경해서 원본 객체의 값이 변경되는지 확인해보자.</p>
<p>아래와 같이 코드를 작성해서 실행해보았다.</p>
<pre><code class="language-js">user3.name = 'Pete';
console.log(user.name); // John
console.log(user3.name); // Pete
</code></pre>
<p>user3의 값을 변경했으나 원본 객체의 값은 변경되지 않았다. 이번엔 하위 url 프로퍼티의 값을 변경해보자.</p>
<pre><code class="language-js">user3.url.twitter = 'https://twitter.com/pete';
console.log(user.url.twitter); // https://twitter.com/pete
console.log(user3.url.twitter); // https://twitter.com/pete
</code></pre>
<p>하위 객체인 url의 경우에는 user3 객체의 값을 변경했을 때 원본인 user 객체까지 변경되는 것을 확인할 수 있었다.</p>
<p>이것은 user 하위의 url객체의 메모리상 주소값만이 복사되었기 때문이다.</p>
<blockquote>
<p>즉 위의 케이스는 얕은 복사가 이루어진 것이다.</p>
</blockquote>
<h2>깊은 복사를 하는 방법</h2>
<h3>JSON 객체 메서드 사용</h3>
<p>객체를 JSON으로 변환하고 다시 객체로 변환하는 방법이다.</p>
<pre><code class="language-js">const user4 = JSON.parse(JSON.stringify(user));
user4.url.twitter = 'https://twitter.com/pete';
console.log(user4 === user); // false
console.log(user4.url === user.url); // false
console.log(user4.url.twitter === user.url.twitter); // falses
</code></pre>
<h3>재귀함수를 사용하는 방법</h3>
<pre><code class="language-js">const copyObject = (target) => {
  let result = {};
  if (typeof target === 'object' &#x26;&#x26; target !== null) {
    for (let key in target) {
      result[key] = copyObject(target[key]);
    }
  } else {
    result = target;
  }
  return result;
};

const user5 = copyObject(user);
user5.url.twitter = 'https://twitter.com/pete';
console.log(user5 === user); // false
console.log(user5.url.twitter === user.url.twitter); // false
</code></pre>
<h3>lodash.js cloneDeep 메서드 사용</h3>
<p>많이 사용하는 라이브러리인 lodash의 cloneDeep 메서드를 사용하는 방법이다.</p>
<pre><code class="language-js">var objects = [{ a: 1 }, { b: 2 }];

var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false
</code></pre>
<h3>immer.js 또는 Immutable.js 라이브러리 사용</h3>
<pre><code class="language-js">import { produce } from 'immer';

const nextState = produce(baseState, (draft) => {
  draft[1].done = true;
  draft.push({ title: 'Tweet about it' });
});
</code></pre>
<p>Immutable.js 는 페이스북에서 만든 패키지인데, 요샌 immer.js를 많이 사용한다고 한다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="javascript"/>
        <category label="shallow"/>
        <category label="deep"/>
        <category label="copy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 다크모드 적용하기]]></title>
        <id>164-next-darkmode-toggle</id>
        <link href="https://nostrss.me/blog/164-next-darkmode-toggle"/>
        <updated>2023-09-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[요새 많이 사용하는 다크모드를 적용해보자.]]></summary>
        <content type="html"><![CDATA[<p>네이버도 그렇고 요새 많은 사이트들이 <code>다크모드</code>를 지원하고 있다.</p>
<p>나도 웹페이지를 볼때 다크모드를 선호하는 편인지라 다크모드를 적용하려고 한다.</p>
<p>내가 원하는 다크모드의 기능은 다음과 같다.</p>
<ul>
<li>최초 접속 시에는 유저의 OS 다크모드 설정을 따른다.</li>
<li>유저가 버튼을 클릭시 모드가 변경이 된다.</li>
<li>변경된 모드가 다음에 접속시에도 유지가 된다.</li>
</ul>
<h2>유저의 OS 다크모드 설정을 따르기</h2>
<p>유저의 OS 다크모드 설정을 따르기 위해서는 <code>window.matchMedia</code>를 사용하면 된다.</p>
<p>코드를 살펴보자.</p>
<pre><code class="language-tsx">export default function DarkModeToggle() {
  const [isDark, setIsDark] = useState(false);
  const path = usePathname();

  useEffect(() => {
    initializeDarkMode();
  }, [path]);

  const initializeDarkMode = () => {
    const savedMode = COOKIE.getCookie(MODE_COOKIE_NAME);
    const prefersDarkMode = window.matchMedia(
      `(prefers-color-scheme: ${DARK_MODE})`
    ).matches;
    const initialMode = savedMode || (prefersDarkMode ? DARK_MODE : LIGHT_MODE);

    setIsDark(initialMode === DARK_MODE);
    changeColorScheme(initialMode);
    COOKIE.setCookie(MODE_COOKIE_NAME, initialMode, 720);
  };

  return (
    &#x3C;>
      &#x3C;button title={isDark ? '일반모드로 변경' : '다크모드로 변경'}>
        {isDark ? &#x3C;SunnyIcon color='white' /> : &#x3C;NightIcon />}
      &#x3C;/button>
    &#x3C;/>
  );
}

const changeColorScheme = (mode: string) => {
  const colorScheme = document.querySelector('meta[name="color-scheme"]');
  colorScheme?.setAttribute('content', mode);

  if (mode === DARK_MODE) {
    document.documentElement.classList.add(DARK_MODE);
    document.documentElement.classList.remove(LIGHT_MODE);
  } else {
    document.documentElement.classList.add(LIGHT_MODE);
    document.documentElement.classList.remove(DARK_MODE);
  }
};
</code></pre>
<blockquote>
<p>브라우저에서 작동해야 하기 때문에 최상단에 'use client'를 선언해주어야 한다.</p>
</blockquote>
<blockquote>
<p>모드 초기화를 위해 initializeDarkMode라는 함수를 만들고 useEffect를 통해 최초 실행시켜줬다.</p>
</blockquote>
<blockquote>
<p>initializeDarkMode 함수에서는 쿠키에 저장된 모드가 있는지 확인하고 없다면 유저의 OS 다크모드 설정을 확인한다.</p>
</blockquote>
<blockquote>
<p>초기화 된 모드를 쿠키에 저장한다.</p>
</blockquote>
<blockquote>
<p>초기화 된 모드에 따라 Icon을 변경해준다.</p>
</blockquote>
<blockquote>
<p>초기화 된 모드에 따라 documentElement에 클래스를 추가해준다.</p>
</blockquote>
<h2>버튼 클릭시 모드 변경처리</h2>
<pre><code class="language-tsx">const chageModeInvert = () => {
  const currentMode = document
    .querySelector('meta[name="color-scheme"]')
    ?.getAttribute('content');
  const newMode = currentMode === DARK_MODE ? LIGHT_MODE : DARK_MODE;

  setIsDark(newMode === DARK_MODE);
  changeColorScheme(newMode);
  COOKIE.setCookie(MODE_COOKIE_NAME, newMode, 720);
};
</code></pre>
<p>위의 함수는 버튼 클릭시 모드를 변경해주는 함수이다.이걸 버튼의 <code>onClick</code>에 넣어주면 된다.</p>
<p><img src="https://github.com/nostrss/next13-blog/assets/56717167/3044f7e6-6bfb-409e-9831-bff5baed05f2" alt="화면-기록-2023-09-15-오후-7 24 06"></p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="darkmode"/>
        <category label="toggle"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js meatadata 적용하기]]></title>
        <id>163-next-metadata</id>
        <link href="https://nostrss.me/blog/163-next-metadata"/>
        <updated>2023-09-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[SEO 최적화를 위한 메타데이터 생성하기]]></summary>
        <content type="html"><![CDATA[<p>작성된 블로그를 다른 개발자들이 볼 수 있도록 하려면 SEO 최적화라는 작업을 해야한다.</p>
<p>대단한 건 아니고 구글같은 검색엔진에서 검색시 노출이 잘 될 수 있도록 웹사이트의 정보를 제공하는 것이다.</p>
<h2>NEXT에서의 메타데이터 삽입</h2>
<p><a href="https://nextjs.org/docs/app/building-your-application/optimizing/metadata">Next.js metadata 공식문서 바로가기</a>를 참고하여 작성했다.</p>
<p>Next에서는 메타데이터 추가를 위해 2가지 방법을 제공한다.</p>
<ul>
<li>Static Metadata</li>
<li>Dynamic Metadata</li>
</ul>
<p>하나씩 살펴 보도록 하겠다.</p>
<h2>Static Metadata</h2>
<p>Static Metadata는 아래와 같이 <code>layout.js</code> 파일에 생성할 메타데이터 객체를 생성하면 된다.</p>
<pre><code class="language-tsx">import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: '...',
  description: '...',
};

export default function Page() {}
</code></pre>
<p>대신 이렇게 생성된 메타데이터는 정적 데이터로 변하지 않는다.</p>
<p>그래서 <code>dynamic router</code>를 사용한 페이지에서 계속 변하는 <code>title, description</code>을 메타데이터에 적용할 수 는 없다. 만약 동적으로 변하는 메타데이터를 적용하고 싶다면 <code>Dynamic Metadata</code>를 사용해야 한다.</p>
<h2>Dynamic Metadata</h2>
<p>위에서 말한 것처럼 metadata에 계속 변하는 정보가 있다면, 아래처럼 <code>generateMetadata</code>함수를 사용해야 한다.</p>
<pre><code class="language-tsx">import type { Metadata, ResolvingMetadata } from 'next';

type Props = {
  params: { id: string };
  searchParams: { [key: string]: string | string[] | undefined };
};

export async function generateMetadata(
  { params, searchParams }: Props,
  parent: ResolvingMetadata
): Promise&#x3C;Metadata> {
  // read route params
  const id = params.id;

  // fetch data
  const product = await fetch(`https://.../${id}`).then((res) => res.json());

  // optionally access and extend (rather than replace) parent metadata
  const previousImages = (await parent).openGraph?.images || [];

  return {
    title: product.title,
    openGraph: {
      images: ['/some-specific-page-image.jpg', ...previousImages],
    },
  };
}

export default function Page({ params, searchParams }: Props) {}
</code></pre>
<p>각 페이지에 맞는 메타데이터 객체를 return 값으로 넘겨 주면된다.</p>
<p>이때 메타데이터 객체는 아래와 같은 형태로 구성되어 있다.</p>
<pre><code class="language-ts">interface ResolvedMetadata extends DeprecatedMetadataFields {
  metadataBase: null | URL;
  title: null | AbsoluteTemplateString;
  description: null | string;
  applicationName: null | string;
  authors: null | Array&#x3C;Author>;
  generator: null | string;
  keywords: null | Array&#x3C;string>;
  referrer: null | ReferrerEnum;
  themeColor: null | ThemeColorDescriptor[];
  colorScheme: null | ColorSchemeEnum;
  viewport: null | string;
  creator: null | string;
  publisher: null | string;
  robots: null | ResolvedRobots;
  alternates: null | ResolvedAlternateURLs;
  icons: null | ResolvedIcons;
  openGraph: null | ResolvedOpenGraph;
  manifest: null | string | URL;
  twitter: null | ResolvedTwitterMetadata;
  verification: null | ResolvedVerification;
  appleWebApp: null | ResolvedAppleWebApp;
  formatDetection: null | FormatDetection;
  itunes: null | ItunesApp;
  abstract: null | string;
  appLinks: null | ResolvedAppLinks;
  archives: null | Array&#x3C;string>;
  assets: null | Array&#x3C;string>;
  bookmarks: null | Array&#x3C;string>;
  category: null | string;
  classification: null | string;
  other:
    | null
    | ({
        [name: string]: string | number | Array&#x3C;string | number>;
      } &#x26; DeprecatedMetadataFields);
}
</code></pre>
<p>상당히 많은 값을 지원하는데, 자세한 내용은 Next.js 공식문서를 참고하여 추가해주면 된다.</p>
<h2>실제 적용 코드</h2>
<h3>src/app/layout.tsx</h3>
<pre><code class="language-tsx">export const metadata: Metadata = {
  ...defaultMetaData,
};
</code></pre>
<h3>src/defaultMetaData.ts</h3>
<pre><code class="language-ts">import { Metadata } from 'next';
import {
  BASE_URL,
  DEFAULT_APP_NAME,
  DEFAULT_GENERATOR,
  DEFAULT_META_AUTHOR_NAME,
  DEFAULT_META_AUTHOR_URL,
  DEFAULT_META_DESCRIPTION,
  DEFAULT_META_KEYWORDS,
  DEFAULT_META_TITLE,
  DEFAULT_OG_IMAGE_URL,
  DEFAULT_REFERRER,
  LIGHT_MODE,
  RSS_ATOM_URL,
  RSS_JSON_URL,
  RSS_XML_URL,
} from './constant';

export const defaultMetaData: Metadata = {
  title: {
    template: `%s | ${DEFAULT_META_TITLE}`,
    default: DEFAULT_META_TITLE,
  },
  description: DEFAULT_META_DESCRIPTION,
  generator: DEFAULT_GENERATOR,
  applicationName: DEFAULT_APP_NAME,
  referrer: DEFAULT_REFERRER,
  keywords: DEFAULT_META_KEYWORDS,
  authors: {
    name: DEFAULT_META_AUTHOR_NAME,
    url: DEFAULT_META_AUTHOR_URL,
  },

  colorScheme: LIGHT_MODE,
  creator: DEFAULT_META_AUTHOR_NAME,
  publisher: DEFAULT_META_AUTHOR_NAME,
  formatDetection: {
    email: true,
    address: false,
    telephone: false,
  },
  metadataBase: new URL(BASE_URL),
  alternates: {
    canonical: BASE_URL,
    types: {
      'application/rss+xml': RSS_XML_URL,
      'application/atom+xml': RSS_ATOM_URL,
      'application/json': RSS_JSON_URL,
    },
  },
  openGraph: {
    title: `${DEFAULT_META_TITLE}`,
    description: `${DEFAULT_META_DESCRIPTION}`,
    url: BASE_URL,
    siteName: `${DEFAULT_APP_NAME}`,
    images: [
      {
        url: DEFAULT_OG_IMAGE_URL,
        width: 1500,
        height: 855,
      },
      {
        url: DEFAULT_OG_IMAGE_URL,
        width: 1500,
        height: 855,
        alt: DEFAULT_META_TITLE,
      },
    ],
    locale: 'ko_KR',
    type: 'website',
  },
  robots: {
    index: false,
    follow: true,
    nocache: true,
    googleBot: {
      index: true,
      follow: false,
      noimageindex: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  icons: {
    icon: '/icon.png',
    apple: '/apple-icon.png',
  },
  twitter: {
    card: 'summary_large_image',
    title: `${DEFAULT_META_TITLE} | twitter`,
    description: `${DEFAULT_META_DESCRIPTION} | twitter`,
  },
};
</code></pre>
<h3>src/app/blog/[slug]/page.tsx</h3>
<p>RootLayout과 다른 메타데이터가 필요한 정보만 객체로 return 해주면 된다.</p>
<pre><code class="language-tsx">export async function generateMetadata({
  params: { slug },
}: {
  params: { slug: string };
}) {
  const { data } = await API.fetchBlogDetail(slug);
  return {
    title: data.title,
    description: data.description || data.title,
    keywords: data.tags.split(' '),
    alternates: {
      canonical: `${BASE_URL}/${slug}`,
    },
    openGraph: {
      title: `${data.title}`,
      description: `${data.description || data.title}`,
      url: `${BASE_URL}/${slug}`,
      alternates: {
        canonical: `${BASE_URL}/${slug}`,
      },
      images: [
        {
          url:
            data.images?.length > 0 ? data.images[0].url : DEFAULT_OG_IMAGE_URL,
          width: 1550,
          height: 800,
        },
        {
          url:
            data.images?.length > 0 ? data.images[0].url : DEFAULT_OG_IMAGE_URL,
          width: 1550,
          height: 800,
          alt: data.title,
        },
      ],
    },
    twitter: {
      card: 'summary_large_image',
      title: `${data.title} | twitter_page`,
      description: `${data.description || data.title} | twitter_page`,
    },
  };
}
</code></pre>
<h2>결과 확인</h2>
<blockquote>
<p>크롬 개발자 도구로 확인</p>
</blockquote>
<blockquote>
<p>카카오톡 og-image 확인</p>
</blockquote>
<blockquote>
<p>카카오톡 dynamic metadata og-image 확인</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="markdown"/>
        <category label="view"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13 react-markdown 적용하기]]></title>
        <id>162-markdown-view</id>
        <link href="https://nostrss.me/blog/162-markdown-view"/>
        <updated>2023-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이쁘게 만드는게 이렇게 어려운지 몰랐지...]]></summary>
        <content type="html"><![CDATA[<p>이제 블로그 본문의 상세페이지를 꾸밀 차례다.</p>
<p>마크다운 파일 컨텐츠를 바로 렌더링 할 경우 마크다운 문법이 적용이 되어 보이질 않는다.</p>
<p>그렇기 때문에 다른 패키지를 사용하여 보여줄 생각이다.</p>
<h2>react-markdown 적용하기</h2>
<p><a href="https://www.npmjs.com/package/react-markdown">react-markdown 바로가기</a></p>
<p>위의 패키지를 설치하고, 아래와 같이 사용하면 된다.</p>
<pre><code class="language-tsx">'use client';
import ReactMarkdown from 'react-markdown';

xport default function MarkDownViewer({ content }: { content: string }) {
  return (
    &#x3C;ReactMarkdown>{content}&#x3C;/ReactMarkdown>
  );
}
</code></pre>
<p>설치 후 이렇게 마크다운 정보를 <code>children</code>으로 넘겨주기만 하면 끝이다.</p>
<p><code>npm</code> 페이지에서 <code>react</code>로 예시로는 <code>Props</code>로 넘겨주도록 되어 있었는데, 에러가 발생해서 위와 같이 <code>children</code>으로 넘겨주었다.</p>
<h2>remarkGfm 적용하기</h2>
<p>그런데 결과물이 조금은 부족해보인다.</p>
<p>기존에 <code>github</code>에서 보던 마크다운과는 다소 다르게 보인다.</p>
<p>왜냐하면 우리가 github에서 보던 마크다운은 표준이 아니기 때문이다. <code>github</code>에서 보는 마크다운은 <code>github</code>에서 자체적으로 추가한 문법들이 추가되어 있다.</p>
<p>그렇기 때문에 평소 깃허브와 동일하게 보이게 하려면 별도의 <code>plugin</code>을 이용해야 한다.</p>
<p>이때 사용할 수 있는 플러그인으로 <code>remarkGfm</code>이 있다.</p>
<p>여기서 <code>GFM</code>은 <code>Github Flavored Markdown</code>의 약자이며 이에 해당하는 문법은 아래와 같다.</p>
<ul>
<li>autolink literals</li>
<li>footnotes</li>
<li>strikethrough</li>
<li>tables</li>
<li>tasklists.</li>
</ul>
<p><a href="https://www.npmjs.com/package/remark-gfm">remarkGfm 바로가기</a></p>
<p><code>remarkGfm</code>을 <code>react-markdown</code>에 적용하는 방법은 아래와 같다.</p>
<pre><code class="language-tsx">'use client';
import ReactMarkdown from 'react-markdown';

export default function MarkDownViewer({ content }: { content: string }) {
  return &#x3C;ReactMarkdown remarkPlugins={[remarkGfm]}>{content}&#x3C;/ReactMarkdown>;
}
</code></pre>
<p>위와 같이 추가하고 결과물을 확인해봤다.</p>
<p>약간의 변화가 있었지만, 여전히 부족해보인다.</p>
<h2>CSS 커스텀하기</h2>
<p>조금 더 이쁘게 보이게 하기 위해 <code>syntax-highlighting</code>을 적용해서 코드블럭 CSS를 수정해볼 생각이다.</p>
<p><a href="https://www.npmjs.com/package/react-syntax-highlighter">react-syntax-highlighter 바로가기</a></p>
<p>코드블럭은 <code>&#x3C;code>&#x3C;/code></code> 태그이므로 아래와 같이 작성해줬다.</p>
<pre><code class="language-tsx">'use client';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { materialDark } from 'react-syntax-highlighter/dist/esm/styles/prism';

export default function MarkDownViewer({ content }: { content: string }) {
  return (
    &#x3C;ReactMarkdown
      remarkPlugins={[remarkGfm]}
      components={{
        code({ node, inline, className, children, ...props }) {
          const match = /language-(\w+)/.exec(className || '');

          return !inline &#x26;&#x26; match ? (
            &#x3C;SyntaxHighlighter
              {...props}
              style={materialDark}
              language={match[1]}
              PreTag='article'
              showLineNumbers={true}
            >
              {String(children).replace(/\n$/, '')}
            &#x3C;/SyntaxHighlighter>
          ) : (
            &#x3C;code {...props} className={className}>
              {children}
            &#x3C;/code>
          );
        },
      }}
    >
      {content}
    &#x3C;/ReactMarkdown>
  );
}
</code></pre>
<p><code>ReactMarkdown</code> 은 <code>components</code>라는 <code>props</code>를 받을 수 있는데, 이것을 통해 커스터마이징을 할 수 있다.</p>
<p>그리고 아래와 같이 코드블럭 부분이 이쁘게 변경된 것을 확인 할 수 있었다.</p>
<p>이제 나머지 태그들도 커스터 마이징 해보자.</p>
<pre><code class="language-tsx">'use client';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { materialDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import Image from 'next/image';

export default function MarkDownViewer({ content }: { content: string }) {
  return (
    &#x3C;ReactMarkdown
      remarkPlugins={[remarkGfm]}
      components={{
        code({ node, inline, className, children, ...props }) {
          const match = /language-(\w+)/.exec(className || '');
          return !inline &#x26;&#x26; match ? (
            &#x3C;SyntaxHighlighter
              {...props}
              style={materialDark}
              language={match[1]}
              PreTag='div'
              showLineNumbers={true}
            >
              {String(children).replace(/\n$/, '')}
            &#x3C;/SyntaxHighlighter>
          ) : (
            &#x3C;code {...props} className={className}>
              {children}
            &#x3C;/code>
          );
        },
        img: (image) => (
          &#x3C;Image
            className='w-full h-auto object-cover'
            src={image.src || ''}
            alt={image.alt || ''}
            width={500}
            height={500}
            placeholder='blur'
          />
        ),
        h1: ({ children, ...props }) => (
          &#x3C;h1 className='prose text-2xl dark:text-white' {...props}>
            {children}
          &#x3C;/h1>
        ),
        h2: ({ children, ...props }) => (
          &#x3C;h2 className='prose text-xl dark:text-white' {...props}>
            {children}
          &#x3C;/h2>
        ),
        h3: ({ children, ...props }) => (
          &#x3C;h3 className='prose text-lg dark:text-white' {...props}>
            {children}
          &#x3C;/h3>
        ),
        p: ({ children, ...props }) => (
          &#x3C;p className='prose dark:text-white' {...props}>
            {children}
          &#x3C;/p>
        ),
        li: ({ children, ...props }) => {
          const liProps = { ...props, ordered: 'false' };
          return (
            &#x3C;li className='prose dark:text-white' {...liProps}>
              {children}
            &#x3C;/li>
          );
        },
        strong: ({ children, ...props }) => (
          &#x3C;strong className='prose dark:text-white' {...props}>
            {children}
          &#x3C;/strong>
        ),
        a: ({ children, ...props }) => (
          &#x3C;a className='prose dark:text-blue-300' {...props}>
            {children}
          &#x3C;/a>
        ),
      }}
    >
      {content}
    &#x3C;/ReactMarkdown>
  );
}
</code></pre>
<p>커스텀한 태그들이 수정되었다.</p>
<p>그런데 문제점이 있다. 내가 이미지 삽입을 위해 추가한 붉은 박스의 <code>html</code> 코드가 문자열로 그대로 노출되고 있다.</p>
<h2>rehypeRaw 적용하기</h2>
<p>마크다운 컨텐츠에 담겨있는 <code>html</code>을 그대로 렌더링 하기 위해서는 또 다시 추가 작업을 해야한다.</p>
<p>여기서 정말 많은 검색과 시행착오를 겪었는데, 결론을 정리하면 <code>rehypeRaw</code> 이라는 플러그인을 설치하면 적용하면 된다.</p>
<blockquote>
<p>그리고 7.0버전의 경우 오류가 발생했는데, 6.1.0 버전으로 다운그레이드 하니 정상적으로 작동했다.</p>
</blockquote>
<p><a href="https://www.npmjs.com/package/rehype-raw/v/6.1.0">rehype-raw 바로가기</a></p>
<p>적용방법은 아래와 같다.</p>
<pre><code class="language-tsx">&#x3C;ReactMarkdown
      className='prose max-w-none dark:text-white '
      remarkPlugins={[remarkGfm]}
      rehypePlugins={[rehypeRaw]}
</code></pre>
<p>후.. 생각보다 어려웠다. 그래도 이제 마크다운 뷰어를 완성했다.</p>
<p>나머진 조금씩 수정해나가면 될 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="markdown"/>
        <category label="view"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13 App router에 Google Analytics 적용하기]]></title>
        <id>161-next-google-analytics</id>
        <link href="https://nostrss.me/blog/161-next-google-analytics"/>
        <updated>2023-09-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[아직 Next13에 Google Analytics를 적용한 경우가 없는지 자료가 부실했다. 그래서 직접 정리한 내용]]></summary>
        <content type="html"><![CDATA[<p>개인 블로그 작업이 거의 마무리 단계가 되어가고 있다. 그리고 오늘은 <code>Google Analytics</code>를 적용해보려고 한다.</p>
<p>적용 방법은 링크를 따라 가면 자세하게 설명이 되어 있어서 따라하면 된다.</p>
<p><a href="https://support.google.com/sites/answer/97459?hl=ko">📌 사이트에 애널리틱스 사용하기 📌</a></p>
<p>다만 <code>Next</code>에 직접 적용하는데 살짝 어려움이 있었다.</p>
<p>일단, 위의 링크를 따라하면 아래와 같은 <code>script</code>를 구글에서 알려준다.</p>
<pre><code class="language-html">&#x3C;!-- Google tag (gtag.js) -->
&#x3C;script
  async
  src="https://www.googletagmanager.com/gtag/js?id=G-xxxxxxxxx"
>&#x3C;/script>
&#x3C;script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-xxxxxxxxx');
&#x3C;/script>
</code></pre>
<p>위의 코드를 이제 <code>Next</code> <code>head</code>에 적용하기만 하면 끝이다.</p>
<p>모든 페이지에서 위의 스크립트가 호출되어야 하므로 일단 나는 <code>RootLayout</code>에 적용하기로 마음 먹었다.</p>
<p>아래는 내가 작성 및 적용한 코드이다.</p>
<p>먼저 위의 코드를 포함한 <code>Client</code> 컴포넌트를 하나 만들었다.</p>
<pre><code class="language-tsx">// Analytics.tsx
'use client';

import Script from 'next/script';

export default function Analytics() {
  return (
    &#x3C;>
      &#x3C;Script
        async
        src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_ID}`}
        strategy='afterInteractive'
      />
      &#x3C;Script id='google-analytics' strategy='afterInteractive'>
        {`window.dataLayer = window.dataLayer || []; 
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '${process.env.NEXT_PUBLIC_GA_ID}');
          `}
      &#x3C;/Script>
    &#x3C;/>
  );
}
</code></pre>
<p>그리고 <code>RootLayout</code>에는 아래와 같이 적용했다.</p>
<pre><code class="language-tsx">//layout.tsx
export default function RootLayout({ children }: IPropsChildren) {
  return (
    &#x3C;html lang='kr'>
      &#x3C;Analytics />
      &#x3C;QueryProviders>
        &#x3C;body className={sans.className}>
          &#x3C;Header menus={menus} />
          &#x3C;div className='w-full flex flex-col items-center'>
            &#x3C;section className='w-full max-w-[1192px] flex flex-row justify-center'>
              {children}
              &#x3C;TagBox />
            &#x3C;/section>
          &#x3C;/div>
        &#x3C;/body>
      &#x3C;/QueryProviders>
    &#x3C;/html>
  );
}
</code></pre>
<p>그리고 <code>head</code>에 정상적으로 스크립트가 심어졌는지 확인해보자</p>
<blockquote>
<p>정상!!</p>
</blockquote>
<p>이제 배포 후 구글애널리틱스와 통신이 되면 끝나게 된다.</p>
<p>모든게 정상적으로 작동하는 것을 확인할 수 있다.</p>
<p>이제 구글애널리틱스가 내 블로그로 접속하는 유저들의 통계를 수집해 줄 것이다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="next"/>
        <category label="google-analytics"/>
        <category label="app-router"/>
        <category label="layout"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[면접리뷰]클로저(Closure)란? (3)]]></title>
        <id>160-interview-review-closure3</id>
        <link href="https://nostrss.me/blog/160-interview-review-closure3"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[클로저는 언제 사용하는가? 자주 사용해서 익숙해지자.]]></summary>
        <content type="html"><![CDATA[<p>이론적인 내용을 정리하고 이제는 실제로 어떻게 쓰이는지 알아보자.<br>
poiemaweb에서 클로저가 사용되는 예제가 있어서 가져와 봤다.<br>
<a href="https://poiemaweb.com/js-closure">🔗 poiemaweb 클로저 바로가기 🔗</a></p>
<h2>1. 최신 상태유지</h2>
<pre><code class="language-js">&#x3C;!DOCTYPE html>
&#x3C;html>
&#x3C;body>
  &#x3C;button class="toggle">toggle&#x3C;/button>
  &#x3C;div class="box" style="width: 100px; height: 100px; background: red;">&#x3C;/div>

  &#x3C;script>
    var box = document.querySelector('.box');
    var toggleBtn = document.querySelector('.toggle');

    var toggle = (function () {
      var isShow = false;

      // ① 클로저를 반환
      return function () {
        box.style.display = isShow ? 'block' : 'none';
        // ③ 상태 변경
        isShow = !isShow;
      };
    })();

    // ② 이벤트 프로퍼티에 클로저를 할당
    toggleBtn.onclick = toggle;
  &#x3C;/script>
&#x3C;/body>
&#x3C;/html>
</code></pre>
<p>위의 코드는 버튼을 클릭하면 박스가 사라지고 나타나는 코드이다.</p>
<p>일반적으로 함수는 반환하고 즉시 소멸하기 때문에, 이때 함수 내부의 변수의 값도 소멸하게 된다.</p>
<p>하지만 위의 코드는 클로저를 사용하여 함수 내부의 변수를 최신으로 유지하고 있다.</p>
<p>그런데 그 기능이 마치 React에서 쓰던 useState와 비슷한 것 같다.</p>
<p>클로저로 useState를 구현 할 수 있지 않을까?</p>
<p>아래는 간단한 기능의 useState를 클로저로 구현해본 코드이다.</p>
<p>버튼을 클릭하면 console에 true, false가 번갈아가며 출력되도록 작업해봤다.</p>
<blockquote>
<p>isState값이 변경될 때 렌더링을 다시 일으키고 isColor값도 없데이트를 해줘야 하는데, 방법을 찾지 못해서 일단은 이렇게라도 흉내를 내보았다.</p>
</blockquote>
<pre><code class="language-jsx">export default function UseStateByClosure() {
  function useCustomState(initialState: any) {
    let state = initialState;

    const isState = () => state;
    const setState = () => {
      state = !isState();
      console.log(state);
    };

    return [isState(), setState];
  }

  const [isColor, setIsColor] = useCustomState(false);

  return (
    &#x3C;div>
      &#x3C;button type='button' onClick={() => setIsColor()}>
        클릭
      &#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<h2>2. 전역변수 사용의 억제</h2>
<p>전역변수의 경우 누구나 접근할 수 있기 때문에, 의도치 않게 값이 변경이 될 수 있다.</p>
<p>따라서 전역변수를 클로저를에 넣어서 사용하게 되면 외부에서 접근이 불가능하기 때문에 의도치 않은 값의 변경을 막을 수 있다.</p>
<h2>3. 정보의 은닉화</h2>
<p>이번에는 조금 다른 방식으로 클로저를 이용하는 방법에 대해서 알아보자.</p>
<p>아래는 생성자함수를 선언하고 new 연산자를 통해 새로운 객체를 생성하는 코드이다.</p>
<blockquote>
<p>생성자 함수와 일반 함수에 기술적차이는 없다. 다만 생성자 함수는 아래 두 관례를 따른다고 한다.
함수이름의 첫글자는 대문자로 시작한다.
반드시 new 연산자를 사용하여 실행한다.</p>
</blockquote>
<pre><code class="language-js">function Counter() {
  // 카운트를 유지하기 위한 자유 변수
  let hiddenCounter = 0;

  // 클로저
  this.increase = function () {
    return ++hiddenCounter;
  };

  // 클로저
  this.decrease = function () {
    return --hiddenCounter;
  };
}

const myCounter = new Counter();

console.log(myCounter); // Counter { increase: f, decrease: f }
console.log(myCounter.increase()); // 1
console.log(myCounter.decrease()); // 0
</code></pre>
<p>위의 console.log에서 보듯이 직접 Counter 내부에 생성된 변수 hiddenCounter에 외부에서 직접 접근을 할 수가 없게 된다.</p>
<p>이렇게 되면 외부에서는 increase, decrease 함수를 통해서만 hiddenCounter에 접근이 가능하게 된다.</p>
<p>이를 통해 다른 클래스 기반의 언어에서 말하는 정보의 은닉화를 어느정도 구현할 수가 있다.</p>
<blockquote>
<p>주의 : 아래와 같이 this에 바인딩되어 있으면 외부에서 접근이 가능해진다.</p>
</blockquote>
<pre><code class="language-js">function Counter() {
  // 카운트를 유지하기 위한 자유 변수
  this.hiddenCounter = 0;

  // 클로저
  this.increase = function () {
    return ++this.hiddenCounter;
  };

  // 클로저
  this.decrease = function () {
    return --this.hiddenCounter;
  };
}

const myCounter = new Counter();

console.log(myCounter); // Counter { hiddenCounter: 0, increase: f, decrease: f }
console.log(myCounter.increase()); // 1
console.log(myCounter.decrease()); // 0
</code></pre>
<p>알아두면 유용할 기법인 것 같다. 나중에 기억해두었다가 사용할 경우가 있으면 적용해봐야겠다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="interview"/>
        <category label="javascript"/>
        <category label="closure"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[면접리뷰]클로저(Closure)란? (2)]]></title>
        <id>159-interview-review-closure2</id>
        <link href="https://nostrss.me/blog/159-interview-review-closure2"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[다양한 예제를 보고 클로저에 대해 조금 더 이해해보자.]]></summary>
        <content type="html"><![CDATA[<p>이번에는 여러 사이트들의 예제들을 보면서 클로저에 대해 조금 더 이해해보려고 한다.</p>
<h2>MDN 예제</h2>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures">🔗 MDN 클로저 바로가기 🔗</a></p>
<pre><code class="language-js">function makeAdder(x) {
  return function (y) {
    // debugger; 브라우저에서 실행 시 중단점
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12
</code></pre>
<p>특이한 코드이다. 이런 식으로 코드가 작성가능하구나 싶었다.</p>
<p>위 코드의 클로저를 확인해보자.</p>
<p>add5(2) 클로저가 생성된 모습이다.
클로저에 x: 5가 저장되어 있고, y: 2가 인자로 전달는 모습을 볼 수 있다.</p>
<p>이번에는 add10(2) 클로저가 생성된 모습이다.
위와 마찬가지로 클로저에 x: 10이 저장되어 있고, y: 2가 인자로 전달는 모습을 볼 수 있다.
</p>
<h2>javascript.info 예제</h2>
<p><a href="https://ko.javascript.info/closure">🔗 javascript.info 클로저 바로가기🔗</a></p>
<p>다음 예제에서 sayHi()의 결과는 John일까 Pete일까?</p>
<pre><code class="language-js">let name = 'John';

function sayHi() {
  alert('Hi, ' + name);
}

name = 'Pete';

sayHi(); // what will it show: "John" or "Pete"?
</code></pre>
<p>나는 처음에 John이라고 생각했다가 결과를 보고 깜짝 놀랐다.<br>
정답은 Pete이다.</p>
<p>왜 그런지 위의 코드를 시간 순으로 브라우저에서 살펴보자.</p>
<ul>
<li>name에 John이 할당된다.</li>
<li>name에 Pete가 할당된다.</li>
<li>sayHi()가 호출된다.</li>
<li>name 변수에 접근하여 alert을 띄운다.</li>
</ul>
<p>즉, sayHi()가 호출되는 시점에 name 변수에는 Pete가 할당되어 있기 때문에 Pete가 출력되는 것을 볼 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="interview"/>
        <category label="javascript"/>
        <category label="closure"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[면접리뷰]클로저(Closure)란?]]></title>
        <id>158-interview-review-closure</id>
        <link href="https://nostrss.me/blog/158-interview-review-closure"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[어설프게 알고 면접보다 망했다. 다음엔 실수하지 말자!]]></summary>
        <content type="html"><![CDATA[<p>오늘 면접을 보면서 내가 이론 공부에 대해 개념적으로만 간단히 알고있다는 느낌을 받았다.</p>
<p>그래서 면접 질문에 대해서 복습차원에서 정리해보려고 한다.</p>
<h2>Step1: 클로저(Closure)란 무엇인가?</h2>
<ul>
<li>
<p>MDN</p>
<blockquote>
<p>클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다. 즉, 클로저는 내부 함수에서 외부 함수의 범위에 대한 접근을 제공합니다. JavaScript에서 클로저는 함수 생성 시 함수가 생성될 때마다 생성됩니다.</p>
</blockquote>
</li>
<li>
<p>javascript.info</p>
<blockquote>
<p>클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다.</p>
</blockquote>
</li>
<li>
<p>poiemaweb</p>
<blockquote>
<p>클로저(closure)는 자바스크립트에서 중요한 개념 중 하나로 자바스크립트에 관심을 가지고 있다면 한번쯤은 들어보았을 내용이다. execution context에 대한 사전 지식이 있으면 이해하기 어렵지 않은 개념이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(Functional Programming language: 얼랭(Erlnag), 스칼라(Scala), 하스켈(Haskell), 리스프(Lisp)…)에서 사용되는 중요한 특성이다.</p>
</blockquote>
</li>
</ul>
<p>내가 Javascript를 공부할때 자주 참고하는 사이트에서 클로저에 대한 설명을 가져왔다.</p>
<p>일단 위 내용의 주요 키워드는 이렇다.</p>
<ul>
<li>외부함수, 외부변수, 내부함수, 내부함수</li>
<li>어휘적 환경(Lexical Scope)</li>
<li>자바스크립트 뿐만 아니라 다른 언어에서도 쓰이는 기법이자 개념이다.</li>
</ul>
<pre><code class="language-js">function init() {
  // 외부 함수
  var name = 'Mozilla'; // 외부 변수
  function displayName() {
    // 내부 함수, 클로저
    console.log(name); // 내부 함수에서 외부 변수 접근
  }
  displayName();
}

init(); // Mozilla
</code></pre>
<p>위의 코드에서 init() 함수가 실행되면 displayName() 함수가 실행된다.</p>
<p>이 때 외부 변수인 name에 접근하여 Mozilla가 출력된다.</p>
<p>이렇게 외부함수의 변수에 접근할 수 있는 내부함수를 클로저라고 부른다.</p>
<p>여기까지 이해한 내용은 이렇다.</p>
<blockquote>
<p>클로저는 외부함수의 변수에 접근하는 내부함수이다.</p>
</blockquote>
<h2>Q : 함수가 외부 변수에 접근하는 것은 당연한 것 아닌가?</h2>
<p>위의 내용만 보면 단순히 내부 함수가 외부 함수의 변수에 접근하는 당연한 내용처럼만 보인다.</p>
<p>그런데 왜 클로저라는 별도의 네이밍을 하면서 이 개념을 정의해 놓은 것일까?</p>
<p>조금 더 클로저에 대해 알아보자</p>
<h2>Step2: 클로저 = 외부 변수 + 내부 함수</h2>
<p>위의 코드를 아래와 같이 조금 변형해 보았다.</p>
<pre><code class="language-js">function init() {
  // 외부 함수
  var name = 'Mozilla'; // 외부 변수
  function displayName() {
    // 내부 함수, 클로저
    console.log(name); // 내부 함수에서 외부 변수 접근
  }
  return displayName;
}

const showName = init();
console.log(showName);

// console.log 결과
// ƒ displayName() {
//     // 내부 함수, 클로저
//     console.log(name); // 내부 함수에서 외부 변수 접근
//   }

showName(); // Mozilla
</code></pre>
<p>console.log를 살펴보면 showName 변수에는 init함수의 return 값인 displayName 함수가 담겨있다.</p>
<p>그리고 showName을 실행하면 Mozilla가 출력되고 있다.</p>
<p>조금만 생각해보면 말이 안되는 상황인 것이다.</p>
<p>showName 함수에 name 변수가 없는데도 Mozilla가 출력되고 있는 것이다.</p>
<p>위 코드의 결과는 아래와 같이 해석할 수 있다.</p>
<pre><code class="language-js">function displayName() {
  console.log(name);
}
displayName(); // Mozilla
</code></pre>
<p>name 변수가 선언도 되지 않았고, 할당도 되지 않았는데 Mozilla가 출력되고 있는 것이다.</p>
<p>앞서 클로저의 정의를 다시 살펴보자.</p>
<blockquote>
<p>클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다.<br>
클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다.</p>
</blockquote>
<p>단순히 외부함수에 접근하는 내부 변수가 아니라, 외부함수의 변수를 기억한다는 내용이 있다.</p>
<p>name 변수를 showName 함수가 기억하고 있기 때문에 Mozilla가 출력되고 있다고 말하고 있다.</p>
<p>즉, 클로저는 아래와 같은 모습이라는 것이다.</p>
<pre><code class="language-js">const name = 'Mozilla';

function displayName() {
  console.log(name);
}
</code></pre>
<h2>Step3. 디버거로 클로저 직접 확인해보기</h2>
<p>위에서는 클로저가 외부함수의 변수를 기억한다고 했다.</p>
<p>이걸 눈으로 직접 확인해보고 싶어졌다.</p>
<p>그래서 아래와 같이 디버거를 추가하고 브라우저에서 실행해보았다.</p>
<pre><code class="language-js">function init() {
  // 외부 함수
  var name = 'Mozilla'; // 외부 변수
  function displayName() {
    // 내부 함수, 클로저
    debugger; // 디버거 추가!!
    console.log(name); // 내부 함수에서 외부 변수 접근
  }
  return displayName;
}

const showName = init();
showName();
</code></pre>
<p>크롬브라우저 > 개발자도구 > Sources 탭에서 위와 같이 Closure 값을 확인할 수 있었다.</p>
<h2>Q : 모든 변수의 값이 클로저에 저장되는 것일까?</h2>
<p>어떤 변수값에 대한 참조값이 클로저에 저장되는 것일까?</p>
<p>모든 변수값이 저장되면 비효율적이지 않을까 해서 테스트를 해보았다.</p>
<p>displayName 함수 외부에 age변수와 counter라는 함수를 선언하고 실행해보았다.
</p>
<p>내부에서 사용하지 않는 변수는 클로저에 저장되지 않는 것을 확인할 수 있었다.</p>
<p>그럼 이번에는 displayName 함수안에서 age 변수와 counter 함수를 console.log로 출력해보았다. 예상대로라면 콜러저에 age와 counter가 포함되어 있을 것이다.</p>
<p>예상대로 클로저에 age변수와 함수까지 저장되는 것을 확인할 수 있었다.</p>
<p>이제 여기까지 이해한 내용을 다시 정리해 봐야겠다.</p>
<blockquote>
<p>클로저란 : 외부함수 안에서 내부 함수가 선언될 때, 내부함수에서 사용되는 외부함수의 Lexical scope(어휘적 환경)를 함께 저장하는 것을 클로저라고 한다.</p>
</blockquote>
<p>이전보다 조금 더 명확하게 정리가 되는 느낌이다.</p>
<p>다음에는 조금 더 심화된 내용을 정리해봐야 할 것 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="interview"/>
        <category label="javascript"/>
        <category label="closure"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[React-Query] 무한 스크롤 구현하기]]></title>
        <id>157-react-query-inifinite-scroll</id>
        <link href="https://nostrss.me/blog/157-react-query-inifinite-scroll"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[별도의 무한스크롤 라이브러리 없이 useInfiniteQuery와 IntersectionObserver를 통해 무한 스크롤을 구현해보자]]></summary>
        <content type="html"><![CDATA[<p>그동안 <code>무한스크롤</code>을 구현하기 위해 몇가지 라이브러리를 사용해봤다.</p>
<p>그런데 이번에 <code>React-Query</code> 문서를 보던 중 <code>useInfiniteQuery</code>를 제공하는 것을 알았고 이를 통해 무한스크롤을 구현해보기로 했다.</p>
<h2>무한스크롤의 구현원리</h2>
<p>무한 스크롤을 구현하기 위해서는 2가지가 준비되어야 한다.</p>
<ol>
<li>
<p>일정 단위(개수)별로 컨텐츠를 불어올수 있는 API가 필요하다. (ex. 10개씩)</p>
</li>
<li>
<p>페이지 스크롤이 끝에 도달했을 때, 추가적인 데이터를 불러오기 위한 트리거를 만들어야 한다.</p>
</li>
</ol>
<p>예를 들어 설명하면 이렇다.</p>
<ul>
<li>10개의 컨텐츠를 불러온다.</li>
<li>스크롤을 내리다 끝에 도달하면 트리거를 발동한다.</li>
<li>트리거가 발동되면 10개의 컨텐츠를 추가로 불러온다.</li>
</ul>
<p>위 과정을 더이상의 컨텐츠가 없을때까지 반복하면 무한스크롤이 완성된다.</p>
<h2>Next.js Api Route를 이용한 무한스크롤 API 만들기</h2>
<p>별도 데이터베이스를 사용하지 않고 프로젝트에 있는 마크다운 파일을 읽어와서 무한스크롤 API를 만들었다.</p>
<p>그래서 마크다운 파일을 읽어와서 가공하는 과정이 있기 때문에 코드가 다소 길다.</p>
<p>그리고 api 응답값에서 <code>중요</code>한 건 <code>다음페이지</code>가 있는지 여부를 나타내는 값이다.</p>
<p>나중에 <code>react-query</code>의 <code>useInfiniteQuery</code>를 사용할 때 이 값을 이용해 다음 페이지가 있는지 여부를 판단할 것이다.</p>
<pre><code class="language-ts">import { UTIL } from '@/util';
import { readFile, readdir } from 'fs/promises';
import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import parse from 'node-html-parser';
import { ImgesArrayItem } from '@/type/common';

// 예시 : /api/posts?page=1&#x26;limit=10
export async function GET(req: NextRequest) {
  // 파싱할 req.url을 이용해 URL 객체 생성
  const url = new URL(req.url);

  // page, limit 쿼리스트링 파라미터가 없을 경우 기본값 1, 10으로 설정
  const page = Number(url.searchParams.get('page')) || 1;
  const limit = Number(url.searchParams.get('limit')) || 10;

  // 파일경로를 생성하고 파일리스트를 읽어온다.
  const filePath = path.join(process.cwd(), 'posts');
  const fileList = await readdir(filePath);

  // 파일리스트를 순회하며 각 파일의 정보를 읽고 가공한다.
  const markdowmMetaData = await Promise.all(
    fileList.map(async (file) => {
      const fileData = await readFile(`${filePath}/${file}`, 'utf-8');
      const currentPostId = {
        currentPostId: file.replace('.md', ''),
      };
      const markDownContent = UTIL.removeMetaData(fileData);

      const imgArr = getImageSrc(markDownContent);

      return {
        ...UTIL.getMarkDownMetaData(fileData, currentPostId),
        images: imgArr,
      };
    })
  );

  // 가공된 컨텐츠 배열을 타이틀, 날짜 순으로 정렬하고 페이지와 limit을 이용해 데이터를 자른다.
  const sortDataByTitle = UTIL.sortByTitle(markdowmMetaData);
  const sortDataByDate = UTIL.sortByDate(sortDataByTitle);
  const sliceData = UTIL.slicePerPage(sortDataByDate, page, limit);

  return NextResponse.json({
    data: sliceData,
    total: markdowmMetaData.length,
    // 중요! 다음 페이지가 있는지 여부를 나타내는 값
    // 다음 페이지가 있으면 페이지 number, 없ㅇ면 null
    nextPage: UTIL.getNextpage(page, limit, markdowmMetaData.length),
  });
}

const getImageSrc = (htmlElement: string | undefined) => {
  if (!htmlElement) return [];
  const imgHtml = parse(htmlElement).getElementsByTagName('img');
  const imgUrl: Array&#x3C;ImgesArrayItem> = [];
  imgHtml.forEach((img) => {
    const imgParse = img.getAttribute('src');
    imgUrl.push({ url: imgParse });
  });

  const result = imageUrlValidate([...imgUrl]);

  return [...result];
};

const imageUrlValidate = (images: ImgesArrayItem[]) => {
  const validateImages = images.filter((image) => {
    if (image.url?.includes('http')) {
      return image.url;
    }
  });
  return [...validateImages];
};
</code></pre>
<h3>API 응답 예시</h3>
<pre><code class="language-json">{
  "data": [
    {
      "currentPostId": "2023-08-23-144-nestjs",
      "layout": "post",
      "title": "'[Nest.js] - 소개'",
      "author": "'Nostrss'",
      "comments": "true",
      "tags": "nestjs node express javascript typescript",
      "excerpt_separator": "",
      "sticky": "",
      "hidden": "",
      "date": "2023-08-23",
      "images": []
    }
    // (... 생략)
  ],
  "total": 25,
  "nextPage": 2 // 중요!
}
</code></pre>
<h2>useInfiniteQuery 적용하기</h2>
<p><a href="https://tanstack.com/query/latest/docs/react/guides/infinite-queries">🔗 Tanstack Infinite Queries 문서보기 🔗</a></p>
<p>아래는 공식문서의 일부를 발췌한 것이다.<br>
<code>Query</code>와 사용법이 비슷하지만 다소 다르게 생겼다. 하나씩 살펴보자.</p>
<pre><code class="language-tsx">const {
  data, // api 응답 객체
  error,
  fetchNextPage, // 다음 페이지(컨텐츠)를 불러오는 함수
  hasNextPage, // Boolean 값, 다음 페이지가 있는지 여부를 나타낸다.
  isFetching, // 로드가 진행중인지 여부를 나타낸다.
  isFetchingNextPage // 추가로드가 진행중인지 여부를 나타낸다.,
  status,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
});
</code></pre>
<p>위 코드의 작동방식을 보면 다음과 같다.</p>
<ul>
<li><code>queryKey</code> : 쿼리의 키값을 나타낸다. 이 키값을 이용해 캐시를 관리한다.</li>
<li><code>queryFn</code> : 쿼리를 실행하는 함수를 나타낸다. 이 함수는 <code>queryKey</code>를 인자로 받는다.</li>
<li><code>getNextPageParam</code> : 다음 페이지를 불러오는 함수를 나타낸다. 이 함수는 <code>queryFn</code>의 결과값을 인자로 받으며, 다음 페이지가 있는 경우 실행된다.</li>
</ul>
<h2>실제 적용된 코드</h2>
<pre><code class="language-tsx">const { data, isFetching, fetchNextPage, hasNextPage } = useInfiniteQuery({
  queryKey: ['post'],
  queryFn: ({ pageParam = 1 }) => fetchPostList(pageParam, limit),
  getNextPageParam: (lastPage) => {
    console.log(lastPage);
    return lastPage.nextPage;
  },
});
</code></pre>
<p>위에서 찍힌 <code>console.log</code>를 살펴볼 필요가 있다.</p>
<pre><code class="language-json">{
  "data": [
    //생략
  ],
  "total": 25,
  "nextPage": 2
}
</code></pre>
<p>getNextPageParam 함수의 인자로 들어온 lastPage는 위와 같은 형태이다.</p>
<p>그리고 이 함수의 반환값은 다음 페이지의 <code>number</code>이며, 이 값은 <code>queryFn</code>의 <code>pageParam</code>으로 들어간다.</p>
<p>그래서 만약 백엔드 개발자가 따로 있다면 응답값에 다음페이지의 number를 반환하도록 요청해야한다.</p>
<h2>IntersectionObserver를 이용한 무한스크롤 구현하기</h2>
<p><a href="https://simian114.gitbook.io/blog/undefined/react/intersectionobserverapi">🔗 참고 블로그 🔗</a></p>
<p>이제는 다음페이지를 불러오도록 하기 위해서 트리거를 구현해야한다.</p>
<ul>
<li>빈 <code>div</code>를 만들고 이 <code>div</code>를 <code>IntersectionObserver</code>의 <code>targe</code>t으로 지정해야한다.</li>
<li>그래서 <code>useRef</code>를 이용해 위의 빈 div의 ref에 바인딩 해주었다.</li>
<li>그리고 빈 div가 화면에 보이면 <code>fetchNextPage</code>를 실행한다.
<blockquote>
<p>주의사항 : IntersectionObserver는 Web API이기 때문에 SSR에서는 사용할 수 없다. 그러므로 useEffect를 이용해 빈 div가 화면에 보일때만 IntersectionObserver를 실행하도록 해야한다.</p>
</blockquote>
</li>
</ul>
<pre><code class="language-tsx">const ref = useRef&#x3C;HTMLDivElement | null>(null);

useEffect(() => {
  if (!ref.current || !hasNextPage) return;

  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      fetchNextPage();
    }
  });
  observer.observe(ref.current);

  return () => {
    observer.disconnect();
  };
}, [hasNextPage]);

return (
  &#x3C;section className='flex flex-col gap-4 items-center px-4 pt-4'>
    {renderData &#x26;&#x26;
      renderData.map((post: Post, index: number) => (
        &#x3C;PostCard key={index} {...post} />
      ))}
    {isFetching &#x26;&#x26; &#x3C;div>loading...&#x3C;/div>}

    &#x3C;div ref={ref}>&#x3C;/div>
  &#x3C;/section>
);
</code></pre>
<p>위의 같이 코드를 작성하고 실행해보면 무한스크롤이 작동을 하지 않는다.</p>
<p>그 이유는 <code>useInfiniteQuery</code>가 반환하는 data의 구조 때문이다.</p>
<p>위의 이미지는 useInfiniteQuery가 반환하는 data의 구조이다.
중첩된 구조로 되어있기 때문에 map을 두번 사용해야 렌더링이 가능한 형태이다.</p>
<p>그래서 이를 한번에 렌더링할 수 있도록 데이터를 가공해주는 코드를 추가해주었다.</p>
<pre><code class="language-tsx">const renderData = data?.pages.map(({ data }) => data).flat();
</code></pre>
<h2>결과</h2>
<p>10개마다 추가로 불러오도록 설정했는데 잘 작동하는 것을 확인할 수 있다.</p>
<h2>최종 코드</h2>
<pre><code class="language-tsx">'use client';

import PostCard from '@/stories/PostCard';
import { Post } from '@/type/common';
import { useInfiniteQuery } from '@tanstack/react-query';
import { useEffect, useRef } from 'react';

const fetchPostList = async (page: number, limit: number) => {
  const data = await fetch(`/api/post?page=${page}&#x26;limit=${limit}`, {
    method: 'GET',
  });
  return data.json();
};

export default function PostList() {
  const ref = useRef&#x3C;HTMLDivElement | null>(null);
  const limit = 10;
  const { data, isFetching, fetchNextPage, hasNextPage } = useInfiniteQuery({
    queryKey: ['post'],
    queryFn: ({ pageParam = 1 }) => fetchPostList(pageParam, limit),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.nextPage;
    },
  });

  const renderData = data?.pages.map(({ data }) => data).flat();

  useEffect(() => {
    if (!ref.current || !hasNextPage) return;

    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        fetchNextPage();
      }
    });
    observer.observe(ref.current);

    return () => {
      observer.disconnect();
    };
  }, [hasNextPage]);

  return (
    &#x3C;section className='flex flex-col gap-4 items-center px-4 pt-4'>
      {renderData &#x26;&#x26;
        renderData.map((post: Post, index: number) => (
          &#x3C;PostCard key={index} {...post} />
        ))}
      {isFetching &#x26;&#x26; &#x3C;div>loading...&#x3C;/div>}
      &#x3C;div ref={ref}>&#x3C;/div>
    &#x3C;/section>
  );
}
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="app"/>
        <category label="storybook"/>
        <category label="error"/>
        <category label="tsconfig"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Error] Storybook, Cannot find module]]></title>
        <id>156-next13-storybook-error</id>
        <link href="https://nostrss.me/blog/156-next13-storybook-error"/>
        <updated>2023-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[스토리북에서 Cannot find module 에러가 발생했을 때 해결 방법]]></summary>
        <content type="html"><![CDATA[<p>외부에서 <code>상수</code>나 <code>컴포넌트</code>를 import 해왔을때 갑자기 <code>스토리북</code>에서 아래와 같은 에러가 발생했다.</p>
<p><code>Next</code>의 <code>Alias</code> 설정과 <code>스토리북</code>의 <code>웹팩</code> 경로 설정상의 문제로 보인다.</p>
<pre><code class="language-json">// tsconfig.json
"paths": {
      "@/*": ["./src/*"]
    },
</code></pre>
<h2>해결</h2>
<p>검색을 해보니 관련한 이슈가 생각보다 많아 보였다.</p>
<p>그중에서 내가 지금 쓰고 있는 7버전의 스토리북과 관련된 이슈를 발견했다.
<a href="https://github.com/storybookjs/storybook/issues/21901">🔗 스토리북 깃허브 이슈 바로가기 🔗</a></p>
<p>next.js 최초 프로젝트 생성 시 <code>tsconfig</code>에 <code>baseurl</code>이 생성되지 않아서 밣생하는 것이 문제였던 것 같다.
아래와 같이 <code>baseurl</code>을 <code>tsconfig</code>에 추가해주니 해결되었다.</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    // 추가
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="app"/>
        <category label="storybook"/>
        <category label="error"/>
        <category label="tsconfig"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nextjs 13에서 스토리북 사용하기(with tailwindcss)]]></title>
        <id>155-next13-storybook</id>
        <link href="https://nostrss.me/blog/155-next13-storybook"/>
        <updated>2023-09-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[스토리북으로 UI 단위 컴포넌트를 문서화해보자]]></summary>
        <content type="html"><![CDATA[<p>이번에 <code>nextjs 13</code>으로 개인 블로그를 만드려는데 때마침 <code>스토리북</code>이 생각나서 사용해보려고 했다.</p>
<h2>스토리북(Storybook)이란?</h2>
<p>내가 <code>스토리북</code>을 적용해보려고 한 건 아래와 같은 이유에서 였다.</p>
<blockquote>
<ul>
<li>UI 컴포넌트를 독립적인 환경에서 개발 및 확인 할 수 있다.</li>
<li>UI 컴포넌트를 쉽게 테스트 할 수 있다.</li>
<li>자연스럽게 컴포넌트를 독립적으로 쪼개서 개발하게 된다.</li>
<li>UI 컴포넌트를 쉽게 문서화 할 수 있다.</li>
<li>문서를 기획자,디자이너에게 쉽게 공유할 수 있다.</li>
</ul>
</blockquote>
<p>특히 예전에 기획을 할때 현재 운영중인 서비스의 UI를 한눈에 볼 수 있는 문서가 있으면 참 좋겠다는 생각을 했었다.</p>
<p>기획문서를 보면 되지만, 문서들이 관리가 되지 않는 경우가 많아 이를 파악하는데 시간이 많이 소요되는 경우가 많았다.</p>
<p>그리고 이제는 개발을 하다보니 컴포넌트의 단위에 대해 많은 고민을 하게 되었다.</p>
<p>그래서 <code>스토리북</code>을 사용해보려고 한다.</p>
<h2>스토리북 설치</h2>
<p>설치를 하기 전에 공식 문서를 살펴봤다. 그런데 스토리북에서 next에 대해 <code>zero-config support</code>를 제공한다고 한다는 문서를 보았다.</p>
<blockquote>
<p><a href="https://storybook.js.org/blog/integrate-nextjs-and-storybook-automatically/">🔗 Integrate Next.js and Storybook automatically 바로가기 🔗</a></p>
</blockquote>
<p>위의 문서를 참고로 하여 설치를 진행했다.</p>
<p>먼저 <code>app router</code>와 <code>tailwind</code>를 사용하는 next 프로젝트를 하나 생성해줬다.</p>
<p>그리고 아래 명령어로 스토리북을 설치해줬다.</p>
<pre><code class="language-bash">npx storybook@next init
</code></pre>
<p>설치가 완료되자 마자 스토리북이 실행되면서 아래와 같은 화면을 볼 수 있었다.</p>
<h2>스토리북 살펴보기</h2>
<p>설치 후 vscode로 프로젝트를 살펴봤다.</p>
<ul>
<li><code>.storybook</code> 이라는 폴더가 생기고, 그 안에 <code>main.js</code>와 <code>preview.js</code>가 생성되었다.</li>
<li><code>package.json</code>을 살펴보니 스크립트 명령어가 2개 생겼다.</li>
</ul>
<pre><code class="language-json">"storybook": "storybook dev -p 6006",
"build-storybook": "storybook build"
</code></pre>
<ul>
<li><code>src/stories</code> 라는 폴더가 생기고 그안에 각 컴포넌트에 대한 스토리 파일이 생성되어 있었다.</li>
</ul>
<h3>스토리북 실행, 빌드하기</h3>
<pre><code class="language-bash">yarn storybook
// or npm run storybook
</code></pre>
<p>next 프로젝트를 실행할 때 처럼 스토리북도 위의 명령어로 실행을 해줘야 작성된 스토리북 페이지를 볼 수 있다. 기본 포트는 <code>6006</code>으로 되어 있다.</p>
<pre><code class="language-bash">yarn build-storybook
// or npm run build-storybook
</code></pre>
<p>위의 빌드 명령어를 실행하면 `storybook-static`` 이라는 폴더가 생기면서 정적 파일이 생기는 것을 볼 수 있었다.</p>
<h2>tailwindcss 적용하기</h2>
<p>테스트로 아래와 같이 간단한 Textbox 컴포넌트를 생성해보았다.</p>
<pre><code class="language-tsx">export default function Textbox() {
  return (
    &#x3C;div className='w-full border border-red-700 '>
      &#x3C;p className='text-lg font-bold'>Textbox 입니다.&#x3C;/p>
    &#x3C;/div>
  );
}
</code></pre>
<p>그런데 문제가 있었다. <code>tailwindcss</code>가 적용되지 않는 것 같았다.</p>
<h3>tailwindcss.config.js 파일 수정</h3>
<p><code>tailwind</code>가 적용될 경로에 <code>stories</code> 폴더가 없었다. 그래서 아래와 같이 수정해주었다.</p>
<pre><code class="language-ts">import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    // 수정 전
    // './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    // './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    // './src/app/**/*.{js,ts,jsx,tsx,mdx}',

    // 수정 후
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
};
export default config;
</code></pre>
<h3>preview.ts 파일 수정</h3>
<p>그리고 <code>preview.ts</code> 파일에 <code>global css</code>를 <code>import</code> 해주었다.</p>
<pre><code class="language-ts">import type { Preview } from '@storybook/react';

// css 파일을 import 해준다.
import '../src/app/globals.css';

const preview: Preview = {
  parameters: {
    actions: { argTypesRegex: '^on[A-Z].*' },
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/,
      },
    },
  },
};

export default preview;
</code></pre>
<p>수정 후 아래와 같이 잘 적용된 것을 볼 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="app"/>
        <category label="storybook"/>
        <category label="tailwindcss"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 13 프로젝트 yarn berry로 전환하기]]></title>
        <id>154-next-yarnberry</id>
        <link href="https://nostrss.me/blog/154-next-yarnberry"/>
        <updated>2023-09-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Next 프로젝트 인스톨 없이 클론받아 바로 써보기]]></summary>
        <content type="html"><![CDATA[<h2>설치 환경 버전 정보</h2>
<blockquote>
<p>node : 18.13.0</p>
</blockquote>
<blockquote>
<p>yarn : 3.6.3</p>
</blockquote>
<blockquote>
<p>next : 13.4.19</p>
</blockquote>
<h2>next.js 프로젝트 생성</h2>
<p>먼저 <code>next.js</code> 프로젝트를 생성하자.</p>
<p>일반적으로 가장 많이 설치하는 <code>npx create-next-app</code>을 사용하여 설치했다.</p>
<pre><code class="language-bash">npx create-next-app@latest yarnberry-next13
</code></pre>
<h2>node_modules 삭제</h2>
<p>설치가 완료되면 next.js 프로젝트를 <code>vscode</code>로 열어보자.</p>
<p><code>yarnberry</code>를 사용하면 앞으로 <code>node_modules</code>를 사용하지 않게 되기 때문에, 기존에 설치된 <code>node_modules</code>를 삭제해줬다.</p>
<h2>yarnberry 버전으로 전환</h2>
<p>이제 <code>yarn berry</code> 버전으로 전환해보자. 아래의 명령어를 실행해줬다.</p>
<pre><code class="language-bash">yarn set version berry
</code></pre>
<p>위 커맨드를 실행하면 아래와 같이 실행되면서 <code>yarnberry</code> 버전으로 전환된다.</p>
<p>조금은 생소한 실행화면과 함께 아래와 같이 진행된다.</p>
<h2>yarnberry 모드에서 패키지 재설치</h2>
<p>자 이제 삭제한 패키지를 <code>yarnberry</code> 모드에서 재설치 해보자. 설치 명령어는 기존과 동일하다.</p>
<pre><code class="language-bash">yarn install
</code></pre>
<p>설치가 완료되어 <code>vscode</code>를 다시 확인해봤다.</p>
<p>이제는 패키지를 설치하여도 <code>node_modules</code>가 생성되지 않는 것을 확인할 수 있었다.</p>
<p>그리고 생성된 <code>.yarn/cache</code> 폴더를 살펴봤다.</p>
<p>패키지들이 압축파일로 저장되어 있는 것을 확인할 수 있었다.</p>
<p>기존에는 <code>node_modules</code> 폴더 용량이 커서 <code>github</code>에 푸쉬하지 않는것이 일반적이었다.</p>
<p>그렇기 때문에 공동작업자가 있을 경우, 소스코드를 받아서 실행하기 위해서는 패키지를 npm에서 재설치 해야했다.</p>
<p>그리고 만약 이 과정에서 npm 패키지에서 사라진 것이 있다면, 소스코드를 실행할 수 없는 상황이 발생할 수도 있었다.</p>
<p><em><strong>하지만 <code>yarnberry</code> 모드에서 패키지들은 압축되어 용량이 작기 때문에, github에 설치된 패키지들을 함께 푸쉬한다고 한다. 이로서 공동작업자는 소스코드를 받아서 바로 실행할 수 있는 것이다.</strong></em></p>
<h2>gitignore에 코드 추가</h2>
<p><code>yarnberry</code> 모드에 맞게 <code>gitignore</code>에 코드를 추가해줬다.</p>
<pre><code># yarn berry

.yarn/\*
!.yarn/cache
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
</code></pre>
<h2>typescript 설정</h2>
<blockquote>
<p>이 부분은 링크의 도움을 받아 진행했다.</p>
</blockquote>
<blockquote>
<p><a href="https://blog.dramancompany.com/2023/02/%EB%A6%AC%EB%A9%A4%EB%B2%84-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A2%8C%EC%B6%A9%EC%9A%B0%EB%8F%8C-yarn-berry-%EB%8F%84%EC%9E%85%EA%B8%B0/">🔗 리멤버 웹 서비스 좌충우돌 Yarn Berry 도입기 바로가기 🔗</a></p>
</blockquote>
<p>현재 상태에서 작성되어 있는 코드를 보면 <code>typescript</code> 에러가 발생하고 있었다.</p>
<p>기존에 node_modules에서 모듈을 가져오던 방식이 아닌, yarnberry에서 모듈을 가져오는 방식으로 변경되었기 때문에 발생하는 에러이다.</p>
<pre><code class="language-bash">yarn dlx @yarnpkg/sdks vscode
</code></pre>
<p>위의 커맨드를 실행하면 아래와 같이 vscode 오른쪽 하단에 얼럿이 뜬다.</p>
<p>여기서 허용을 해줘도 되고 아래처럼 별도로 <code>타입스크립트 버전</code>을 설정해줘도 된다.</p>
<blockquote>
<p>타입스크립트 버전 검색</p>
</blockquote>
<blockquote>
<p>타입스크립트 버전 선택</p>
</blockquote>
<h2>테스트</h2>
<h3>개발모드 테스트 (yarn dev) : 성공</h3>
<h3>빌드 테스트 (yarn build) : 성공</h3>
<h3>공동 작업자 시점에서 테스트</h3>
<p>먼저 생성한 프로젝트를 github에 푸쉬해 두었다.</p>
<blockquote>
<p><a href="https://github.com/nostrss/yarnberry-next13">🔗 yarnberry-next13 레파지토리 바로가기 🔗</a></p>
</blockquote>
<p>이제 공동작업자 입장에서 소스코드를 받아서 실행해보자.</p>
<p>위 레파지토리를 <code>git clone</code> 받고, <code>yarn dev</code>를 실행해봤다.</p>
<p>터미널에서 정상적으로 실행이 되고 local:3000에서도 정상적으로 실행이 되는 것을 확인할 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="yarnberry"/>
        <category label="migration"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Nest] DTO, 그게 뭐야? 왜쓰는데? 어떻게 쓰는데?]]></title>
        <id>153-nestjs-dto</id>
        <link href="https://nostrss.me/blog/153-nestjs-dto"/>
        <updated>2023-09-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이름도 생소한 DTO, 그것이 알고 싶다.]]></summary>
        <content type="html"><![CDATA[<h2>DTO(Data Transfer Object)란?</h2>
<p>nest.js를 공부하면서 생소한 용어들이 있었는데, 그중 하나가 바로 DTO(Data Transfer Object)였다.</p>
<blockquote>
<p>데이터 전송 객체(data transfer object, DTO)는 프로세스 간에 데이터를 전달하는 객체이다. 프로세스 간 통신이 일반적으로 원격 인터페이스(예: 웹 서비스)로 재정렬하면서 이루어지게 되는데 여기에서 각 호출의 비용이 많다는 점을 동기로 하여 이용하게 된다. 각 호출의 비용이 큰 것이 클라이언트와 서버 간 왕복 시간과 관련되기 때문에 호출의 수를 줄이기 위해 여러 호출에 의해 전송되는 데이터를 축적하면서 오직 하나의 호출만으로 서비스되는 객체인 DTO를 사용하는 것이다.</p>
</blockquote>
<blockquote>
<p><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%A0%84%EC%86%A1_%EA%B0%9D%EC%B2%B4">🔗 위키피디아 바로가기 🔗</a></p>
</blockquote>
<p>즉, 클라이언트, 서버, 데이터베이스 간에 통신하기 전에 <code>유효성</code> 검사를 하고, <code>데이터</code>를 변환하는 역할을 하는 것 같다.</p>
<p>프론트 개발자 입장에서 이해를 해보면 <code>interface</code>로 <code>타입</code>만 지정해주는 것이 아니라, 요청을 보내거나 받을 때 <code>interface</code>로 지정된 타입으로 <code>형변환</code>까지 해주는 역할을 한다고 생각하면 될 것 같다.</p>
<h2>DTO를 사용하는 이유</h2>
<blockquote>
<p><a href="https://dev.to/bivor/why-dtos-are-a-must-have-in-nestjs-api-development-3j2j">🔗 관련글 바로가기 🔗</a></p>
</blockquote>
<p>위 링크의 글을 읽어보니 DTO를 사용하는 이유는 아래와 같다.</p>
<blockquote>
<ul>
<li>DTO는 클라이언트와 서버 간의 문제를 명확하게 분리할 수 있다.</li>
<li>API의 복잡성을 줄이고 유지 관리를 더 쉽게 만드는 데 도움이 될 수 있다.</li>
</ul>
</blockquote>
<p>리액트에서 타입스크립트를 사용하는 것과 비슷한 이유라고 생각하면 될 것 같다.</p>
<p>좀 더 안정적이고, 통신간에 타입으로 인한 오류를 사전에 방지할 수 있는 장점이 있기 때문에 사용하는 것으로 보인다.</p>
<h2>DTO 예시</h2>
<pre><code class="language-ts">import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsNumber } from 'class-validator';

export class CreateBoardDto {
  @IsNumber()
  @IsNotEmpty()
  @ApiProperty({
    description: '작성자 아이디',
    required: true,
    example: '1',
  })
  userId: number;

  @IsNotEmpty()
  @ApiProperty({
    description: '내용',
    required: true,
    example: '안녕하세요',
  })
  content: string;
}
</code></pre>
<p>위의 코드에서 <code>CreateBoardDto</code>는 <code>userId</code>와 <code>content</code>라는 두개의 속성을 가지고 있는데, 위 코드를 React 코드로 표현하면 아래와 비슷할 것 같다.</p>
<pre><code class="language-ts">interface ICreateBoardDto {
  userId: number;
  content: string;
}

export default function CreateBoardDto(dto: ICreateBoardDto) {
  return {
    userId: Number(dto.userId),
    content: String(dto.content),
  };
}
</code></pre>
<p>그리고 Service 코드에서는 위에 지정한 DTO의 형식으로 데이터를 가져 올수 있게 된다.</p>
<pre><code class="language-ts">async create(data: CreateBoardDto) {
    return this.boardRepository.save(data);
  }
</code></pre>
<h2>class-validator와 class-transformer</h2>
<p>위의 역할을 하기 위해서는 추가적인 npm 패키지가 필요하다.</p>
<p>찾아보니 아래 2개의 패키지를 많이 사용하는 것 같다.</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/class-validator">🔗 npm class-validator 바로가기 🔗</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.npmjs.com/package/class-transformer">🔗 npm class-transformer 바로가기 🔗</a></p>
</blockquote>
<p><code>class-validator</code>는 <code>DTO</code>의 유효성 검사를 해주고, <code>class-transformer</code>는 <code>DTO</code>의 형변환을 해주는 역할을 한다.</p>
<p>위의 패키지를 설치하고, <code>main.ts</code>에 아래와 같이 ValidationPipe를 설정해주면 DTO에서 지정한 유효성 검사와 형변환을 자동으로 해준다.</p>
<pre><code class="language-ts">import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const port = 3000;
  const app = await NestFactory.create(AppModule);

  // ValidationPipe 전역 적용
  app.useGlobalPipes(
    new ValidationPipe({
      // class-transformer 적용
      transform: true,
    })
  );

  await app.listen(port);
  console.info(`listening on port ${port}`);
}
bootstrap();
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="dto"/>
        <category label="validator"/>
        <category label="transformer"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] Middleware와 Edge Functions]]></title>
        <id>152-nextjs-middleware-edge</id>
        <link href="https://nostrss.me/blog/152-nextjs-middleware-edge"/>
        <updated>2023-08-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[새로운 걸 사용하기 전에는 사전학습을 충분히 하자. Next.js Middleware를 사용하면서 발생한 문제점과 해결방법]]></summary>
        <content type="html"><![CDATA[<p>얼마 전 팀프로젝트에 <code>Next.js</code>의 <code>Middleware</code> 파일을 사용하여 github 로그인 관련 기능을 구현하려고 했었다.</p>
<blockquote>
<p><a href="https://nextjs.org/docs/pages/building-your-application/routing/middleware">🔗 Next.js Middleware 공식문서 🔗</a></p>
</blockquote>
<p>기능 설명</p>
<ul>
<li>로그인 버튼 클릭</li>
<li>깃헙에서 리다이렉트 url로 페이지를 다시 보내준다.</li>
<li>리다이렉트 url 쿼리스트링 중에서 code값을 받아온다.</li>
<li>받아온 code값을 이용하여 api 통신을 하여 토큰 값을 받아온다.</li>
<li>토큰 값으로 쿠키를 생성한다.</li>
</ul>
<h2>구현코드</h2>
<p><code>root</code> 위치에 <code>middleware.ts</code> 파일을 생성하고 아래와 같이 작성해주었다.</p>
<pre><code class="language-tsx">// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import {
  BLOGRASS_API_BASE_URL,
  BLOGRASS_AUTH_GET_TOKEN,
} from './constants/api';
import { ACCESS_TOKEN, REFRESH_TOKEN } from './constants/common';

// This function can be marked `async` if using `await` inside
export async function middleware(request: NextRequest) {
  const url = new URL(request.url);
  const code = new URLSearchParams(url.search).get('code') || '';
  let accessToken = request.cookies.get(ACCESS_TOKEN)?.value;
  let refreshToken = request.cookies.get(REFRESH_TOKEN)?.value;

  const getAuthToken = async () => {
    const data = await fetch(
      `${BLOGRASS_API_BASE_URL}${BLOGRASS_AUTH_GET_TOKEN}${code}`
    );
    const jsonData = await data.json();
    return jsonData.result[0];
  };

  if (code &#x26;&#x26; !accessToken &#x26;&#x26; !refreshToken) {
    const data = await getAuthToken();
    accessToken = data.accessToken;
    refreshToken = data.refreshToken;
    const response = NextResponse.next();
    if (accessToken &#x26;&#x26; refreshToken) {
      response.cookies.set(ACCESS_TOKEN, accessToken);
      response.cookies.set(REFRESH_TOKEN, refreshToken);
    }
    return response;
  }
}

export const config = {
  matcher: '/',
};
</code></pre>
<h2>문제 발생</h2>
<p>개발모드에서는 상관없었는데, 배포 후에 문제가 발생했다.</p>
<p><code>vercel</code>을 프론트 서버로 사용하고 있는데, 배포 후에 <code>edge runtime</code> 에러가 발생해서 롤백을 한 적이 있다.</p>
<p>그래서 <code>edge runtime</code>에 대해서 알아보았다.</p>
<h2>Edge runtime이란?</h2>
<p><code>Next</code>에서 런타임은 2가지가 존재한다.</p>
<ul>
<li><code>Node.js Runtime</code>(우리가 일반적으로 사용하는 런타임)</li>
<li><code>Edge Runtime</code></li>
</ul>
<p>Next.js에서 <code>Edge</code> 런타임은 경량화된 <code>Node.js</code> <code>API</code>의 <em>하위 집합</em>이라 <code>Node.js</code> <code>API</code>의 일부 기능만 사용할 수 있다.</p>
<p>사용가능한 <code>API</code>는 아래 링크에서 확인할 수 있다.</p>
<blockquote>
<p><a href="https://nextjs.org/docs/pages/api-reference/edge">🔗 edgeruntime api 바로가기 🔗</a></p>
</blockquote>
<p>링크에서 보듯 사용할 수 있는 API가 한정되어 있으며 <em>npm 패키지를 사용할 수 없다</em>.</p>
<blockquote>
<p>그래서 <code>edge runtime</code>에서는 <code>axios</code>를 사용할 수 없었다.</p>
</blockquote>
<p>또한 vercel에서도 사용할 때 여러가지 제약이 있다.</p>
<blockquote>
<p><a href="https://vercel.com/docs/functions/edge-functions/limitations">🔗 vercel edge function 제한 바로가기 🔗</a></p>
</blockquote>
<p>그래서 개발모드에서는 작동을 했으나 vercel에 배포 후에는 에러가 발생한 것으로 추측이 된다.</p>
<h2>결론</h2>
<blockquote>
<ul>
<li>next.js middleware는 edge runtime에서 작동한다.</li>
<li>edge runtime은 경량화된 node.js API의 하위 집합이다.</li>
<li>edge runtime에서는 npm 패키지를 사용할 수 없다.</li>
<li>그리고 vercel에서도 사용할 때 여러가지 제약이 있다.</li>
<li>middleware에서는 간단한 로직만 사용하는 것이 좋을 것 같다.</li>
</ul>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="edge"/>
        <category label="vercel"/>
        <category label="runtime"/>
        <category label="middleware"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Nest] ERROR [ExceptionsHandler] No metadata]]></title>
        <id>151-error-nest-no-metadata</id>
        <link href="https://nostrss.me/blog/151-error-nest-no-metadata"/>
        <updated>2023-08-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[해결이 됐는데도 이유를 모르는 이 찝찝함이란..]]></summary>
        <content type="html"><![CDATA[<p><code>Nest.js</code>에서 <code>typeorm</code>을 연결하여 사용하려고 하던 중 아래와 같은 에러가 발생했다.</p>
<pre><code class="language-bash">[Nest] 87109  - 2023. 08. 29. 오후 9:41:15   ERROR [ExceptionsHandler] No metadata for "Board" was found.
EntityMetadataNotFoundError: No metadata for "Board" was found.
    at DataSource.getMetadata (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/data-source/DataSource.ts:444:30)
    at Repository.get metadata [as metadata] (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/repository/Repository.ts:53:40)
    at Repository.find (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/repository/Repository.ts:524:39)
    at BoardService.findAll (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/board/board.service.ts:35:33)
    at BoardController.findAll (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/board/board.controller.ts:24:30)
    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-execution-context.js:38:29
    at InterceptorsConsumer.intercept (/Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/interceptors/interceptors-consumer.js:11:20)
    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-execution-context.js:46:60
    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-proxy.js:9:23
    at Layer.handle [as handle_request] (/Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/express/lib/router/layer.js:95:5)
</code></pre>
<h2>해결을 위한 시도</h2>
<h3>@Entity() 누락</h3>
<ul>
<li><code>entitiy</code> 파일에 <code>@Entity()</code> 데코레이터가 누락여부 확인</li>
<li><code>Module</code>에 해당 <code>Entity</code>가 등록되어있는지 확인</li>
<li><code>typeorm</code> 버전 낮추기(0.3.17 => 0.2.X)
<ul>
<li>버전을 낮추지 않고 수정해보기 위해 변경하지 않았다.</li>
</ul>
</li>
<li>typeorm <code>DataSource</code>의 entities 경로가 잘못되었는지 확인</li>
</ul>
<h3>해결(app.module.ts 수정)</h3>
<pre><code class="language-ts">// app.module.ts
// 변경전

@Module({
  imports: [
    ConfigModule(),
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'admin',
      password: '**********',
      database: 'postgres',
      entities: [__dirname + '/**/*.entity.{.ts,.js}'],
      synchronize: false,
    }),
    BoardModule,
  ],
    controllers: [AppController],
  providers: [AppService],
})

// 변경후
@Module({
  imports: [
    ConfigModule(),
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: process.env.DB_HOST,
      port: parseInt(process.env.DB_PORT),
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      synchronize: false,
      logging: true,
    }),
    BoardModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})

</code></pre>
<p>위와 같이 환경변수를 사용하도록 수정하니 정상적으로 동작하였다.</p>
<h2>해결 됐지만 여전한 궁금증</h2>
<blockquote>
<p>환경변수를 사용하는 것과 하드코딩하는 것의 차이는 무엇일까</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="typeorm"/>
        <category label="express"/>
        <category label="error"/>
        <category label="repository"/>
        <category label="datasource"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] TOAST Editor에서 작성한 글정보 불러오기(useRef)]]></title>
        <id>147-toast-next-2</id>
        <link href="https://nostrss.me/blog/147-toast-next-2"/>
        <updated>2023-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[에디터에 적어놓은 글을 어떻게 불러올까? useState or useRef?]]></summary>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li><a href="https://nostrss.github.io/2023-08-25/146-toast-next-1">1.TOAST Editor에 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/147-toast-next-2">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/148-toast-next-3">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/149-toast-next-4">4.TOAST Editor Viewer 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/150-toast-next-5">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>
</ul>
</blockquote>
<h2>Toast Editor에 작성한 글 내용을 불러오기</h2>
<pre><code>src
 ┣ components
 ┃ ┣ newpost
 ┃ ┃ ┗ PostEditor.tsx // 에디터 컴포넌트
 ┣ pages
 ┃ ┣ newpost
 ┃ ┃ ┗ index.tsx // 에디터의 내용을 api 요청으로 서버에 전송
 ┃ ┗ index.tsx
</code></pre>
<p>에디터에 글을 작성하고, 서버에 저장하기 위해서는 먼저 에디터에 작성된 글 내용을 불러와야 한다.</p>
<pre><code class="language-tsx">// src/pages/newpost/index.tsx
const editorRef = useRef&#x3C;Editor>(null);

const onSubmitNewPost = (e: FormEvent) => {
  e.preventDefault();
  // 마크다운 형식으로 작성한 글 내용을 불러온다.
  const markDownContent = editorRef.current?.getInstance().getMarkdown();
  console.log(markDownContent);
};

return (
  &#x3C;section>
    &#x3C;form onSubmit={onSubmitNewPost}>
      &#x3C;PostEditor editorRef={editorRef} />
    &#x3C;/form>
  &#x3C;/section>
);
</code></pre>
<p><code>useRef</code>를 사용하여 <code>editorRef</code>를 선언하였고, <code>editorRef</code>를 <code>PostEditor</code>에 <code>Props</code>로 전달하게 되면 유저가 작성한 글정보가 <code>editorRef</code>에 담기게 될 것이다.</p>
<blockquote>
<p><code>useState</code>가 아닌 <code>useRef</code>를 사용한 이유는, <code>useState</code>를 사용하면 <code>onChange</code> 이벤트가 발생할 때마다 렌더링이 일어나기 때문에, 글자를 입력하는 동안에도 렌더링이 일어나게 될 것이다. 이를 방지하고자 <code>useRef</code>를 사용하였다.</p>
</blockquote>
<p><code>editorRef</code>에서 작성된 글 내용을 뽑아내기 위해서는 <code>getInstance()</code>를 사용하였다.</p>
<p>여기서 <code>Toast Editor</code>는 2가지 모드를 제공하는데, <code>markdown</code>과 <code>wysiwyg</code>이다.</p>
<ul>
<li><code>markdown</code> : README.md 파일처럼 작성하는 에디터이다. 이런 형식으로 불러오기 위해서는 getMarkdown()을 사용하면된다.</li>
<li><code>wysiwyg</code> : 일반적인 글쓰기 편집기 형식의 에디터이다. 이런 형식으로 불러오기 위해서는 getHtml()을 사용하면 된다.</li>
</ul>
<p>나는 마크다운 형식만 사용할 것이기 때문에 <code>getMarkdown()</code>을 사용하였다.</p>
<p>이제는 <code>Props</code>를 받는 <code>PostEditor</code> 컴포넌트를 수정해야겠다.</p>
<pre><code class="language-tsx">//src/components/newpost/PostEditor.tsx
import { Editor } from '@toast-ui/react-editor';
import '@toast-ui/editor/dist/toastui-editor.css';
import '@toast-ui/editor/dist/i18n/ko-kr';
import { RefObject } from 'react';

export default function PostEditor({
  editorRef,
}: {
  editorRef: RefObject&#x3C;Editor>;
}) {
  return (
    &#x3C;Editor
      ref={editorRef}
      previewStyle='vertical'
      height='800px'
      initialEditType='markdown'
      placeholder='Write Something'
      hideModeSwitch={true}
      language='ko-KR'
    />
  );
}
</code></pre>
<p><code>Props</code>로 전달받은 <code>editorRef</code>를 <code>Editor</code> 컴포넌트의 <code>ref</code>로 전달해주었다.</p>
<p>이제 테스트를 해보자.</p>
<p>콘솔에 정상적으로 글 내용이 출력되는 것을 확인할 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="toast"/>
        <category label="editor"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] TOAST Editor에서 이미지 업로드하기(hooks)]]></title>
        <id>148-toast-next-3</id>
        <link href="https://nostrss.me/blog/148-toast-next-3"/>
        <updated>2023-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[블로그에 이미지가 없으면 섭섭하니깐, Toast에서 제공하는 hooks에 이미지 업로드 함수를 연결해보자.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li><a href="https://nostrss.github.io/2023-08-25/146-toast-next-1">1.TOAST Editor에 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/147-toast-next-2">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/148-toast-next-3">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/149-toast-next-4">4.TOAST Editor Viewer 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/150-toast-next-5">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>
</ul>
</blockquote>
<h2>Toast Editor에서 이미지 업로드 하기</h2>
<p><code>Toast Editor</code>는 이미지 업로드를 위한 UI를 아래와 같이 제공하고 있다.</p>
<p>그리고 이미지를 선택하고 OK 버튼을 누르면 이미지가 아래와 같이 노출되게 된다.</p>
<p>좌측에 노출된 복잡한 코드는 base64로 인코딩된 이미지 코드인데,유저가 이렇게 실사용하기는 어려울 것 같다.</p>
<p>그래서 아래와 같이 수정을 해보려고 한다.</p>
<blockquote>
<ol>
<li>업로드할 이미지를 선택한다.</li>
<li>OK버튼을 누르면 선택한 이미지를 서버에 업로드한다.</li>
<li>업로드가 완료되면, 업로드된 이미지의 주소를 받는다.</li>
<li>업로드 된 이미지의 주소를 에디터에 노출한다.</li>
</ol>
</blockquote>
<p>1번은 이미 구현되어 있다. 2번부터 직접 구현해보도록 하자.</p>
<h2>OK버튼을 누르면 이미지 업로드 함수를 실행하기</h2>
<p>그런데 OK 버튼을 눌렀을 때 내가 작성한 이미지 업로드 함수가 바로 실행되도록 어떻게 해야할까?</p>
<p>이전에 <code>EditorOptions</code>의 문서에서 <code>hooks</code>라는 <code>Props</code>를 본적이 있었다.</p>
<blockquote>
<p><a href="https://nhn.github.io/tui.editor/latest/ToastUIEditorCore">🔗 EditorOptions 문서 바로가기 🔗</a></p>
</blockquote>
<p>설명에 이미지 업로드를 위한 <code>hooks</code>라고 당당히 기재되어 있는 것을 볼 수 있다. 역시 문서는 잘 써놓은 것 같다.</p>
<p><code>hooks</code>를 사용하면 되지 않을까 예상은 되는데 사용하는 방법은 어떻게 될까?</p>
<p>조금 더 알아봐야겠다.</p>
<pre><code class="language-ts">// node_modules/@toast-ui/editor/types/editor.d.ts
export interface EditorOptions {
 (...)
  hooks?: HookMap;
  (...)
}

export type HookMap = {
  addImageBlobHook?: (blob: Blob | File, callback: HookCallback) => void;
};

type HookCallback = (url: string, text?: string) => void;
</code></pre>
<p><code>hooks</code>에 대한 타입을 확인해보니, <code>addImageBlobHook</code>이라는 함수가 있고, 이 함수는 <code>blob</code>과 <code>callback</code>을 인자로 받는다.</p>
<p>그리고 <code>callback</code>은 <code>url</code>과 <code>text</code>를 인자로 받는다.</p>
<p>이제 <code>blob</code>과 <code>callback</code>을 인자로 받는 이미지 업로드 함수를 만들어서 연결 해주면 될 것 같다.</p>
<h3>이미지 업로드 함수</h3>
<pre><code class="language-ts">export const imageAPI = {
  postUploadImage: async (image: File | Blob, callback: HookCallback) => {
    // 이미지 업로드를 위한 formData 생성
    const formData = new FormData();
    formData.append('file', image);

    try {
      // 이미지 업로드 후 이미지 id 받기
      const result = await axios({
        method: 'post',
        url: BLOGRASS_IMAGE_UPLOAD,
        data: formData,
      });

      // 이미지 id를 이용하여 이미지 url 생성
      const imageUrl =
        await `${BLOGRASS_IMAGE_BUCKET_URL}/${result.data.result[0]}`;

      // callback에 이미지 url과 alt_text를 인자로 넣어준다.
      callback(imageUrl, 'alt_text');
    } catch (error) {
      console.error(error);
    }
  },
};
</code></pre>
<blockquote>
<ol>
<li><code>image</code>와 <code>callback</code>을 인자로 받는다.</li>
<li><code>image</code>를 서버에 업로드 한다.</li>
<li>업로드가 완료되면, 업로드된 이미지의 <code>URL</code>을 받는다.</li>
<li><code>callback</code>에 이미지의 <code>URL</code>과 텍스트를 인자로 넣어준다.</li>
</ol>
</blockquote>
<h3>hooks에 이미지 업로드 함수 연결하기</h3>
<p>아래와 같이 <code>hooks</code>에 이미지 업로드 함수를 연결해주면 된다.</p>
<pre><code class="language-tsx">export default function PostEditor({
  editorRef,
}: {
  editorRef: RefObject&#x3C;Editor>;
}) {
  return (
    &#x3C;Editor
      ref={editorRef}
      previewStyle='vertical'
      height='800px'
      initialEditType='markdown'
      placeholder='Write Something'
      hideModeSwitch={true}
      language='ko-KR'
      hooks={{ addImageBlobHook: imageAPI.postUploadImage }}
    />
  );
}
</code></pre>
<blockquote>
<p>테스트를 해보니 아래와 같이 이미지가 업로드 되는 것을 확인 할 수 있었다.</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="toast"/>
        <category label="editor"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] TOAST Editor 사용하기]]></title>
        <id>146-toast-next-1</id>
        <link href="https://nostrss.me/blog/146-toast-next-1"/>
        <updated>2023-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[국산을 애용하자. 한국 에디더 Toast Editor를 사용해보자.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li><a href="https://nostrss.github.io/2023-08-25/146-toast-next-1">1.TOAST Editor에 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/147-toast-next-2">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/148-toast-next-3">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/149-toast-next-4">4.TOAST Editor Viewer 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/150-toast-next-5">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>
</ul>
</blockquote>
<h2>버전 정리</h2>
<ul>
<li><code>Next.js</code> : 13.4.10
<ul>
<li><code>pages Router</code>를 사용하였다.</li>
</ul>
</li>
<li><code>@toast-ui/editor</code> - 3.2.2</li>
<li><code>@toast-ui/react-editor</code> - 3.2.3</li>
</ul>
<h2>대략적인 폴더 구조</h2>
<pre><code>src
 ┣ components
 ┃ ┣ newpost
 ┃ ┃ ┗ PostEditor.tsx
 ┣ pages
 ┃ ┣ newpost
 ┃ ┃ ┗ index.tsx
 ┃ ┗ index.tsx
</code></pre>
<h2>사용법 익히기</h2>
<blockquote>
<p><a href="https://ui.toast.com/tui-editor">🔗 Toast Editor 소개 바로가기 🔗</a></p>
</blockquote>
<p><code>Toast Editor</code>는 <code>NHN</code>이 만든 오픈소스 에디터이다.</p>
<p>그래서 한국에서 많이 사용하고, 검색 시에도 한국어 결과가 많이 나오는 편이었다.</p>
<p>나는 Next.js를 사용하고 있기 때문에 React 버전의 사용법을 찾아보았다.</p>
<blockquote>
<p><a href="https://github.com/nhn/tui.editor/tree/master/apps/react-editor#-usage">🔗 @toast-ui/react-editor 깃허브 바로가기 🔗</a></p>
</blockquote>
<p>위의 링크에서 소개한 사용법은 아래와 같았다.</p>
<pre><code class="language-tsx">import '@toast-ui/editor/dist/toastui-editor.css';

import { Editor } from '@toast-ui/react-editor';

const MyComponent = () => (
  &#x3C;Editor
    initialValue='hello react editor world!'
    previewStyle='vertical'
    height='600px'
    initialEditType='markdown'
    useCommandShortcut={true}
  />
);
</code></pre>
<p>위와 같이 <code>Editor</code>를 <code>import</code>하고 컴포넌트에 필요한 props를 전달해 주면 된다.</p>
<p>그렇다면 <code>Editor</code>컴포넌트는 어떤 <code>props</code>를 가지고 있을까?</p>
<h2>Editor 컴포넌트 살펴보기</h2>
<pre><code class="language-ts">// node_modules/@toast-ui/react-editor/index.d.ts
export class Editor extends Component&#x3C;EditorProps> {
  getInstance(): ToastuiEditor;

  getRootElement(): HTMLElement;
}
</code></pre>
<p><code>Editor</code> 컴포넌트는 <code>Component&#x3C;EditorProps></code>타입을 상속받고 <code>getInstance</code>와 <code>getRootElement</code>라는 메서드를 가지고 있었다.</p>
<p><code>props</code>를 알아보기 위해서 이번엔 상속받은 <code>EditorProps</code>를 살펴보았다.</p>
<pre><code class="language-ts">// node_modules/@toast-ui/react-editor/index.d.ts
export type EditorProps = Omit&#x3C;EditorOptions, 'el'> &#x26; Partial&#x3C;EventMapping>;
</code></pre>
<ol>
<li>
<p><code>Omit&#x3C;EditorOptions, 'el'></code>는 <code>EditorOptions</code>에서 <code>el</code>을 제외한 나머지 속성들을 상속받는다는 뜻이다.</p>
</li>
<li>
<p><code>Partial&#x3C;EventMapping></code>는 <code>EventMapping</code>의 속성들을 선택적으로 상속받는다는 뜻이다.</p>
</li>
<li>
<p>그리고 위의 두 타입을 합쳐서 <code>EditorProps</code>를 만들었다.</p>
</li>
</ol>
<p>이중에 <code>EditorOptions</code>를 먼저 살펴보았다.</p>
<h3>EditorOptions</h3>
<pre><code class="language-ts">// node_modules/@toast-ui/editor/types/editor.d.ts
export interface EditorOptions {
  el: HTMLElement; // 이건 제외하고 상속을 받는다.
  height?: string;
  minHeight?: string;
  initialValue?: string;
  previewStyle?: PreviewStyle;
  initialEditType?: EditorType;
  events?: EventMap;
  hooks?: HookMap;
  language?: string;
  useCommandShortcut?: boolean;
  usageStatistics?: boolean;
  toolbarItems?: (string | ToolbarItemOptions)[][];
  hideModeSwitch?: boolean;
  plugins?: EditorPlugin[];
  extendedAutolinks?: ExtendedAutolinks;
  placeholder?: string;
  linkAttributes?: LinkAttributes;
  customHTMLRenderer?: CustomHTMLRenderer;
  customMarkdownRenderer?: ToMdConvertorMap;
  referenceDefinition?: boolean;
  customHTMLSanitizer?: Sanitizer;
  previewHighlight?: boolean;
  frontMatter?: boolean;
  widgetRules?: WidgetRule[];
  theme?: string;
  autofocus?: boolean;
  viewer?: boolean;
}
</code></pre>
<p>엄청나게 많은 옵션들이 있다.</p>
<p>하지만 다행히 문서로 잘 정리가 되어 있어서 각 옵션들이 어떤 역할을 하는지 확인할 수 있었다.</p>
<blockquote>
<p><a href="https://nhn.github.io/tui.editor/latest/ToastUIEditorCore">🔗 EditorOptions 문서 바로가기 🔗</a></p>
</blockquote>
<p>위의 링크를 보면서 나에게 필요한 옵션들이 무엇인지 알 수 있었다.</p>
<h3>EventMapping</h3>
<pre><code class="language-ts">// node_modules/@toast-ui/react-editor/index.d.ts
export interface EventMapping {
  onLoad: EventMap['load'];
  onChange: EventMap['change'];
  onCaretChange: EventMap['caretChange'];
  onFocus: EventMap['focus'];
  onBlur: EventMap['blur'];
  onKeydown: EventMap['keydown'];
  onKeyup: EventMap['keyup'];
  onBeforePreviewRender: EventMap['beforePreviewRender'];
  onBeforeConvertWysiwygToMarkdown: EventMap['beforeConvertWysiwygToMarkdown'];
}

export interface EventMap {
  load?: (param: Editor) => void;
  change?: (editorType: EditorType) => void;
  caretChange?: (editorType: EditorType) => void;
  focus?: (editorType: EditorType) => void;
  blur?: (editorType: EditorType) => void;
  keydown?: (editorType: EditorType, ev: KeyboardEvent) => void;
  keyup?: (editorType: EditorType, ev: KeyboardEvent) => void;
  beforePreviewRender?: (html: string) => string;
  beforeConvertWysiwygToMarkdown?: (markdownText: string) => string;
}
</code></pre>
<p><code>EventMapping</code>이라는 단어 그대로 사용 가능한 이벤트 함수와 이벤트 함수의 파라미터 타입을 정의하고 맵핑한 것 이었다.</p>
<h2>컴포넌트 만들기</h2>
<p>글작성 페이지는 <code>pages/newpost/index.tsx</code> 경로에 만들려고 한다.</p>
<p>하지만 <code>index.tsx</code> 파일이 너무 커질것 같아 <code>components/newpost/PostEditor.tsx</code>파일에 <code>PostEditor</code>라는 컴포넌트를 별도로 만들고, <code>index.tsx</code>에서 import 하여 사용하려고 한다.</p>
<p><code>PostEditor</code> 컴포넌트는 아래와 같이 작성했다.</p>
<pre><code class="language-tsx">// components/newpost/PostEditor.tsx
import { Editor } from '@toast-ui/react-editor';
import '@toast-ui/editor/dist/toastui-editor.css';
import '@toast-ui/editor/dist/i18n/ko-kr';

export default function PostEditor() {
  return (
    &#x3C;Editor
      previewStyle='vertical'
      height='800px'
      initialEditType='markdown'
      placeholder='Write Something'
      hideModeSwitch={true}
      language='ko-KR'
    />
  );
}
</code></pre>
<p>그리고 <code>pages/newpost/index.tsx</code>에 import해서 사용하였다.</p>
<blockquote>
<p>📌 Toast에디터는 ssr을 지원하지 않기 때문에 <code>next/dynamic</code>을 사용하여 ssr을 하지 않도록 설정해주었다. 아마 React로 작업하는 경우에는 사용할 필요가 없을 것 같다.</p>
</blockquote>
<pre><code class="language-tsx">import dynamic from 'next/dynamic';

const PostEditor = dynamic(() => import('@/components/newpost/PostEditor'), {
  ssr: false,
});
</code></pre>
<p>정상적으로 잘 나오는 것을 확인할 수 있었다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="toast"/>
        <category label="editor"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] TOAST Editor customHTMLSanitizer 사용하기]]></title>
        <id>150-toast-next-5</id>
        <link href="https://nostrss.me/blog/150-toast-next-5"/>
        <updated>2023-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[dangeroulySetInnerHTML을 사용하지 않고 dompurify를 Toast Editor에 적용해보자.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li><a href="https://nostrss.github.io/2023-08-25/146-toast-next-1">1.TOAST Editor에 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/147-toast-next-2">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/148-toast-next-3">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/149-toast-next-4">4.TOAST Editor Viewer 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/150-toast-next-5">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>
</ul>
</blockquote>
<h2>TOAST Editor customHTMLSanitizer 사용하기</h2>
<p>에디터의 경우 유저가 악의적인 용도로 스크립트를 삽입하여 공격할 위험이 있다.</p>
<p>이를 방지하기 위해서는 HTML 요소에 공격을 하는 스크립트등을 삭제해야 한다.</p>
<p>이런 기능을 하는 npm 패키지가 있는데, <code>Dompurify</code>이다.</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/dompurify?activeTab=readme">🔗 dompurify npm 페이지 바로가기 🔗</a></p>
</blockquote>
<h2>TOAST Editor 자체적인 Sanitizer</h2>
<p>앞서 EditorOptions을 살펴봤을때 <code>customHTMLSanitizer</code>라는 Props가 존재하는 것을 확인할 수 있었다.</p>
<blockquote>
<p><a href="https://nhn.github.io/tui.editor/latest/ToastUIEditorCore">🔗 EditorOptions 문서 바로가기 🔗</a></p>
</blockquote>
<blockquote>
<p><a href="https://ui.toast.com/weekly-pick/ko_monthly_202004">🔗 customHTMLSanitizer 옵션 기능 추가 🔗</a></p>
</blockquote>
<pre><code class="language-ts">// node_modules/@toast-ui/editor/types/editor.d.ts
export interface EditorOptions {
  (...)
  customHTMLSanitizer?: Sanitizer;
  (...)
}
</code></pre>
<p><code>customHTMLSanitizer</code>라는 표현이 있는 것으로 보아 이런 생각이 들었다.</p>
<blockquote>
<p>혹시 Toast Editor에는 이미 Sanitizer가 적용되어 있는게 아닐까</p>
</blockquote>
<p>테스트를 해봐야겠다.</p>
<p><code>dompurify</code> 페이지에 샘플코드가 있어서 이를 가져와서 테스트를 해봤다.
<code>Markdown</code>, <code>wysiwyg</code> 모드 둘다 테스트를 해봤다.</p>
<pre><code class="language-tsx">const onSubmitNewPost = (e: FormEvent) => {
  e.preventDefault();
  const markDownContent = editorRef.current?.getInstance().getMarkdown();
  const htmlContent = editorRef.current?.getInstance().getHTML();
  console.log('1️⃣', markDownContent);
  console.log('2️⃣', htmlContent);
};
</code></pre>
<p>에디터에 샘플코드를 입력하고 어떻게 값이 반환되는지 확인해보았다.</p>
<pre><code class="language-javascript">DOMPurify.sanitize('&#x3C;img src=x onerror=alert(1)//>');
// dompurify : &#x3C;img src="x">
// Markdown :  &#x3C;img src=x onerror=alert(1)//>
// wysiwyg : &#x3C;p>&#x3C;img src="x" contenteditable="false">&#x3C;br>&#x3C;/p>

DOMPurify.sanitize('&#x3C;svg>&#x3C;g/onload=alert(2)//&#x3C;p>');
// dompurify : &#x3C;svg>&#x3C;g>&#x3C;/g>&#x3C;/svg>
// Markdown : &#x3C;svg>&#x3C;g/onload=alert(2)//&#x3C;p>
// wysiwyg : &#x3C;p>&#x26;lt;g/onload=alert(2)//&#x3C;/p>

DOMPurify.sanitize('&#x3C;p>abc&#x3C;iframe//src=jAva&#x26;Tab;script:alert(3)>def&#x3C;/p>');
// dompurify : &#x3C;p>abc&#x3C;/p>
// Markdown : &#x3C;p>abc&#x3C;iframe//src=jAva&#x26;Tab;script:alert(3)>def&#x3C;/p>
// wysiwyg : &#x3C;p>abc&#x3C;/p>

DOMPurify.sanitize('&#x3C;math>&#x3C;mi//xlink:href="data:x,&#x3C;script>alert(4)&#x3C;/script>">');
// dompurify : &#x3C;math>&#x3C;mi>&#x3C;/mi>&#x3C;/math>
// Markdown : &#x3C;math>&#x3C;mi//xlink:href="data:x,&#x3C;script>alert(4)&#x3C;/script>">
// wysiwyg : &#x3C;p>&#x26;lt;mi//xlink:href="data:x,alert(4)"&#x26;gt;&#x3C;/p>

DOMPurify.sanitize('&#x3C;TABLE>&#x3C;tr>&#x3C;td>HELLO&#x3C;/tr>&#x3C;/TABL>');
// dompurify : &#x3C;table>&#x3C;tbody>&#x3C;tr>&#x3C;td>HELLO&#x3C;/td>&#x3C;/tr>&#x3C;/tbody>&#x3C;/table>
// Markdown : &#x3C;TABLE>&#x3C;tr>&#x3C;td>HELLO&#x3C;/tr>&#x3C;/TABL>
// wysiwyg : &#x3C;table>&#x3C;thead>&#x3C;tr>&#x3C;td>&#x3C;p>HELLO&#x3C;/p>&#x3C;/td>&#x3C;/tr>&#x3C;/thead>&#x3C;tbody>&#x3C;tr>&#x3C;/tr>&#x3C;/tbody>&#x3C;/table>

DOMPurify.sanitize('&#x3C;UL>&#x3C;li>&#x3C;A HREF=//google.com>click&#x3C;/UL>');
// dompurify : &#x3C;ul>&#x3C;li>&#x3C;a href="//google.com">click&#x3C;/a>&#x3C;/li>&#x3C;/ul>
// Markdown : &#x3C;UL>&#x3C;li>&#x3C;A HREF=//google.com>click&#x3C;/UL>
// wysiwyg : &#x3C;ul>&#x3C;li>&#x3C;p>&#x3C;a href="//google.com">click&#x3C;/a>&#x3C;/p>&#x3C;/li>&#x3C;/ul>
</code></pre>
<p><code>dompurify</code>와 방식은 다르지만 <code>wysiwyg</code> 모드에서는 Toast 에디터 자체적으로 <code>Sanitizer</code>가 적용되어 있는 것을 확인할 수 있었다.</p>
<h2>Custom Sanitizer 사용하기</h2>
<p>이제는 customHTMLSanitizer를 사용해보려고 한다.</p>
<pre><code class="language-ts">export type Sanitizer = (content: string) => string;
</code></pre>
<p><code>customHtmlSanitizer</code>는 <code>Sanitizer</code>라는 타입을 가지고 있고, <code>Sanitizer</code>는 <code>content</code>라는 <code>string</code>을 받아서 <code>string</code>을 반환하는 함수이다.</p>
<p>일단 간단히 테스트를 해보기 위해서 아래와 같이 함수를 하나 작성하여 <code>customHTMLSanitizer</code>와 연결해보았다.</p>
<pre><code class="language-tsx">export default function PostEditor({
  editorRef,
}: {
  editorRef: RefObject&#x3C;Editor>;
}) {
  // 테스트용 Sanitizer 함수
  const testSanitizer = (text: string) => {
    console.log(text);
    return text;
  };

  return (
    &#x3C;Editor
      ref={editorRef}
      previewStyle='vertical'
      height='800px'
      initialEditType='markdown'
      placeholder='Write Something'
      hideModeSwitch={true}
      language='ko-KR'
      customHTMLSanitizer={testSanitizer}
    />
  );
}
</code></pre>
<p><code>testSanitizer</code> 함수가 잘 연결되어 작동을 한다면, <code>console.log(text)</code>가 실행되어 콘솔에 <code>text</code>가 출력될 것이다.</p>
<p>텍스트를 입력할때 마다 직접 생성한 <code>testSanitizer</code> 함수를 실행하는 것을 확인할 수 있었다.</p>
<blockquote>
<p>즉, Toast Editor에는 이미 Sanitizer가 적용되어 있다. 그리고 별도의 Sanitizer를 적용하려면 customHTMLSanitizer에 string을 매개변수로 받아서 string을 반환하는 함수를 넣어주면 된다.</p>
</blockquote>
<h2>dompurify 적용하기</h2>
<p>Toast Editor 자체적으로 Sanitizer가 적용되어 있지만, <code>dompurify</code>를 적용해보기로 했다.</p>
<p>일단 글을 작성하는 에디터에 적용을 해주었다. 방법은 간단했다.</p>
<pre><code class="language-tsx">// dompurify Import
import * as DOMPurify from 'dompurify';

export default function PostEditor({
  editorRef,
}: {
  editorRef: RefObject&#x3C;Editor>;
}) {
  const customSanitizer = DOMPurify.sanitize;

  return (
    &#x3C;Editor
      ref={editorRef}
      previewStyle='vertical'
      height='800px'
      initialEditType='markdown'
      placeholder='Write Something'
      hideModeSwitch={true}
      language='ko-KR'
      // customHTMLSanitizer에 dompurify 적용
      customHTMLSanitizer={customSanitizer}
    />
  );
}
</code></pre>
<p>그리고 <code>Viewer</code>에도 동일하게 적용을 해주었다.</p>
<p>작성할때 이미 dompurify가 적용되어 있긴 하지만, <code>Viewer</code>에서도 <code>dompurify</code>를 적용해주는 것이 보안에 좋을 것 같아서 적용해주었다.</p>
<pre><code class="language-tsx">import { Viewer } from '@toast-ui/react-editor';
import * as DOMPurify from 'dompurify';

export default function EditorViewer({
  initialValue,
}: {
  initialValue: string;
}) {
  const customSanitizer = DOMPurify.sanitize;

  return (
    &#x3C;Viewer initialValue={initialValue} customHTMLSanitizer={customSanitizer} />
  );
}
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="toast"/>
        <category label="dompurify"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] TOAST Editor Viewer 사용하기]]></title>
        <id>149-toast-next-4</id>
        <link href="https://nostrss.me/blog/149-toast-next-4"/>
        <updated>2023-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[보여주기만 할 땐 Viewer를 사용하면 된다.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<ul>
<li><a href="https://nostrss.github.io/2023-08-25/146-toast-next-1">1.TOAST Editor에 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/147-toast-next-2">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/148-toast-next-3">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/149-toast-next-4">4.TOAST Editor Viewer 사용하기</a></li>
<li><a href="https://nostrss.github.io/2023-08-25/150-toast-next-5">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>
</ul>
</blockquote>
<h2>TOAST Editor Viewer 사용하기</h2>
<p>예전에 <code>React Quill</code>의 경우에는 <code>Viewer</code>를 따로 제공하지 않고, <code>readOnly</code> 속성을 통해 편집기와 뷰어를 구분하여 사용할 수 있었다.</p>
<p>하지만 <code>TOAST Editor</code>의 경우에는 아예 <code>Viewer</code>를 따로 제공하고 있었다.</p>
<p>문서에서는 찾지 못했는데, 타입에 아래와 같이 정의가 되어 있어서 사용해봤다.</p>
<pre><code class="language-ts">export class Viewer extends Component&#x3C;ViewerProps> {
  getInstance(): ToastuiEditorViewer;

  getRootElement(): HTMLElement;
}
</code></pre>
<p>이제 상세 페이지에 Viewer를 적용해보자.</p>
<pre><code class="language-tsx">import { Viewer } from '@toast-ui/react-editor';

export default function EditorViewer({
  initialValue,
}: {
  initialValue: string;
}) {
  return &#x3C;Viewer initialValue={initialValue} />;
}
</code></pre>
<p>상위 컴포넌트에서 <code>Props</code>로 <code>initialValue</code>에 컨텐츠 정보를 받아오고, 이것을 단순히 <code>Viewer</code>에 전달해주기만 하면 된다.</p>
<p><code>Viewer</code>의 경우에도 <code>import</code>시 아래와 같이 <code>dynamic import</code>를 사용해야한다.</p>
<pre><code class="language-tsx">const EditorViewer = dynamic(() => import('@/components/post/EditorViewer'), {
  ssr: false,
});
</code></pre>
<p>적용한 결과는 아래와 같다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <category label="toast"/>
        <category label="editor"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgresSQL 설치 시 "/tmp/.s.PGSQL.5432" 에러]]></title>
        <id>145-postgre-install-error</id>
        <link href="https://nostrss.me/blog/145-postgre-install-error"/>
        <updated>2023-08-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[설치 에러가 제일 무서운 개발자]]></summary>
        <content type="html"><![CDATA[<p>Nest.js를 공부하면서 Brew로 PostgresSQL을 설치하고 DB를 연결하려고 했는데 아래와 같은 에러가 발생했다.</p>
<pre><code class="language-bash">psql postgres

psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: No such file or directory
</code></pre>
<p>검색을 해보니 다양한 결과들이 나왔다.</p>
<ul>
<li>삭제 후 재설치 하는 방법</li>
<li>재부팅 하는 방법</li>
<li>postgresql@13을 설치하는 방법(나는 14버전을 사용하고 싶었다.)</li>
</ul>
<p>chatgpt도 사용해봤으나 전부 실패했다.</p>
<p>그러다 stackoverflow에서 아래와 같은 답변을 찾았다.</p>
<p><a href="https://stackoverflow.com/questions/69754628/psql-error-connection-to-server-on-socket-tmp-s-pgsql-5432-failed-no-such">stack overflow 원본링크</a></p>
<p>위의 링크 중간에 보면 아래와 같은 답변이 있었다.</p>
<pre><code class="language-bash">brew services start postgresql
</code></pre>
<p>위의 명령어를 실행하고 다시 psql을 실행하니 정상적으로 실행되었다.</p>
<pre><code>psql postgres
</code></pre>
<p>개발은 처음에 설치와 환경설정이 제일 어렵다..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="node"/>
        <category label="express"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Nest.js] - 소개]]></title>
        <id>144-nestjs</id>
        <link href="https://nostrss.me/blog/144-nestjs"/>
        <updated>2023-08-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[올해 안에 Nest.js 서버를 만들어 보자!!]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://docs.nestjs.com/">Nest.js 공식 문서</a>를 참고하였습니다.</p>
</blockquote>
<h2>Nest.js란?</h2>
<ul>
<li>Node.js 서버 측 애플리케이션을 구축하기 위한 프레임 워크</li>
</ul>
<h2>특징</h2>
<ul>
<li><code>Angular</code>와 비슷한 구조이며 이에 영감을 받은 것으로 알려져 있습니다.</li>
<li><code>Typescript</code>를 기본 언어로 사용합니다.</li>
<li><code>Express</code>를 기본값으로 사용하며 <code>Fastify</code>도 사용할 수 있습니다.</li>
<li>객체지향 개념을 도입하였습니다.</li>
</ul>
<h2>장점</h2>
<h3>Angular와 비슷한 구조</h3>
<ul>
<li>모듈/컴포넌트 기반으로 프로그램을 작성함으로써 재사용성을 높여줍니다.
<blockquote>
<p>프론트 엔드를 먼저 시작한 나로서는 모듈기반이라는 말이 잘 와닿지 않았다.</p>
</blockquote>
</li>
</ul>
<h3>Express의 단점을 보완</h3>
<ul>
<li>
<p>expresss는 훌륭한 프레임워크이지만, 과도한 유연함으로 인해 SW의 품질이 일정하지 않고 알맞은 라이브러리를 찾기 위해 사용자가 많은 시간을 할애해야 합니다.</p>
</li>
<li>
<p>하지만 Nest.js는 데이터베이스, ORM, 설정(Configuration), 유효성 검사 등 수많은 기능을 기본 제공하고 있다. 그러면서도 필요한 라이브러리를 쉽게 설치하여 기능을 확장할 수 있는 Node.js 장점은 그대로 가지고 있다고 한다.</p>
</li>
</ul>
<blockquote>
<p>즉, Express는 React, Nest.js는 Next.js, Nuxt.js와 같은 프론트엔드 프레임워크와 비슷한 역할을 한다고 이해하면 될 것 같다.</p>
</blockquote>
<h2>설치 및 설정</h2>
<p>아래 2개의 명령어를 터미널에서 실행하여 설치와 새 프로젝트를 설정 할 수 있다.</p>
<pre><code class="language-bash">npm i -g @nestjs/cli
nest new project-name

</code></pre>
<h3>핵심 파일</h3>
<p>설치를 완료하면 src 폴더에 아래와 같은 파일들이 생성된다.</p>
<p>|                          |                                                                                                                                                             |
| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <code>app.controller.ts</code>      | 클라이언트로 부터 들어오는 요청을 <code>service</code>애 위임하고 처리된 결과를 다시 클라이언트에게 반환하는 일을 담당한다. HTTP 요청 메서드(GET, POST 등)를 정의한다. |
| <code>app.controller.spec.ts</code> | 컨트롤러에 대한 단위 테스트 파일 이다.                                                                                                                      |
| <code>app.module.ts</code>          | 애플리케이션의 루트 모듈. Nest.js에서는 모듈을 사용하여 애플리케이션을 구성한다. 모듈은 기능과 비즈니스 로직을 담당하는 컴포넌트의 집합이라 할 수 있다.     |
| <code>app.service.ts</code>         | <code>controller</code>로부터 위임받은 요청을 실제로 처리하고 반환하는 역할을 한다. 즉,비즈니스 로직을 구현하는 역할이라고 볼 수 있다.                                 |
| <code>main.ts</code>                | Nest.js의 진입점, NestFactory핵심 기능을 사용하여 Nest 애플리케이션 인스턴스를 생성하는 애플리케이션의 항목 파일이다. HTTP 서버를 시작하는 역할을 한다.     |</p>
<h2>실행</h2>
<pre><code class="language-bash">npm run start
npm run start:dev // 개발 모드
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nestjs"/>
        <category label="node"/>
        <category label="express"/>
        <category label="javascript"/>
        <category label="typescript"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[reduce 사용법 정리]]></title>
        <id>142-javascript-reduce</id>
        <link href="https://nostrss.me/blog/142-javascript-reduce"/>
        <updated>2023-07-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[자주 쓰지 않아서 까먹은 reduce 사용법을 정리]]></summary>
        <content type="html"><![CDATA[<p>좀 처럼 프론트엔드 실무를 하면서는 자주 사용할 기회가 없었던 메소드가 바로 reduce였다.</p>
<p>얼마 전 지인의 코드를 수정해주다가 reduce를 사용한 부분이 있어서 정리해봤다.</p>
<h2>등차수열</h2>
<p>갑자기 등차수열이 왜 나오냐고? 라고 생각할 수 있지만, reduce를 사용하면서 등차수열을 공식과 연관지어 생각하니 이해가 쉬워져서 예시를 들었다.</p>
<h3>등차수열 공식</h3>
<pre><code class="language-text">a(n) = a(1) + (n - 1) * d
</code></pre>
<p>등차 수열의 공식은 위와 같다.</p>
<p>수열의 첫 항 a(1)이 있고 공차 d가 있다면, n번째 항은 위와 같이 구할 수 있다.</p>
<p>이것을 reduce와 비교해보자.</p>
<h3>reduce</h3>
<p>리듀스의 구문은 아래와 같다.</p>
<pre><code class="language-js"> arr.reduce(callback[, initialValue])
</code></pre>
<p>callback은 필수값이고, initialValue는 옵션이다.</p>
<p>reduce 메소드는 initialValue 값에 callback 함수를 적용하여 하나의 결과값을 만들어낸다.</p>
<p>즉, 등차수열의 첫항 a(1)이 initialValue이고, 공차 d가 callback 함수라고 생각하면 이해가 쉽다.</p>
<p>mdn에 나와 있는 예시를 통해 살펴보자.</p>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">mdn reduce 예시 </a></p>
<pre><code class="language-js">[0, 1, 2, 3, 4].reduce(function (
  accumulator,
  currentValue,
  currentIndex,
  array
) {
  return accumulator + currentValue;
},
10);
</code></pre>
<p>|  callback  | accumulator | currentValue | currentIndex |      array      | return value |
| :--------: | :---------: | :----------: | :----------: | :-------------: | :----------: |
| 1번째 호출 |     10      |      0       |      0       | [0, 1, 2, 3, 4] |      10      |
| 2번째 호출 |     10      |      1       |      1       | [0, 1, 2, 3, 4] |      11      |
| 3번째 호출 |     11      |      2       |      2       | [0, 1, 2, 3, 4] |      13      |
| 4번째 호출 |     13      |      3       |      3       | [0, 1, 2, 3, 4] |      16      |
| 5번째 호출 |     16      |      4       |      4       | [0, 1, 2, 3, 4] |      20      |</p>
<p>위의 표를 보면 이해가 쉽다.</p>
<p>initialValue가 10이고, callback 함수가 accumulator에 currentValue를 더해주는 형태이다.</p>
<p>즉, 등차수열에서 공차 d가 1이라고 생각하면, initialValue는 a(1)이고, callback 함수는 d가 된다.</p>
<p>물론 reduce가 등차수열로만 적용되는 것은 아니고 다양한 용도로 사용할 수 있지만, 이렇게 이해들 해두고 나머지는 응용을 하면 되겠다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="javascript"/>
        <category label="reduce"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NEXT] page.js (with App Router)]]></title>
        <id>141-next-page-app-router</id>
        <link href="https://nostrss.me/blog/141-next-page-app-router"/>
        <updated>2023-07-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[NEXT.JS에서 page.js에 기본적으로 제공되는 Props를 알아보자.]]></summary>
        <content type="html"><![CDATA[<h2>Props</h2>
<p>NEXT.JS에서는 기본적으로 컴포넌트에 Props로 params와 searchParams를 전달해준다.</p>
<p>상위 컴포넌트에서 아무런 Props를 전달하지 않아도 params와 searchParams를 사용할 수 있다.</p>
<pre><code class="language-js">export default function Page({
  params,
  searchParams,
}: {
  params: { slug: string }
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  return &#x3C;h1>My Page&#x3C;/h1>
}
</code></pre>
<h2>params</h2>
<p><code>params</code>: URL의 path에 있는 동적 경로 파라미터를 담고 있는 객체이다.</p>
<p>예를 들면 아래와 같다.</p>
<p>| Example                            | URL       | params                       |
| :--------------------------------- | :-------- | :--------------------------- |
| app/shop/[slug]/page.js            | /shop/1   | { slug: '1' }                |
| app/shop/[category]/[item]/page.js | /shop/1/2 | { category: '1', item: '2' } |
| app/shop/[...slug]/page.js         | /shop/1/2 | { slug: ['1', '2'] }         |</p>
<p>예전에 나는 useRouter를 사용해서 params를 가져왔었는데, 이제는 이렇게 간단하게 가져올 수 있다.</p>
<h2>searchParams</h2>
<p><code>searchParams</code>: URL의 query string에 있는 파라미터를 담고 있는 객체</p>
<p>| URL           | searchParams       |
| :------------ | :----------------- |
| /shop?a=1     | { a: '1' }         |
| /shop?a=1&#x26;b=2 | { a: '1', b: '2' } |
| /shop?a=1&#x26;a=2 | { a: ['1', '2'] }  |</p>
<h2>useRouter 변경사항</h2>
<p>그리고 이와 관련하여 몇가지 달라진 점이 있다. 특히 내가 많이 사용하던 것들 중에 달라진 사항이 있어 정리해봤다.</p>
<blockquote>
<p>새로운 useRouter는 import시 next/navigation에서 가져와야한다.(기존 next/router)</p>
</blockquote>
<blockquote>
<p>문자열 pathname은 usePathname()으로 대체되었다.</p>
</blockquote>
<blockquote>
<p>문자열 query는 useQuery()로 대체되었다.</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="nextjs"/>
        <category label="react"/>
        <category label="app-router"/>
        <category label="pagejs"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[React server component와 Next.js]]></title>
        <id>143-react-nextjs-server-component</id>
        <link href="https://nostrss.me/blog/143-react-nextjs-server-component"/>
        <updated>2023-07-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Server Component 참 신기한 컴포넌트네요]]></summary>
        <content type="html"><![CDATA[<p>React 18 버전에서 새로 추가된 기능 중 하나가 바로 server component이다.</p>
<p>아직 많이 쓰이는 것 같지는 않지만, Next.js에서도 app router가 정식 버전으로 나오면서 server component를 지원한다고 한다.</p>
<p>그래서 이에 대해 조금 공부해보았다.</p>
<h2>React server component는 왜 나왔을까?</h2>
<h3>번들 사이즈 최적화</h3>
<p>React18 이전의 리액트 컴포넌트는 한마디로 '클라이언트' 컴포넌트였다.</p>
<p>그래서 모든 것이 브라우저에서 실행되었다.(CSR인 경우)</p>
<p>코드를 다운로드 하고, DOM에 렌더링하고, Data를 fetch하고, 이벤트를 처리하는 것까지 모두 브라우저에서 수행되었다.</p>
<p>이는 번들 사이즈가 커지는 원인이 되었다.</p>
<p>하지만 서버에서 렌더링을 할 수 있게 된다면, 브라우저에서 수행할 작업을 줄일 수 있고, 번들 사이즈를 줄일 수 있게 된다.</p>
<p>즉, 그동안 브라우저에서 하던 일을 서버와 브라우저가 나눠서 작업을 할 수 있게 되는 것이다.</p>
<h3>서버 리소스 리소스 접근</h3>
<p>서버는 데이터 베이스, GraphQL, 파일시스템 등 데이터 리소스에 빠르게 접근할 수 있고, 이를 클라이언트 컴포넌트에 Props로 전달할 수 있다.</p>
<h3>서버 컴포넌트와 SSR</h3>
<p>나도 착각 했던 것 중 하나인데 RSC는 SSR과는 다르다.</p>
<p><code>server</code>라는 단어가 둘다 들어가서 딱 착각하기 좋은 듯하다.</p>
<p>좋은 내용이 있어서 아래에 인용해봤다.</p>
<blockquote>
<p>Does this(RSC) replace SSR?</p>
</blockquote>
<blockquote>
<p>No, they’re complementary. SSR is primarily a technique to quickly display a non-interactive version of client components. You still need to pay the cost of downloading, parsing, and executing those Client Components after the initial HTML is loaded.
You can combine Server Components and SSR, where Server Components render first, with Client Components rendering into HTML for fast non-interactive display while they are hydrated. When combined in this way you still get fast startup, but you also dramatically reduce the amount of JS that needs to be downloaded on the client.</p>
</blockquote>
<h2>Next.js에서의 RSC</h2>
<p>얼마전에 app router가 정식 버전으로 나왔다.</p>
<p>많은 변화가 있었지만 가장 큰 변화는 아마 app 폴더가 생긴 것이 아닐까 싶다.</p>
<p>기존 버전의 Next.js에서는 pages 폴더에 있는 컴포넌트를 전부 클라이언트 컴포넌트로 취급하였다.</p>
<p>그리고 이번 버전에 추가된 app 폴더는 디폴트로 모든 컴포넌트를 서버 컴포넌트 취급을 한다.</p>
<blockquote>
<p>당분간은 pages폴더와 app폴더를 같이 사용할 수 있다고 한다.</p>
</blockquote>
<h3>무엇이 달라지는가?</h3>
<p>서버 컴포넌트와 클라이언트 컴포넌트를 구분하여 사용할 줄 알아야 할 것 같다.</p>
<p>서버 컴포넌트는 Node.js 환경에서 실행되고, 클라이언트 컴포넌트는 브라우저 환경에서 실행된다.</p>
<p>그렇기 때문에 서버 컴포넌트에서는 기존에 우리가 사용했던 Browser APIs, 이벤트, React Lifecycle Effect, Hooks 등을 사용할 수 없다.</p>
<p>기존처럼 사용하기 위해서는 아래와 같이 최상단에 <code>use client</code>를 선언해주면 된다.</p>
<pre><code class="language-js">'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    &#x3C;div>
      &#x3C;p>You clicked {count} times&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>Click me&#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md">https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md</a></li>
<li><a href="https://tech.kakaopay.com/post/react-server-components/">https://tech.kakaopay.com/post/react-server-components/</a></li>
<li><a href="https://yceffort.kr/2022/01/how-react-server-components-work">https://yceffort.kr/2022/01/how-react-server-components-work</a></li>
</ul>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="react"/>
        <category label="rsc"/>
        <category label="next.js"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[정리] 렌더링의 종류와 용어 정리]]></title>
        <id>140-frontend-of-term</id>
        <link href="https://nostrss.me/blog/140-frontend-of-term"/>
        <updated>2023-07-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[렌더링 사전이 필요해..]]></summary>
        <content type="html"><![CDATA[<h1>렌더링의 종류와 용어 정리</h1>
<p>현업에서 CSR만 사용해봐서 다른 렌더링 방식에 대해서 알아보다가 용어 정리가 좀 필요한 것 같아서 정리해봤다.</p>
<h2>CSR : client side rendering</h2>
<ul>
<li>렌더링의 주체 : Browser</li>
<li>렌더링의 과정
<ul>
<li>빈 HTML 파일을 받아온다</li>
<li>JS 파일을 받아온다</li>
<li>JS 파일을 실행한다</li>
<li>데이터를 받아온다</li>
<li>DOM Tree를 만든다</li>
<li>HTML을 렌더링한다</li>
</ul>
</li>
</ul>
<h3>장점</h3>
<ul>
<li>한번만 로딩(HTML, JS)이 되면 이후에는 빠르게 렌더링이 가능하다</li>
<li>서버의 부하가 적다</li>
<li>변경되는 일부분만 렌더링이 가능하다</li>
</ul>
<h3>단점</h3>
<ul>
<li>
<p>TTV, FCP 시간이 길다.</p>
<blockquote>
<p>TTV : time to view, 유저가 화면을 볼때까지의 시간
FCP : first contentful paint, 유저가 화면에 처음으로 무언가를 볼 수 있는 시간</p>
</blockquote>
</li>
<li>
<p>SEO 최적화가 어렵다.</p>
</li>
</ul>
<h2>SSG : static site generation</h2>
<ul>
<li>렌더링의 과정 : 빌드할 때 HTML 파일을 렌더링하여 정적 사이트를 생성한다.</li>
</ul>
<h3>장점</h3>
<ul>
<li>페이지 로딩이 빠르다.</li>
<li>SEO 최적화가 가능하다.</li>
</ul>
<h3>단점</h3>
<ul>
<li>데이터가 정적이고 실시간 데이터가 아니다.</li>
</ul>
<h2>ISR : incremental static regeneration</h2>
<ul>
<li>렌더링 과정 - SSG 처럼 빌드 시 HTML 파일을 렌더링하여 정적 사이트를 생성한다. 그리고 정해진 주기에 따라 정적 사이트를 재생성한다.</li>
</ul>
<h3>장점</h3>
<ul>
<li>SSG + 데이터가 업데이트 된다.</li>
<li>SEO 최적화가 가능하다.</li>
</ul>
<h3>단점</h3>
<ul>
<li>하지만 실시간 데이터가 아니다.</li>
</ul>
<h2>SSR : server side rendering</h2>
<ul>
<li>렌더링의 주체 : Server</li>
<li>렌더링의 과정
<ul>
<li>유저의 요청을 받는다.</li>
<li>Server가 요청을 받아서 데이터를 받아온다.</li>
<li>Server가 HTML을 렌더링한다.</li>
<li>Server가 렌더링된 HTML을 유저에게 전달한다.</li>
</ul>
</li>
</ul>
<h3>장점</h3>
<ul>
<li>TTV, FCP 시간이 짧다.</li>
<li>SEO 최적화가 가능하다.</li>
<li>실시간 데이터를 사용한다.</li>
</ul>
<h3>단점</h3>
<ul>
<li>SSG, ISR과 비교했을 때 비교적 느릴 수 있다</li>
<li>서버의 부하(Overhead)가 크다.</li>
</ul>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="rendering"/>
        <category label="csr"/>
        <category label="isr"/>
        <category label="ssg"/>
        <category label="ssr"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[알고리즘]최대공약수와 최소공배수]]></title>
        <id>139-algorithm</id>
        <link href="https://nostrss.me/blog/139-algorithm"/>
        <updated>2023-06-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[알아두면 쓸모 있을 것 같은 수학]]></summary>
        <content type="html"><![CDATA[<p>최근 알고리즘 문제를 풀다가 최대공약수와 최소공배수를 활용하는 문제가 있었다.</p>
<p>문제를 풀긴 풀었지만, 최대공약수와 최소공배수의 경우에는 공식이 이미 존재하기 때문에</p>
<p>잘 알아두면 시간을 절약하기 좋을 것 같아서 정리해 보았다.</p>
<h2>최대 공약수(greatest common divisor)</h2>
<p>유클리드 호제법을 이용하여 최대 공약수를 구하는 방법을 코드로 구현해 보았다.</p>
<pre><code class="language-javascript">const getGcd = (a, b) => {
  while (b > 0) {
    let temp = b;
    b = a % b;
    a = temp;
  }
  return a;
};
</code></pre>
<p>재귀적으로도 구현 가능할 것 같아 작성을 해봤다.</p>
<pre><code class="language-javascript">const getGcd = (a, b) => {
  if (b === 0) {
    return a;
  }
  return getGcd(b, a % b);
};
</code></pre>
<h2>최소 공배수(least common multiple)</h2>
<p>최소 공배수는 위의 최대 공약수를 이용하면 쉽게 구할 수 있다.</p>
<pre><code class="language-javascript">const lcm = (a, b) => {
  return (a * b) / gcd(a, b);
};
</code></pre>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="algorithm"/>
        <category label="javascript"/>
        <category label="gcd"/>
        <category label="lcm"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[책읽기]refactoring - 챕터 1]]></title>
        <id>138-refactoring-1</id>
        <link href="https://nostrss.me/blog/138-refactoring-1"/>
        <updated>2023-05-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[사수가 없으니 책이라도 읽어보자.]]></summary>
        <content type="html"><![CDATA[<h2>샘플 코드</h2>
<ul>
<li>
<p><a href="https://github.com/nostrss/book-refactoring/tree/ef7e94134633027ad7a61d140184751e64422a16/chapter-01">리팩토링 전 코드</a></p>
</li>
<li>
<p><a href="https://github.com/nostrss/book-refactoring/tree/main/chapter-01">리팩토링 후 코드</a></p>
</li>
</ul>
<h2>챕터 1</h2>
<p>저자는 자기가 명명한 리팩터링의 규칙과 기법(?)을 의거하며 샘플 코드를 리팩토링을 하는 법을 단계별로 보여준다.</p>
<p>예시를 통해서 리팩터링이 무엇인지 감을 잡는 챕터이다. 하지만..</p>
<blockquote>
<p>아니 챕터1 부터 왜 이렇게 복잡하지?</p>
</blockquote>
<p>라는 생각이 들게 한다.</p>
<p>그리고 눈으로만 코드를 보니 괄호가 눈에 잘 들어오지 않아서, 나는 저자의 코드를 직접 작성하면서 책을 정독했다.</p>
<p>챕터1만 보는데 반나절은 걸린 것 같다...</p>
<h2>리팩터링 기법</h2>
<p>저자는 앞으로 뒷장에서 더 자세히 리팩터링의 기법에 대해서 다룰 예정이라고 했지만, 몇가지 인상적인 내용이 있었다.</p>
<h3>변수 인라인하기</h3>
<p><strong>리팩터링 전</strong></p>
<pre><code class="language-javascript">for (let perf of invoice.performances) {
  const play = playFor(perf);
  let thisAmout = amountFor(perf, play);
}
</code></pre>
<p><strong>리팩터링 후</strong></p>
<pre><code class="language-javascript">for (let perf of invoice.performances) {
  // const play = playFor(perf);
  let thisAmout = amountFor(perf, playFor(perf));
}
</code></pre>
<p>저자는 위의 방식 대신 아래의 방식으로 리팩터링을 진행하며 이를 <code>변수 인라인하기</code>라고 부른다.</p>
<p>변수 <code>play</code>가 하나 제거 되기는 장점이 있긴 한데, 개인적으로는 그동안 위의 방식이 보기 좋아서 많이 사용했던 방식이었다.</p>
<p>왜 저자가 이렇게 수정을 하는지 궁금해지는 부분이다.</p>
<h3>조건부 로직을 다형성으로 바꾸기</h3>
<p><strong>리팩터링 전</strong></p>
<pre><code class="language-javascript">function amountFor(aPerformance) {
  let result = 0;
  switch (aPerformance.play.type) {
    case 'tragedy': // 비극
      result = 40000;
      if (aPerformance.audience > 30) {
        result += 1000 * (aPerformance.audience - 30);
      }
      break;
    case 'comedy': // 희극
      result = 30000;
      if (aPerformance.audience > 20) {
        result += 10000 + 500 * (aPerformance.audience - 20);
      }
      result += 300 * aPerformance.audience;
      break;
    default:
      throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);
  }
  return result;
}
</code></pre>
<p><strong>리팩터링 후</strong></p>
<pre><code class="language-javascript">class PerformanceCalculator {
  constructor(aPerformance, aPlay) {
    this.performance = aPerformance;
    this.play = aPlay;
  }

  get amount() {
    throw new Error('서브클래스에서 처리하도록 설계되었습니다.');
  }

  get volumeCredits() {
    return Math.max(this.performance.audience - 30, 0);
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 40000;
    if (this.performance.audience > 30) {
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}
class ComedyCalculator extends PerformanceCalculator {
  get amount() {
    let result = 30000;
    if (this.performance.audience > 20) {
      result += 10000 + 500 * (this.performance.audience - 20);
    }
    result += 300 * this.performance.audience;
    return result;
  }
  get volumeCredits() {
    return super.volumeCredits + Math.floor(this.performance.audience / 5);
  }
}
</code></pre>
<p>저자는 switch를 이용한 조건부 로직을 다형성(polymorphism)을 활용하여 수정하였다.</p>
<p>현업에서도 조건에 따른 분기마다 별도의 로직을 적용해야 하는경우가 아주 많다.</p>
<p>그럴때면 if else 의 지옥에 빠져 엄청나게 긴 코드를 봐야 하는 경우가 많았다.</p>
<p>class 문법이 익숙하지 않은 나지만 현실적으로 아주 와 닿는 리팩터링 방법이었다.</p>
<h2>후기</h2>
<p>생각보다 단계별로 설명이 알차게 되어 있다. 무언가 책이 단단하고 알찬 느낌이다.</p>
<p>오래 걸릴 것 같긴한데 완독 해보자 ㅎㅎ</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="book"/>
        <category label="refactoring"/>
        <category label="javascript"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[[책읽기]refactoring]]></title>
        <id>137-refactoring-0</id>
        <link href="https://nostrss.me/blog/137-refactoring-0"/>
        <updated>2023-05-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이 책이 그렇게 유명하다며? 그런데 어려워 보이는데?]]></summary>
        <content type="html"><![CDATA[<h2>좋은 코드란 어떤걸까?</h2>
<p>회사를 다니기 전에 좋은 코드에 대한 나의 생각은 아래와 같았다.</p>
<blockquote>
<p>짧고 간결한 코드</p>
</blockquote>
<blockquote>
<p>최적화가 잘 되어 있는 코드</p>
</blockquote>
<p>하지만 회사를 다니면서 추가된 내용이 있다.</p>
<blockquote>
<p>알아보기 쉬운 코드</p>
</blockquote>
<blockquote>
<p>유지 보수가 쉬운 코드</p>
</blockquote>
<blockquote>
<p>기능 추가가 쉬운 코드</p>
</blockquote>
<p>기존의 생각과는 조금 다른 방향성이 생겨 난 것이다.</p>
<h3>왜?</h3>
<p>혼자 개발을 한다면 이런 생각이 들지 않았을 것 같다.</p>
<p>하지만 회사에서 동료들과 함께 일을 하다보니 누군가가 작성한 코드를 봐야 하는 일이 자주 생겼다. 그리고 반대로 내가 작성한 코드를 다른 사람이 수정해야 하는 일도 있었다.</p>
<p>이때 서로 다른 스타일의 코드를 보면서 분석하는데 많은 시간을 들였던 기억이 있다.</p>
<p>또한 동료가 작성한 코드를 수정하다 보면 예상치 못한 사이드 이펙트가 발생하는 경우가 발생하는 일도 많았다. 여기에 정말 간단한 기능을 추가하는데, 예상보다 수정의 범위가 넓어져서 당황스러운 경우도 있었다.</p>
<p>회사에 시니어 개발자가 없다 보니 이에 대한 갈증이 생겨날 수 밖에 없었는데 마땅한 해결방법을 찾기 어려웠다. chat-gpt, 구글검색, 유튜브를 아무리 들여봐도 깊이가 느껴지지 않았고, 정보를 탐색하는 시간만 길어지는 느낌이 들었다.</p>
<h2>책 한번 읽어 볼까?</h2>
<p>그러다 회사 업무 때문에 대표님이 얇은 책 한 권을 읽어 오라고 했다.</p>
<p><a href="http://www.yes24.com/Product/UsedShopHub/Hub/92456411">프로그레시브 웹 앱</a></p>
<p>정말 오랜 만에 읽는 책을 읽어 봤는데, 그래서 인지 느낌이 남달랐다. 유튜브나, 블로그와 달리 작가의 내공이 느껴졌다고 해야할까?</p>
<p>책이 앏야서, 아니면 작가의 필력이 좋아서 그랬을지 모르지만 그 느낌이 너무 좋았다.</p>
<p>그래서 이번에는 조금 더 두껍고 어려운 책을 읽어 보려고 한다.</p>
<h3>리팩터링</h3>
<p><a href="http://www.yes24.com/Product/UsedShopHub/Hub/89649360">리팩터링 2판</a></p>
<p>이 책을 선택한 이유</p>
<ul>
<li>유튜브에서 추천 영상이 많았다..</li>
<li>1판의 경우 java로 예제 코드가 작성되어 있었는데, 2판에서는 javascript로 되어 있다.</li>
<li>1판에 대한 좋은 평가 글이 많았다.</li>
</ul>
<p>자, 책은 준비했고 한번 읽어보자.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="book"/>
        <category label="refactoring"/>
        <category label="javascript"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[typedoc으로 프론트엔드 문서 만들기]]></title>
        <id>136-typedoc-gh-pages</id>
        <link href="https://nostrss.me/blog/136-typedoc-gh-pages"/>
        <updated>2023-03-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[AI가 문서를 만들어주는 세상이 빨리 왔으면 좋겠다.]]></summary>
        <content type="html"><![CDATA[<p>회사에서든, 개인적으로 집에서 코드를 볼 때마다</p>
<blockquote>
<p>이 변수는 뭐지?</p>
</blockquote>
<blockquote>
<p>이 함수는 무슨 작동을 하는거지?</p>
</blockquote>
<p>라는 생각을 하면서 코드를 살펴보곤 한다.</p>
<p>그래서 다음에 볼때는 좀 더 알아 보기 쉽게 하려고 주석을 열심히 달기도 한다.</p>
<p>그러다 API 명세처럼 프론트 소스코드들도 문서화 해주는 방법이 없을까 해서 알아보다가 typedoc을 통해서 문서화 할 수 있는 방법을 찾아서 적용해 봤다.</p>
<h2>typedoc이란?</h2>
<p><a href="https://typedoc.org/">typedoc 공식 홈페이지 바로가기</a></p>
<p><a href="https://typedoc.org/example/">typedoc 예제</a></p>
<p>typedoc은 소스코드에 포함된 주석으로 html 문서를 만들어주는 패키지이다.</p>
<p>별도로 문서를 작성하는 시간을 들일 필요없이 소스코드에 작성하면 바로 빌드하여 문서화 할 수 있는 장점이 있다.</p>
<h2>typedoc 설치하기</h2>
<pre><code class="language-bash">// Install

npm install --save-dev typedoc
</code></pre>
<h2>typedoc 설정하기</h2>
<p>tsconfig.json에 아래와 같이 entryPoints를 지정해줘야 한다.</p>
<p>entryPoints는 TypeDoc이 문서화할 TypeScript 파일의 진입점을 지정하는 데 사용되고, 진입점이 여러 곳일 경우에는 배열로 여러개 지정해줄 수 있다.</p>
<p>out은 빌드파일이 생성될 경로이다.</p>
<pre><code class="language-json"> "typedocOptions": {
    "entryPoints": ["src/pages/index.tsx"],
    "out": "docs"
  }
</code></pre>
<h2>typedoc 문서 생성하기</h2>
<p>문서를 생성하는 명령어는 아래와 같다.</p>
<pre><code class="language-bash">npx typedoc src/index.ts
</code></pre>
<p>하지만, 위와 같이 작성하면 하위에 있는 소스코드 파일의 주석들은 문서로 만들어지지 않는 단점이 있었다.</p>
<p>그래서 찾은 방법이 아래의 명령어이다. 이렇게 입력하면, entrypoints부터 시작하여 하위 폴더의 파일들까지 전부 문서로 만들어 준다.</p>
<pre><code class="language-bash">npx typedoc --entryPointStrategy expand ./src
</code></pre>
<h2>결과물</h2>
<p>나 같은 경우 빌드된 문서를 언제든지 웹에서 볼 수 있도록 gh-pages를 이용해 git-hub page에 배포를 해두었다.</p>
<p><a href="https://nostrss.github.io/nextjs-blog/">typedoc 으로 생성한 문서 보기</a></p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="react"/>
        <category label="nextjs"/>
        <category label="typedoc"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[나만의 Boilerplate를 github template로 만들기]]></title>
        <id>135-github-template</id>
        <link href="https://nostrss.me/blog/135-github-template"/>
        <updated>2023-03-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[한번 잘 만들어두면 계속 사용할 수 있는 boilerplate를 github template로 만들어보자.]]></summary>
        <content type="html"><![CDATA[<p>매번 새로운 프로젝트를 시작할 때 마다 똑같이 반복해서 작업하는 일이 있다.</p>
<pre><code class="language-bash">// 설치하기..
npx create-react-app
npx create-next-app
npx eslint init
(등등등)

// 설정하기
package.json
tsconfig.json
.eslintrc.js
.gitignore
next.config.js
(등등등)
</code></pre>
<p>이렇게 setting 하는 것도 사실 한 번에 잘 되지 않으면 상당히 시간을 소모하는 작업이 되는 경우가 있다. (바로 오늘 내가 그랬다..)</p>
<p>그래서 나만의 boilerplate를 만들어서 git-hub에 템플릿으로 만들어두고 사용해보려고 한다.</p>
<h2>Boilerplate 준비하기</h2>
<blockquote>
<p>boilerplate는 다른 프로젝트에서 재사용할 수 있는 코드와 파일들의 집합입니다. 예를 들어, React 프로젝트를 시작할 때마다 같은 파일들을 만들어야 한다면, 이 파일들을 boilerplate에 추가하여 다음에 프로젝트를 시작할 때 boilerplate를 사용하면 됩니다. 이렇게 boilerplate를 사용하면 새로운 프로젝트를 시작할 때 시간을 절약할 수 있습니다.</p>
</blockquote>
<p>내가 만들 Boilerplate 내용은 아래와 같다</p>
<ul>
<li>Next.js</li>
<li>typescript</li>
<li>eslint : airbnb</li>
<li>prettier</li>
</ul>
<p>최소한의 세팅 내용이다.</p>
<p>css, 상태관리 라이브러리 등등은 상황을 보면서 추가할 예정이다.</p>
<p>준비가 된 코드는 github에 푸쉬해 두자.</p>
<p><a href="https://github.com/nostrss/next-lint-airbnb">Boilerplate 소스코드 보러가기</a></p>
<h2>Github Template Repository 설정하기</h2>
<ul>
<li>Repository > setting</li>
</ul>
<ul>
<li>Template Repository 체크박스 On</li>
</ul>
<p>이게 끝이다. 앞으로 이 Repository를 Template로 바로 사용할 수 있다.</p>
<h2>Template 사용하기</h2>
<p>새로운 Repository를 생성해보자.</p>
<p>그때 select box를 클릭 해보면, 방금 설정한 Template Repository가 옵션으로 나오게 된다.</p>
<p>옵션을 선택하고 Repository를 만들게 되면 똑같은 Repository가 생성이 되고 바로 이어서 추가 설정 및 작업을 시작 하면 된다.</p>
<h2>fork와의 차이점</h2>
<p>Repolistory를 fork해서 그냥 사용하는 것과 차이가 없게 느껴질 수 있는데, 몇가지 다른 점이 있다.</p>
<ul>
<li>새 포크에는 부모 리포지토리의 전체 커밋 기록이 포함되며 템플릿에서 만든 리포지토리는 단일 커밋으로 시작합니다.</li>
<li>포크에 대한 커밋은 기여 그래프에 표시되지 않지만 템플릿에서 만든 리포지토리에 대한 커밋은 기여 그래프에 표시됩니다.</li>
<li>포크는 템플릿에서 리포지토리를 만들면 새 프로젝트를 빠르게 시작하는 동시에 기존 프로젝트에 코드를 기여하는 임시 방법이 될 수 있습니다.</li>
</ul>
<p><a href="https://docs.github.com/ko/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template">자세한 내용보러가기</a></p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="github"/>
        <category label="template"/>
        <category label="boilerplate"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js SSR, SSG를 Vercel에 배포하기(3)]]></title>
        <id>134-nextjs-vercel-3</id>
        <link href="https://nostrss.me/blog/134-nextjs-vercel-3"/>
        <updated>2023-03-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[배포가 가장 쉬웠어요 라고 할 뻔 했다.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/nostrss/next-render">전체 소스코드</a></p>
<p><a href="https://next-render-hjuyogs9h-nostrss.vercel.app/">DEMO</a></p>
<p>이제 소스코드를 <code>vercel</code>에 배포해 볼 차례이다.</p>
<p>먼저 지금까지의 소스코드를 Git-hub에 <code>Push</code> 해두도록 하자.</p>
<h2>Vercel 회원가입</h2>
<p><a href="https://vercel.com/">Vercel 바로가기</a></p>
<h2>Git-hub 계정 연결, Repository 연결하기</h2>
<p>먼저 자신의 Git-Hub 계정을 연결,선택 해준다.</p>
<p>그러면 아래와 같이 Git-hub에 있는 나의 Repository들이 쭉 나오게 된다.</p>
<p>그 중에 배포하고자 하는 Repository를 선택, import 해보자.</p>
<h3>Repository가 보이지 않는 경우</h3>
<p>깃허브에서 Vercel Application 설정을 확인해보자</p>
<ul>
<li>Github > setting > applications > Configure</li>
</ul>
<p>나 같은 경우에는 여기서 <code>All Repositories</code>에 접근 가능하도록 허용하니 해결이 되었다.</p>
<h2>Build &#x26; Deploy</h2>
<p>위와 같이 설정을 하면 화면이 바뀌면서 자동으로 배포가 진행되기 시작한다.</p>
<p>배포가 완료되면 아래 사진과 같이 결과를 볼 수 있다.</p>
<p>배포 결과를 볼수 있는 url, 연결된 branch 등을 확인 할 수 있다.</p>
<p>나 같은 경우에는 현재 main 브랜치를 연결해 두었다.</p>
<h2>후속 배포</h2>
<p>Vercel에 연결되어 있는 branch에 소스코드가 푸쉬되는 순간 vercel에서 자동으로 빌드하여 배포가 진행된다.</p>
<p>별도로 사용자가 npm run build 와 같은 명령어를 사용할 필요가 없다.</p>
<p>터미널에서 빌드 오류가 나듯 vercel에서도 빌드 오류가 발생 하면 배포가 진행되지 않으니, 코드를 push 하고 build와 배포가 끝까지 완료 되었는지 확인 할 필요가 있다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="Next"/>
        <category label="ssr"/>
        <category label="ssg"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js SSR, SSG를 Vercel에 배포하기(2)]]></title>
        <id>133-nextjs-vercel-2</id>
        <link href="https://nostrss.me/blog/133-nextjs-vercel-2"/>
        <updated>2023-03-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이래서 Next Next 하는구나..]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/nostrss/next-render">전체 소스코드</a></p>
<p><a href="https://next-render-hjuyogs9h-nostrss.vercel.app/">DEMO</a></p>
<p>작품 리스트를 <code>SSR</code>로 구현해봤으니, 이번에는 <code>SSG</code>를 구현해보려고 한다.</p>
<p>리스트 중에 하나를 클릭 했을 때 상세 화면으로 넘어가고</p>
<p>상세화면은 <code>SSG</code>로 렌더링 되도록 할 예정이다.</p>
<h2>작품 상세 페이지 SSG 구현</h2>
<h3>API</h3>
<blockquote>
<p>사용할 API : <a href="https://api.artic.edu/docs/">Art Institute of Chicago API</a></p>
</blockquote>
<h3>SSG 구현 코드</h3>
<blockquote>
<p><a href="https://github.com/nostrss/next-render/blob/main/src/pages/%5Bid%5D/index.jsx">SSG로 구현된 전체 소스코드</a></p>
</blockquote>
<h2>구현 내용</h2>
<h3>getStaticProps</h3>
<p><a href="https://nextjs.org/docs/basic-features/data-fetching/get-static-props">getStaticProps 문서 보러가기</a></p>
<ul>
<li><code>getStaticProps</code>는 빌드 시 api 통신 응답값을 받아 미리 html 파일을 생성해둔다.</li>
<li>즉, 운영에 배포 되면 유저는 백엔드 서버와의 통신 결과물을 보는 것이 아니라, 이미 빌드되어 있는 <code>html</code> 정적파일을 브라우저로 다운 받아 보는 것이다</li>
<li>따라서 빌드시 api 통신이 성공하지 않으면 당연히 빌드 에러가 발생한다.</li>
<li>그리고 해당 페이지 접속 시 로딩이 엄청나게 빠르다.(당연히 이미 렌더링되어 있었으니깐..)</li>
<li>또 당연하지만 페이지 소스를 보면 api응답 값들이 이미 채워져 있다.</li>
</ul>
<pre><code class="language-javascript">export async function getStaticProps(context) {
  const id = context.params.id;
  const apiUrl = `https://api.artic.edu/api/v1/artworks/${id}`;
  const res = await fetch(apiUrl);
  const data = await res.json();
  return {
    props: {
      detailData: data.data,
    },
  };
}
</code></pre>
<p>위의 코드는 빌드 시 api 통신 응답값을 클라이언트 컴포넌트에 props로 전달하는 역할을 한다.</p>
<p><code>SSR</code>과 다른 점은 이것이 <code>빌드(build)</code>시 이루어진다는 것이다.</p>
<p><code>npm run build</code> 또는 <code>yarn build</code> 커맨드를 입력하는 순간 이미 페이지가 만들어지는 것이다.</p>
<p>하지만 내가 작성한 코드에서는 위와 같이 작성하면 에러가 발생하였다.</p>
<p>이유는 getStaticProps가 <code>dynamic routing</code>페이지는 렌더링 하지 못하기 때문이다.</p>
<p>이 때 필요한 것이 <code>getStaticPaths</code>이다.</p>
<h3>getStaticPaths</h3>
<p><a href="https://nextjs.org/docs/basic-features/data-fetching/get-static-paths">getStaticPaths 문서 보러가기</a></p>
<ul>
<li><code>getStaticPaths</code>는 <code>dynamic routing</code>으로 동적으로 변하는 path 정보를 <code>getStaticProps</code>에 전달하는 역할을 한다.</li>
<li>이 path 정보로 <code>getStaticProps</code>는 빌드 시 api를 호출하고 응답값을 받아 정적인 페이지를 생성하는 것이다.</li>
</ul>
<pre><code class="language-javascript">export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: '14556' } },
      { params: { id: '11434' } },
      { params: { id: '16487' } },
    ],
    fallback: true,
  };
}
</code></pre>
<p>위의 코드를 보면 id 3개를(14556, 11434, 16487) path 정보로 <code>getStaticProps</code>에 전달하고 있다.
그렇다면 빌드 시 <code>getStaticProps</code>는 3개의 id로 api 통신을 하고 응답값을 받아 정적인 페이지를 생성할 것이다.</p>
<p>빌드를 해보자.</p>
<p>정적 페이지 3개가 빌드 되었다고 빌드 결과에서 확인 할 수 있다.</p>
<p>실제 빌드 폴더에서 확인해보자.</p>
<p>빌드 폴더에 내가 지정한 14556, 11434, 16487 html 파일이 생성된 것을 볼 수 있었다.</p>
<p>그렇다면 여기서 또 다른 의문이 생기게 된다...</p>
<blockquote>
<p>작품의 개수가 100개라면, getStaticPaths에 100개의 정보를 입력해야 하는건가?</p>
</blockquote>
<h4>fallback(Generating paths on-demand)</h4>
<p>다시 한번 <code>getStaticPaths</code> 코드를 살펴보자.</p>
<pre><code class="language-javascript">    fallback: true, // 이건 무엇을 하는 걸까??
</code></pre>
<p><code>Next.js</code>에서는 우리의 이런 요구를 예상한듯 이미 준비를 해두었는데, 바로 <code>fallback</code>을 이용하는 것이다.</p>
<p>모든 페이지를 전부 빌드하는 것이 아니라 필요할 때 마다 정적 페이지를 생성하는 것이다.</p>
<p>위의 코드를 다시 풀어서 설명하면</p>
<blockquote>
<p>id 3개는 미리 페이지를 정적 생성하고</p>
</blockquote>
<blockquote>
<p>나머지 dynamic routing 페이지는 유저가 접속하면 그때 그때 페이지를 생성해줘</p>
</blockquote>
<p>라는 의미로 이해하면 된다.</p>
<p>여기서 <code>fallback:true</code>는 필요할 때마다 정적 페이지를 생성한다라는 옵션인 것이다.</p>
<p>실제로 생성 되는 지 확인 해보자.</p>
<p>빌드 후 <code>Production</code> 모드로 실행을 하자</p>
<blockquote>
<p>yarn build</p>
</blockquote>
<blockquote>
<p>yarn start</p>
</blockquote>
<p>그리고 몇몇 페이지를 방문해봤다.</p>
<p>내가 지정한 3개의 id외 2개의 페이지가 새롭게 생겨난 것을 볼 수 있었다.</p>
<p>신기한 기능이긴 한데 몇가지 의문점이 들었다.</p>
<blockquote>
<p>서비스를 운영하다 보니 약 10,000개의 정적 페이지들이 생겼다.</p>
</blockquote>
<blockquote>
<p>용량적으로 문제는 없는 건가?</p>
</blockquote>
<blockquote>
<p>만약 새롭게 build를 하게 되는 경우 기존에 쌓여있던 정적 페이지들은 전부 사라지는 건가?</p>
</blockquote>
<p>실무에서는 SSG를 어떻게 쓰고 있을까..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="Next"/>
        <category label="ssr"/>
        <category label="ssg"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js SSR, SSG를 Vercel에 배포하기(1)]]></title>
        <id>132-nextjs-vercel</id>
        <link href="https://nostrss.me/blog/132-nextjs-vercel"/>
        <updated>2023-03-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[오랜만에 사용해 보는 Next.js, 보고 싶었다 Next.js]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/nostrss/next-render">전체 소스코드</a></p>
<p><a href="https://next-render-hjuyogs9h-nostrss.vercel.app/">DEMO</a></p>
<p>최근 공부의 목적에 대해 갈팡질팡하다가 rendering에 대해 부쩍 관심이 생겼다.</p>
<p>그래서 공부할 겸 Next.js의 SSR(server siede rendering)과 SSG 렌더링을 간단히 구현해서 배포를 해봤다.</p>
<h2>프로젝트 준비하기</h2>
<h3>API</h3>
<p>먼저 렌더링할 데이터를 fetch할 api가 필요했다.</p>
<p>최대한 간단히 구현하고 싶어서 auth,cors를 신경 쓸 필요 없는 api를 하나 찾았다.</p>
<blockquote>
<p>사용할 API : <a href="https://api.artic.edu/docs/">Art Institute of Chicago API</a></p>
</blockquote>
<h3>구현할 페이지</h3>
<ul>
<li>작품 리스트 페이지 : SSR</li>
<li>작품 상세 페이지 : SSG</li>
</ul>
<p>이렇게 2개의 페이지만 있으면 될 듯 하다.</p>
<p>페이지 1개는 SSR, 다른 나머지 페이지는 SSG로 구현해볼 생각이다.</p>
<h2>작품 리스트 페이지 SSR 구현</h2>
<blockquote>
<p><a href="https://github.com/%3Enostrss/next-render/blob/main/src/pages/index.js">SSR로 구현된 전체 소스코드</a></p>
</blockquote>
<h3>SSR 구현 전 코드</h3>
<pre><code class="language-javascript">import Head from 'next/head';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';

export default function Home() {
  const router = useRouter();
  const [dataList, setDataList] = useState([]);

  useEffect(() => {
    fetch(`https://api.artic.edu/api/v1/artworks?limit=20`)
      .then((res) => res.json())
      .then((data) => {
        setDataList([...data.data]);
      });
  }, []);

  const onClickItem = (id) => () => {
    router.push(`/${id}`);
  };

  return (
    &#x3C;>
      {dataList === undefined ? (
        &#x3C;div>loading...&#x3C;/div>
      ) : (
        &#x3C;>
          &#x3C;Head>
            &#x3C;title>Next.js Rendering Test&#x3C;/title>
            &#x3C;meta
              name='description'
              content='Next Server Sider Rendering Page'
            />
            &#x3C;meta
              name='viewport'
              content='width=device-width, initial-scale=1'
            />
            &#x3C;link rel='icon' href='/favicon.ico' />
          &#x3C;/Head>
          &#x3C;main>
            &#x3C;h1>This page is implemented with SSR&#x3C;/h1>
            {dataList?.map((item) => (
              &#x3C;fieldset
                key={item.id}
                onClick={onClickItem(item.id)}
                style={{ cursor: 'pointer' }}
              >
                &#x3C;legend>Artwork {item.id}&#x3C;/legend>
                &#x3C;ul>
                  &#x3C;li>title : {item.title}&#x3C;/li>
                &#x3C;/ul>
              &#x3C;/fieldset>
            ))}
          &#x3C;/main>
        &#x3C;/>
      )}
    &#x3C;/>
  );
}
</code></pre>
<p>위 코드의 과정을 간단히 설명하면 아래와 같다</p>
<blockquote>
<ul>
<li>useEffect로 페이지가 최초 로딩 될 때 작품 리스트 api를 호출 한다.</li>
<li>응답값을 useState로 dataList에 저장한다.</li>
<li>dataList의 작품 리스트를 보여준다</li>
</ul>
</blockquote>
<p>이 코드를 SSR로 렌더링하기 위해 아래와 같이 변경 했다.</p>
<ul>
<li>
<p>useEffect로 페이지가 최초 로딩 될 때 작품 리스트 api를 호출 한다.</p>
<blockquote>
<p>getServerSideProps로 서버에서 api를 호출한다.</p>
</blockquote>
</li>
<li>
<p>응답값을 useState로 dataList에 저장한다.</p>
<blockquote>
<p>응답값을 props로 전달한다.</p>
</blockquote>
</li>
</ul>
<pre><code class="language-javascript">export async function getServerSideProps() {
  // useEffect가 아니라 서버에서 api를 호출한다.
  const res = await fetch(`https://api.artic.edu/api/v1/artworks?limit=20`);
  const data = await res.json();

  // Props로 응답값을 전달한다.
  return {
    props: {
      dataList: data.data,
    },
  };
}
</code></pre>
<pre><code class="language-javascript">// 서버에서 props로 api 응답값을 전달 받는다.
export default function Home({ dataList }) {
(...생략)
</code></pre>
<h2>SSR 확인하기</h2>
<p>페이지의 외관만 보면 SSR을 적용하기 전과 동일하게 보이기 때문에 제대로 적용이 된건지 알 수가 없다.</p>
<p>이럴 땐 브라우저에서 cmd + opt + u(윈도우 ctrl + u)를 눌러보자.</p>
<p>(또는 마우스 우클릭 > 페이지 소스 보기)</p>
<p>SSR을 적용하기 전과 후의 차이점이 보이는가?</p>
<blockquote>
<p>SSR 적용 전</p>
</blockquote>
<p>SSR을 적용하기 전에는 api 응답으로 받은 작품 리스트의 내용이 보이지 않는다.</p>
<blockquote>
<p>SSR 적용 후</p>
</blockquote>
<p>SSR을 적용 한 뒤에는 api 응답값으로 받은 작품 타이틀명이 페이지 소스에 보이는 것을 확인 할 수 있다.</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="Next"/>
        <category label="ssr"/>
        <category label="ssg"/>
        <category label="vercel"/>
        <category label="deploy"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[React PWA 만들기(2)]]></title>
        <id>131-progressive-web-app-2</id>
        <link href="https://nostrss.me/blog/131-progressive-web-app-2"/>
        <updated>2023-03-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[대표님 한마디에 이렇게까지 준비를 해야해나?]]></summary>
        <content type="html"><![CDATA[<h2>PWA 장점</h2>
<p>프로그레시브 웹 앱(Progressive Web App, PWA)은 웹과 네이티브 앱의 기능을 결합한 형태의 애플리케이션이다.</p>
<p>PWA는 온라인에서 쉽게 접근 가능하며, 브라우저를 통해 실행이 가능하고, 다운로드도 가능하다.
즉, 앱 스토어에서 다운로드 및 설치를 필요로 하지 않으므로, 개발자는 플랫폼의 종속성에서 벗어날 수 있다.
그리고 Native App을 별도로 개발할 필요가 없는 장점이 있다.</p>
<p>이렇게 장점만 보면 모든 기업들이 앞다투어 도입을 할 것 같지만, 어떤 이유 인지 도입이 그렇게 빠르게 되고 있다는 생각이 들지는 않는다.
아무래도 각 플랫폼의 이해타산이 맞물려 있기 때문이 아닐까 싶다.</p>
<p>구글과 애플의 입장에선 인앱 결제를 통한 수수료 수익이 줄어들 가능성이 있기 때문이지 않을까 싶다.</p>
<p>구글의 경우에는 그래도 크롬에서 지원하는 등의 노력이 보이는데, 애플은 아직 소극적인 느낌이다.</p>
<h3>PWA의 기술적 정의</h3>
<p><a href="https://adactio.medium.com/what-is-a-progressive-web-app-f1ca780f30e6">What is a Progressive Web App?</a></p>
<p>제레미 키스(Jeremy Keith)는 PWA의 기술적 특징을 이렇게 설명한다</p>
<ol>
<li>HTTPS</li>
<li>Service-Worker</li>
<li>Web App Manifest</li>
</ol>
<p>이전 블로그 포스팅에서 나도 간단히 React 프로젝트에 PWA를 적용해봤는데, 저 내용을 보니 구현 과정이 조금 이해가 되는 듯 하다.</p>
<p><img src="https://user-images.githubusercontent.com/56717167/222913262-adc55a93-e498-49d1-8cba-ceff24f4ddf6.png" alt="pwabuilder"></p>
<blockquote>
<p>PWA-Builder에서 검사 항목들(https://www.pwabuilder.com)</p>
</blockquote>
<h2>HTTPS</h2>
<p>이건 굳이 말하지 않아도 보안 때문이지 않을까 하는 생각이 든다.
(그리고 https가 아닐 경우 구글이 <code>안전하지 않음</code>이라는 문구를 노출하기 때문에..)</p>
<h2>Service-Worker</h2>
<blockquote>
<p>웹 브라우저의 네트워크 요청과 자원관리를 개발자가 중간에서 직접 제어하도록 해주는 강력한 기술이다. 서비스 워커를 이용하면 안정적이고, 빠르고, 오프라인 기능에서도 작동하는 웹페이지를 제작할 수 있다. - 프로그레시브 웹 앱 (제이슨 그릭스비)</p>
</blockquote>
<p>책에서는 위와 같이 설명을 하고 있는데, 조금 단순화해서 정리하면 App이 오프라인으로 전환되더라도 계속 작동하는 PWA를 만드는 JS파일(?)이라고 생각하면 될 듯하다.
우리나라에 워낙 모바일 네트워크가 잘 구축되어 있기 때문에, 스마트폰은 항상 통신이 되어야 한다고 생각한다.</p>
<p>하지만 이건 우리나라가 특이한 경우고 해외의 경우 모바일 통신 상태가 불안정한 경우가 많다. 그리고 개발자들은 이를 고려해야 하는 경우도 있다.</p>
<p>페이스북과 트위터가 라이트(lite)버전의 용량이 작은 앱을 별도로 출시 하는 것도 이런 이유일 것이다.</p>
<p>즉, 서비스 워커는 PWA의 로컬 캐시 전략을 정의하는 역할을 한다고 볼 수 있다.</p>
<h2>Web App Manifest</h2>
<p><code>Manifest</code></p>
<p>React 개발을 하다보면 어디선가 많이 봤을 법한 단어이다. 그렇다 public 폴더 안에 존재하는 <code>manifest.json</code> 파일을 말한다.</p>
<p>사실 나는 <code>manifest.json</code> 파일이 프로젝트에 항상 있었지만 어떤 역할을 하는지 몰랐었다. 하지만 삭제를 하려고 해도 혹시 몰라서 항상 건드리지 않았던 파일이었는데, PWA에서는 중요한 역할을 하고 있었다..</p>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="react"/>
        <category label="pwa"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[React PWA 만들기(1)]]></title>
        <id>130-progressive-web-app</id>
        <link href="https://nostrss.me/blog/130-progressive-web-app"/>
        <updated>2023-03-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[대표님은 PWA가 하고 싶다고 하셨어.]]></summary>
        <content type="html"><![CDATA[<h2>PWA란?</h2>
<ul>
<li>Progressive Web Apps의 약자이다.</li>
<li>html,css,javascript와 같은 웹기술로 만드는 App이라고 생각하면 된다. 마치 Web과 App의 경계사이에 있는 느낌이다.</li>
<li>바탕화면에 웹페이지를 즐겨찾기 해둔 것처럼 간단해 보이기도 하고, Web을 패키징한 하이브리드 앱처럼 보이기도 한다.</li>
<li>구글,MS에서는 PWA 사용과 보급에 적극적이지만 Apple은 이에 소극적이라고 한다.</li>
</ul>
<h3>Register Store(?)</h3>
<ul>
<li>직접 해보지는 않았지만 이렇게 생성한 App을 이론적(?)으로 구글플레이 스토어와 애플 앱 스토어에 등록 할 수 있다고 한다.</li>
<li>검색을 해보니 구글은 사례가 많이 보였는데, 애플의 앱 스토어의 경우에는 찾을 수가 없었다. 애플은 심사통과가 되지 않을 수도 있을 것 같다.</li>
</ul>
<h3>reference</h3>
<p><a href="https://www.pwabuilder.com/">PWA-builder</a></p>
<p><a href="https://developer.chrome.com/blog/getting-started-pwa/">Getting started with Progressive Web Apps</a></p>
<h3>PWA 예시</h3>
<p>스타벅스 홈페이지가 PWA가 적용이 되어있다.</p>
<p><a href="https://app.starbucks.com/">Starbucks 바로가기</a></p>
<p>위의 링크를 타고 접속하면 주소창 우측에 다운로드 버튼이 있는데, 클릭하면 PWA가 다운로드 된다.
다운로드 된 PWA를 실행시키면 브라우저에서 실행되는 것이 아니라 마치 APP을 실행시킨듯한 화면이 나타난다.</p>
<h2>REACT에 PWA 적용하기</h2>
<h3>1.React Set up</h3>
<blockquote>
<p>npx create-react-app pwa</p>
</blockquote>
<h3>2.Install gh-pages and package.json setting</h3>
<ul>
<li>git-hub pages에 배포해서 보기 위하여 gh-pages를 설치하여 간단히 배포를 위한 세팅을 했다.</li>
</ul>
<blockquote>
<p>npm i gh-pages</p>
</blockquote>
<ul>
<li>package.json에 배포 script 추가</li>
</ul>
<pre><code class="language-json">//package.json
...
"homepage": "http://nostrss.github.io/pwa", //추가
...
"predeploy": "npm run build", //추가
"deploy": "cp build/index.html build/404.html &#x26;&#x26; gh-pages -d build" //추가
</code></pre>
<h3>3.Add service-worker</h3>
<p>아래 2개의 파일을 root 위치에 작성하여 추가해줬다.</p>
<ul>
<li>service-worker.js<a href="https://github.com/nostrss/pwa/blob/main/src/service-worker.js">(소스코드)</a></li>
<li>serviceWorkerRegistration.js<a href="https://github.com/nostrss/pwa/blob/main/src/serviceWorkerRegistration.js">(소스코드)</a></li>
</ul>
<p>그리고 index.js파일에 service-worker를 등록해주는 코드를 추가해줬다.</p>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// 아래 코드 추가
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &#x3C;React.StrictMode>
    &#x3C;App />
  &#x3C;/React.StrictMode>
);

// 아래 코드 추가
serviceWorkerRegistration.register();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
</code></pre>
<h3>4.Deploy</h3>
<blockquote>
<p>npm run deploy</p>
</blockquote>
<ul>
<li>배포 후 페이지에 접속해보면 아래와 같이 주소창 옆에 다운로드 버튼이 생기게 된다.</li>
</ul>
<ul>
<li>다운로드 후 실행 해보면 아까 본 스타벅스 PWA처럼 내가 만든 PWA가 실행되는 것을 볼 수 있다.</li>
</ul>
<h3>5. PWA Analyze</h3>
<ul>
<li>안드로이드, iOS앱에 배포 시 심사를 받듯이, PWA도 조건을 충분이 충족하는지 검사하는 방법이 몇가지 존재한다.</li>
</ul>
<h4>Lighthouse</h4>
<ul>
<li>Chrome 개발자 도구 > Lighthouse 에서 직접 검사를 해볼 수 있다.</li>
<li>검사 후 어떤 점이 부족한지 결과와 어떻게 수정해야하는지 가이드도 볼 수 있다.</li>
</ul>
<h4>Pwa-builder</h4>
<p><a href="https://www.pwabuilder.com/">PWA-builder</a></p>
<ul>
<li>링크에 접속하여, URL을 입력하면 아래와 같이 결과를 볼 수 있다.</li>
</ul>
<ul>
<li>그리고 여기서 OS별(안드로이드,애플 등) 패키지를 다운로드 받을 수가 있다.</li>
<li>이 패키지를 어떤 추가적인 과정을 거쳐서 스토어에 등록할 수 있다고 한다.</li>
<li>실제 가능하다면, 어떤 서비스를 만들 때 초기에 Native App을 따로 만들지 않고 활용할 수 있을 듯하다.</li>
</ul>
<h3>ETC</h3>
<ul>
<li>나는 직접 service-worker를 생성했었는데, 알고보니 더 쉬운 방법이 있었다.</li>
<li>아래의 커맨드로 react template를 설치하면 더 쉽게 PWA를 적용할 수 있다.</li>
</ul>
<p>JavaScript</p>
<blockquote>
<p>npx create-react-app my-app --template cra-template-pwa</p>
</blockquote>
<p>TypeScript</p>
<blockquote>
<p>npx create-react-app my-app --template cra-template-pwa-typescript</p>
</blockquote>]]></content>
        <author>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </author>
        <category label="react"/>
        <category label="pwa"/>
        <contributor>
            <name>Nostrss</name>
            <email>jintagi@gmail.com</email>
            <uri>https://github.com/nostrss</uri>
        </contributor>
    </entry>
</feed>
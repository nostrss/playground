{
    "version": "https://jsonfeed.org/version/1",
    "title": "Nostrss's Dev Blog",
    "home_page_url": "https://github.com/nostrss",
    "feed_url": "https://nostrss.me/feed.json",
    "description": "Nostrss Blog Post List",
    "author": {
        "name": "Nostrss",
        "url": "https://github.com/nostrss"
    },
    "items": [
        {
            "id": "168-rss-atom-json",
            "content_html": "<p>블로그의 컨텐츠를 우리가 검색하거나 직접 방문하여 볼수도 있지만, 구독처럼 새로운 컨텐츠가 발행되면 받아서 볼 수 있는 기능이 존재한다. 이를 가능케 하는게 <code>RSS</code>, <code>Atom</code>, <code>JSON-Feed</code>이다.</p>\n<p>위 3개를 직접 전부 구현하기엔 너무 어려울 것 같아서 외부 패키지를 사용해서 구현해보았다.</p>\n<h2>패키지 설치</h2>\n<p><code>RSS</code>를 구현하기 위해 2가지 방법을 고민했다.</p>\n<ol>\n<li>동적으로 api를 호출해서 데이터를 가져오는 방법</li>\n<li>빌드시 정적 파일을 생성하는 방법</li>\n</ol>\n<p>아무래도 이미 파일로 생성이 되어 있으면, 조금더 속도에서 빠르지 않을까 싶어서 2번의 방법으로 구현하기로 했다. 그리고 서버 리소스도 사용하지 않아도 되는 장점도 있을 것 같다.</p>\n<p>구현에 사용할 패키지는 아래 2개이다.</p>\n<p><a href=\"https://www.npmjs.com/package/feed\">📌 Feed NPM 페이지 바로가기 📌</a></p>\n<p><a href=\"https://www.npmjs.com/package/ts-node\">📌 ts-node 페이지 바로가기 📌</a></p>\n<h2>구현 코드</h2>\n<pre><code class=\"language-ts\">import { Feed } from 'feed';\nimport { writeFileSync } from 'fs';\nimport {\n  BASE_URL,\n  DEFAULT_META_AUTHOR_EMAIL,\n  DEFAULT_META_AUTHOR_NAME,\n  DEFAULT_META_AUTHOR_URL,\n  DEFAULT_META_DESCRIPTION,\n  DEFAULT_META_TITLE,\n} from './constant';\n\nimport fetch from 'node-fetch';\n\nconst master = {\n  name: DEFAULT_META_AUTHOR_NAME,\n  email: DEFAULT_META_AUTHOR_EMAIL,\n  link: DEFAULT_META_AUTHOR_URL,\n};\n\nconst feed = new Feed({\n  title: DEFAULT_META_TITLE,\n  description: DEFAULT_META_DESCRIPTION,\n  id: DEFAULT_META_AUTHOR_URL,\n  link: DEFAULT_META_AUTHOR_URL,\n  language: 'ko',\n  image: '',\n  favicon: '',\n  copyright: '',\n  generator: 'generate-rss',\n  feedLinks: {\n    json: `${BASE_URL}/feed.json`,\n    atom: `${BASE_URL}/rss-atom.xml`,\n    rss: `${BASE_URL}/rss.xml`,\n  },\n  author: master,\n});\n\nconst getAllPostData = async () => {\n  const data = await fetch(`${BASE_URL}/api/post/all`, {\n    method: 'GET',\n  });\n\n  const jsonData: any = await data.json();\n  jsonData.data.forEach((json: JsonPost) => {\n    feed.addItem({\n      title: json.title,\n      id: json.currentPostId,\n      link: `${BASE_URL}/${json.currentPostId}`,\n      description: json.description,\n      content: json.content.toString(),\n      author: [master],\n      contributor: [master],\n      date: new Date(json.date),\n      // image: post.image,\n      category: json.tags.split(' ').map((tag: string) => ({ name: tag })),\n    });\n  });\n\n  // Output: RSS 2.0\n  writeFileSync('public/rss.xml', feed.rss2(), 'utf-8');\n  // Output: Atom 1.0\n  writeFileSync('public/rss-atom.xml', feed.atom1(), 'utf-8');\n  // Output: JSON Feed 1.0\n  writeFileSync('public/feed.json', feed.json1(), 'utf-8');\n};\n\ngetAllPostData();\nfeed.addCategory('Technologies');\n\ntype JsonPost = {\n  currentPostId: string;\n  title: string;\n  description: string;\n  date: string;\n  tags: string;\n  content: string;\n};\n</code></pre>\n<blockquote>\n<p>feed 변수는 변하지 rss,atom,json-feed를 생성하는데 공통으로 사용되는 상수이다.</p>\n</blockquote>\n<blockquote>\n<p>getAllPostData 함수는 모든 포스트 데이터를 가져와서 feed에 추가하는 함수이다.</p>\n</blockquote>\n<blockquote>\n<p>getAllPostData 함수 안에서 rss, atom, json-feed를 생성하는 각각 메서드를 실행하여 파일로 저장한다.</p>\n</blockquote>\n<blockquote>\n<p>파일의 생성 경로는 public 폴더이며, public에 생성된 파일은 추후 {도메인}/rss.xml, {도메인}/rss-atom.xml, {도메인}/feed.json으로 접근이 가능하다.</p>\n</blockquote>\n<h2>빌드 및 파일 생성</h2>\n<p>packacge.json에 아래 스크립트를 추가한다.</p>\n<pre><code class=\"language-json\">{\n  \"rss\": \"ts-node --project tsconfig.node.json ./src/generate-rss.ts\",\n  \"build\": \"next build &#x26;&#x26; yarn rss\"\n}\n</code></pre>\n<p>로컬에서 <code>yarn rss</code> 커맨드를 실행하면 <code>public</code> 폴더에 <code>rss.xml</code>, <code>rss-atom.xml</code>, <code>feed.json</code> 파일이 생성되는 것을 확인 할 수 있다.</p>\n<p>로컬에서 생성하지 않아도 <code>vercel</code>에 배포시 자동으로 <code>rss</code>도 빌드가 되도록 스크립트를 추가해두었다.</p>\n<h2>결과확인</h2>\n<p><a href=\"https://www.nostrss.me/rss.xml\">📌 rss 확인하기 📌</a></p>\n<p><a href=\"https://www.nostrss.me/rss-atom.xml\">📌 rss-atom 확인하기 📌</a></p>\n<p><a href=\"https://www.nostrss.me/feed.json\">📌 feed.json 확인하기 📌</a></p>\n<p>모두 정상적으로 생성되었음을 확인 할 수 있다.</p>\n<p>실제 위의 feed를 구독할 때도 잘 보이는지 Rss 리더를 통해 확인해야겠다.</p>\n<p><code>feedly</code>라는 rss 리더를 사용해서 구독해보았다.</p>\n<p><a href=\"https://feedly.com/\">📌 feedly 바로가기 📌</a></p>\n<blockquote>\n<p>된다!! 아주 잘나온다!!</p>\n</blockquote>",
            "url": "https://nostrss.me/168-rss-atom-json",
            "title": "블로그도 구독이 가능하다",
            "summary": "Next.js 블로그에 RSS, Atom, JSON Feed를 추가하기",
            "date_modified": "2023-09-20T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "next",
                "blog",
                "rss",
                "atom",
                "json-feed"
            ]
        },
        {
            "id": "167-webpack-typescript",
            "content_html": "<p>처음 프론트엔드를 배울때 React로 배우고 계속 사용하다보니 리액트 없이는 프론트엔드를 할 수 없는 느낌이 들었다. 그래서 리액트를 벗어나 순수한 프로젝트를 만들어보고 싶었다. 바닐라 자바스크립트에 타입스크립트만 추가한 템플릿을 만들어보았다.</p>\n<p><a href=\"https://github.com/nostrss/webpack-template\">📌 깃허브에서 소스코드 보기 📌</a></p>\n<h2>npm init</h2>\n<p>먼저 폴더를 생성하고 <code>npm init</code>을 실행해준다.</p>\n<p>몇가지 질문이 진행되고 완료되면 <code>package.json</code>이 생성되게 된다.</p>\n<h2>테스트를 위한 파일 생성</h2>\n<pre><code>📦src\n ┣ 📜about.html\n ┣ 📜about.js\n ┣ 📜index.html\n ┣ 📜index.ts\n ┣ 📜style.css\n ┗ 📜word.js\n</code></pre>\n<p>웹팩을 설치하고 빌드하기 전에 테스트를 위한 파일들을 위와 같이 생성해주었다.</p>\n<h2>웹팩 설치(v5)</h2>\n<p><a href=\"https://webpack.kr/guides/getting-started/#creating-a-bundle\">📌 웹팩 공식문서 바로가기 📌</a></p>\n<pre><code class=\"language-bash\">npm install webpack webpack-cli --save-dev\n</code></pre>\n<h2>webpack.config.js 기본 설정하기</h2>\n<pre><code class=\"language-js\">const path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: { index: '/src/index.ts', about: '/src/about.js' },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js',\n  },\n};\n</code></pre>\n<h3>mode</h3>\n<p><a href=\"https://webpack.kr/configuration/mode/#root\">📌 웹팩 Mode 문서 바로가기 📌</a></p>\n<p>mode의 경우 Default로는 production으로 설정되어 있다.</p>\n<p>production 모드의 경우 최적화가 되어 빌드가 되며, 이로 인해 빌드파일의 크기가 development 모드에 비해 작아진다.</p>\n<p>production과 development의 빌드 결과는 아래와 같은 차이가 있다.</p>\n<blockquote>\n<p>development 인 경우</p>\n</blockquote>\n<p>사람이 조금은 알아볼 수 있는 형태로 빌드가 된다.</p>\n<ul>\n<li>production 인 경우</li>\n</ul>\n<p>사람이 알아볼 수 없을 정도로 최적화가 되어 빌드가 된다.</p>\n<h3>Entry Points</h3>\n<p><a href=\"https://webpack.kr/concepts/entry-points/#root\">📌 웹팩 Entry Points 문서 바로가기 📌</a></p>\n<p>webpack이 빌드할 파일을 지정해주는 부분이다.</p>\n<p>테스트로 파일을 2개 생성했기 때문에 2개의 파일을 지정해주었다.</p>\n<h3>Output</h3>\n<p><a href=\"https://webpack.kr/concepts/output/\">📌 웹팩 Output 문서 바로가기 📌</a></p>\n<p>빌드된 파일을 어디에 어떻게 저장할지 지정해주는 부분이다.</p>\n<p><code>path</code>는 빌드된 파일을 저장할 경로를 지정해주고, <code>filename</code>은 빌드된 파일의 이름을 지정해준다.</p>\n<p><code>filename</code>의 경우 <code>[name]</code>을 사용하면 <code>entry</code>에 지정한 Key값(index, about)을 파일명으로 빌드하게 된다.</p>\n<p>다만 이렇게 빌드하여 배포가 될 경우, 빌드 결과 파일의 이름이 기존과 동일하기 브라우저 캐쉬로 인해 변경사항이 유저에게 전달되지 않았던 경험이 있다.</p>\n<p>그래서 아래와 같이 다시 수정해서 빌드를 해봤다.</p>\n<pre><code class=\"language-js\">const path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: { index: '/src/index.ts', about: '/src/about.js' },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash].js',\n  },\n};\n</code></pre>\n<p>빌드할 때 마다 <code>hash</code> 값이 계속 달라지게 되고 브라우저에서는 이전과 파일명이 다르기 때문에 캐쉬를 사용하지 않고 새로 빌드된 파일을 사용하게 된다.</p>\n<h2>문제점</h2>\n<p>js파일은 빌드가 되는 것은 확인이 되었다.</p>\n<p>그리고 js파일을 html과 연결 후 브라우저를 통해 확인해보니 정상적으로 보인다.</p>\n<p>하지만 몇가지 문제점이 보였다.</p>\n<ol>\n<li>\n<p>CSS 파일이 별도로 로딩이 되고 있었다.\n</p>\n</li>\n<li>\n<p>js파일을 html에 연결해야하는 번거로움이 있다.</p>\n</li>\n</ol>\n<ul>\n<li>현업에서 만약 이렇게 사용하면 빌드 후 배포할때, 빌드 할때마다 HTML파일에 새로 생성된 js파일을 HTML에 연결해주는 번거로움이 존재한다.</li>\n</ul>\n<p>하나씩 해결해보자.</p>\n<h2>Loader를 사용하여 CSS를 JS파일과 함께 빌드하고 DOM에 반영하기</h2>\n<p><a href=\"https://webpack.kr/concepts/loaders/\">📌 웹팩 로더 문서 바로가기 📌</a></p>\n<p>이를 위해 2개의 패키지를 추가로 설치해주자.</p>\n<pre><code class=\"language-bash\">npm install css-loader style-loader -D\n</code></pre>\n<p>그리고 <code>webpack.config.js</code>를 아래와 같이 수정했다.</p>\n<pre><code class=\"language-js\">const path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: { index: '/src/index.js', about: '/src/about.js' },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // injects the css into the DOM\n          { loader: 'style-loader' },\n          // translates CSS into JS\n          {\n            loader: 'css-loader',\n          },\n        ],\n      },\n    ],\n  },\n};\n</code></pre>\n<p>그리고 다시 빌드 후 HTML 파일에 link css를 삭제하고 빌드 파일을 연결해 주었다.</p>\n<p>결과물도 정상적으로 나오고 이제는 css 파일을 별도로 로딩하지 않는 것을 확인할 수 있었다.</p>\n<h2>Plugins를 이용해 html 파일 생성하기</h2>\n<p><a href=\"https://webpack.kr/plugins/html-webpack-plugin/\">📌 웹팩 HtmlWebpackPlugin 문서 바로가기 📌</a></p>\n<p>현재 js파일에 css를 추가하여 빌드하는 것까지는 성공했다.</p>\n<p>이제 빌드시 html파일을 생성하고 여기에 js파일을 자동으로 연결해주는 작업을 해보자. 이를 위해 아래의 패키지를 설치해 주자.</p>\n<pre><code class=\"language-bash\">npm install -D html-webpack-plugin\n</code></pre>\n<p>그리고 webpack.config.js를 아래와 같이 수정해주자.</p>\n<pre><code class=\"language-js\">const path = require('path');\n// ----> 추가\nconst HtmlWepackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: { index: '/src/index.js', about: '/src/about.js' },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // injects the css into the DOM\n          { loader: 'style-loader' },\n          // translates CSS into JS\n          {\n            loader: 'css-loader',\n          },\n        ],\n      },\n    ],\n  },\n  // ----> 추가\n  plugins: [\n    new HtmlWepackPlugin({\n      template: './src/index.html',\n      filename: './index.html',\n      chunks: ['index'],\n    }),\n    new HtmlWepackPlugin({\n      template: './src/about.html',\n      filename: './about.html',\n      chunks: ['about'],\n    }),\n  ],\n};\n</code></pre>\n<p>그리고 html파일에서 js파일을 추가해주는 script를 삭제해주자.</p>\n<blockquote>\n<p>즉 이제 html파일에 css와 js파일을 link, script로 삽입해주지 않아도 된다.</p>\n</blockquote>\n<p>이제 빌드를 해보자.</p>\n<p>dist 폴더 안에 html파일이 함께 생성된 것을 볼 수 있다.</p>\n<h2>Typescript 설정하기</h2>\n<p><a href=\"https://webpack.kr/guides/typescript/\">📌 웹팩 Typescript 문서 바로가기 📌</a></p>\n<p>나는 타입스크립트를 사용할 것이기 때문에 또 추가적인 설정이 필요하다.</p>\n<p>일단 나는 타입스크립트가 글로벌로 설치가 되어 있기 때문에 아래의 패키지만 설치를 해주었다.</p>\n<pre><code class=\"language-bash\">npm install -D ts-loader\n</code></pre>\n<p>설치 후에는 tsconfig.json 파일을 아래와 같이 생성해주었다.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/\",\n    \"noImplicitAny\": true,\n    \"module\": \"es6\",\n    \"target\": \"es5\",\n    \"jsx\": \"react\",\n    \"allowJs\": true,\n    \"moduleResolution\": \"node\"\n  }\n}\n</code></pre>\n<p>타입스크립트 파일이 빌드가 되는지 테스트를 위해 indext.js파일의 확장자를 indext.ts로 변경해주었다.</p>\n<p>그리고 webpack.config.js를 아래와 같이 수정해주었다.</p>\n<pre><code class=\"language-js\">const path = require('path');\nconst HtmlWepackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  // ----> ts 파일로 수정\n  entry: { index: '/src/index.ts', about: '/src/about.js' },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // injects the css into the DOM\n          { loader: 'style-loader' },\n          // translates CSS into JS\n          {\n            loader: 'css-loader',\n          },\n        ],\n      },\n      // ----> 추가\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  // ----> 추가\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  plugins: [\n    new HtmlWepackPlugin({\n      template: './src/index.html',\n      filename: './index.html',\n      chunks: ['index'],\n    }),\n    new HtmlWepackPlugin({\n      template: './src/about.html',\n      filename: './about.html',\n      chunks: ['about'],\n    }),\n  ],\n};\n</code></pre>\n<p>빌드를 해보니 이전과 동일하게 정상적으로 빌드가 성공하는 것을 확인할 수 있었다.</p>\n<h2>빌드시 이전 결과물 삭제하기</h2>\n<p>이제 기본적인 설정은 끝난 것 같다.</p>\n<p>그러나 빌드할 때마다 hash값이 변하다 보니 빌드 결과물에 이전 js파일들이 남아 있는 것을 확인할 수 있었다.</p>\n<p>이건 추가 설정으로 간단히 해결 할 수 있었다.</p>\n<pre><code class=\"language-js\">output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash].js',\n    // ----> 추가\n    clean: true,\n  },\n</code></pre>\n<p>위와 같이 clean 옵션을 추가해주면 빌드시 이전 결과물을 삭제해준다.</p>\n<p>이렇게 만들고 나니 기존의 react가 얼마나 편한 라이브러리인지 체감하게 됐다.</p>\n<p>위의 설정등을 하지 않고 바로 최적화 빌드가 가능한 지금, 과거 프론트엔드 개발자들은 얼마나 힘들게 개발을 했을까 싶다.</p>",
            "url": "https://nostrss.me/167-webpack-typescript",
            "title": "리액트를 벗어나 순수한 프로젝트를 만들어보자",
            "summary": "바닐라 타입스크립트에 웹팩을 설정한 템플릿 만들기",
            "date_modified": "2023-09-19T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "javascript",
                "typescript",
                "webpack"
            ]
        },
        {
            "id": "166-curring-function",
            "content_html": "<p>커링함수란 여러개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인처럼 연결하는 것을 말한다.</p>\n<p>그렇기 때문에 원칙적으로 하나의 파라미터만을 전달하는 것을 원칙으로 한다.</p>\n<h2>커링함수의 예시 살펴보기</h2>\n<pre><code class=\"language-js\">const curry3 = function (func) {\n  return function (a) {\n    return function (b) {\n      return func(a, b);\n    };\n  };\n};\n\nconst getMaxWith10 = curry3(Math.max)(100);\nconsole.log(getMaxWith10(51)); // 100\nconsole.log(getMaxWith10(122)); // 122\n</code></pre>\n<p>위의 코드는 커링함수의 예시이다. 함수를 인자로 받고, 후속으로 받는 인자 2개에 대해 인자로 받은 함수를 실행한 값을 리턴한다.</p>\n<p>위의 코드 실행과정을 아래와 같이 정리해봤다.</p>\n<ol>\n<li><code>curry3(Math.max)</code> : 아래의 익명함수를 리턴한다.</li>\n</ol>\n<pre><code>ƒ (a) {\n    return function (b) {\n      return Math.max(a, b);\n    };\n}\n</code></pre>\n<ol start=\"2\">\n<li><code>curry3(Math.max)(100)</code> : 위의 익명함수를 실행하고 새로운 익명함수를 리턴한다.</li>\n</ol>\n<pre><code>ƒ (b) {\n  return Math.max(100, b);\n}\n\n</code></pre>\n<ol start=\"3\">\n<li><code>const getMaxWith10 = curry3(Math.max)(100)</code></li>\n</ol>\n<ul>\n<li>위의 익명함수가 getMaxWith10에 할당된다.</li>\n</ul>\n<ol start=\"4\">\n<li><code>getMaxWith10(51)</code></li>\n</ol>\n<ul>\n<li>getMaxWith10이 실행되고, 51이 인자로 전달되고, Math.max(100, 51)이 실행된다.</li>\n</ul>\n<pre><code>ƒ (51) {\n  return Math.max(100, 51);\n}\n</code></pre>\n<h2>커링함수와 화살표 함수</h2>\n<p>위의 커링함수의 인자가 많아지거나, 길이가 길어지면 가독성이 떨어지는 단점이 있다. 이때 아래와 같이 화살표 함수를 사용하면 가독성을 높일 수 있다.</p>\n<pre><code class=\"language-js\">const curry3 = (func) => (a) => (b) => func(a, b);\n</code></pre>\n<h2>커링함수 언제? 왜 사용하는가?</h2>\n<p>커링함수는 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들오면 전달하는 방식으로 사용할 수가 있다.</p>\n<p>이를 함수형 프로그래밍에서는 <code>지연 실행(lazy execution)</code>이라고 한다.</p>\n<p><code>React</code>에서 실제로 위의 커링함수를 언제 사용할 수 있을지 고민을 해봤다.</p>\n<pre><code class=\"language-js\">// 커링함수를 사용하지 않은 경우\nconst getInformation = (baseUrl, path, id) => fetch(`${baseUrl}${path}/${id}`);\n\n// 커링함수\nconst getInformation = (baseUrl) => (path) => (id) =>\n  fetch(`${baseUrl}${path}/${id}`);\n</code></pre>\n<p>위의 코드는 api를 호출하는 함수이다. 커링을 사용한 경우와 사용하지 않은 경우 결과값을 동일할 것이다.</p>\n<p>이것만 봐서는 커링을 사용하는 명확한 가치를 느끼지는 못하겠다.</p>\n<p>하지만 과거 공부했던 <code>HOC(Higher Order Component)</code>의 개념과 커링은 매우 비슷하게 느껴진다.</p>\n<p>커링은 프로젝트에서 내가 실제로 의도해서 사용해본적은 없는 것 같다.</p>\n<p>이후 프로젝트에서 커링을 사용해볼 수 있는 기회가 생긴다면 사용해보면서 익혀가야 할 것 같다.</p>",
            "url": "https://nostrss.me/166-curring-function",
            "title": "들어는 봤니? 커링함수(currying function)",
            "summary": "근데 React에서 커링함수는 언제 사용해야 할까?",
            "date_modified": "2023-09-18T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "javascript",
                "currying",
                "function"
            ]
        },
        {
            "id": "164-next-darkmode-toggle",
            "content_html": "<p>네이버도 그렇고 요새 많은 사이트들이 <code>다크모드</code>를 지원하고 있다.</p>\n<p>나도 웹페이지를 볼때 다크모드를 선호하는 편인지라 다크모드를 적용하려고 한다.</p>\n<p>내가 원하는 다크모드의 기능은 다음과 같다.</p>\n<ul>\n<li>최초 접속 시에는 유저의 OS 다크모드 설정을 따른다.</li>\n<li>유저가 버튼을 클릭시 모드가 변경이 된다.</li>\n<li>변경된 모드가 다음에 접속시에도 유지가 된다.</li>\n</ul>\n<h2>유저의 OS 다크모드 설정을 따르기</h2>\n<p>유저의 OS 다크모드 설정을 따르기 위해서는 <code>window.matchMedia</code>를 사용하면 된다.</p>\n<p>코드를 살펴보자.</p>\n<pre><code class=\"language-tsx\">export default function DarkModeToggle() {\n  const [isDark, setIsDark] = useState(false);\n  const path = usePathname();\n\n  useEffect(() => {\n    initializeDarkMode();\n  }, [path]);\n\n  const initializeDarkMode = () => {\n    const savedMode = COOKIE.getCookie(MODE_COOKIE_NAME);\n    const prefersDarkMode = window.matchMedia(\n      `(prefers-color-scheme: ${DARK_MODE})`\n    ).matches;\n    const initialMode = savedMode || (prefersDarkMode ? DARK_MODE : LIGHT_MODE);\n\n    setIsDark(initialMode === DARK_MODE);\n    changeColorScheme(initialMode);\n    COOKIE.setCookie(MODE_COOKIE_NAME, initialMode, 720);\n  };\n\n  return (\n    &#x3C;>\n      &#x3C;button title={isDark ? '일반모드로 변경' : '다크모드로 변경'}>\n        {isDark ? &#x3C;SunnyIcon color='white' /> : &#x3C;NightIcon />}\n      &#x3C;/button>\n    &#x3C;/>\n  );\n}\n\nconst changeColorScheme = (mode: string) => {\n  const colorScheme = document.querySelector('meta[name=\"color-scheme\"]');\n  colorScheme?.setAttribute('content', mode);\n\n  if (mode === DARK_MODE) {\n    document.documentElement.classList.add(DARK_MODE);\n    document.documentElement.classList.remove(LIGHT_MODE);\n  } else {\n    document.documentElement.classList.add(LIGHT_MODE);\n    document.documentElement.classList.remove(DARK_MODE);\n  }\n};\n</code></pre>\n<blockquote>\n<p>브라우저에서 작동해야 하기 때문에 최상단에 'use client'를 선언해주어야 한다.</p>\n</blockquote>\n<blockquote>\n<p>모드 초기화를 위해 initializeDarkMode라는 함수를 만들고 useEffect를 통해 최초 실행시켜줬다.</p>\n</blockquote>\n<blockquote>\n<p>initializeDarkMode 함수에서는 쿠키에 저장된 모드가 있는지 확인하고 없다면 유저의 OS 다크모드 설정을 확인한다.</p>\n</blockquote>\n<blockquote>\n<p>초기화 된 모드를 쿠키에 저장한다.</p>\n</blockquote>\n<blockquote>\n<p>초기화 된 모드에 따라 Icon을 변경해준다.</p>\n</blockquote>\n<blockquote>\n<p>초기화 된 모드에 따라 documentElement에 클래스를 추가해준다.</p>\n</blockquote>\n<h2>버튼 클릭시 모드 변경처리</h2>\n<pre><code class=\"language-tsx\">const chageModeInvert = () => {\n  const currentMode = document\n    .querySelector('meta[name=\"color-scheme\"]')\n    ?.getAttribute('content');\n  const newMode = currentMode === DARK_MODE ? LIGHT_MODE : DARK_MODE;\n\n  setIsDark(newMode === DARK_MODE);\n  changeColorScheme(newMode);\n  COOKIE.setCookie(MODE_COOKIE_NAME, newMode, 720);\n};\n</code></pre>\n<p>위의 함수는 버튼 클릭시 모드를 변경해주는 함수이다.이걸 버튼의 <code>onClick</code>에 넣어주면 된다.</p>\n<p><img src=\"https://github.com/nostrss/next13-blog/assets/56717167/3044f7e6-6bfb-409e-9831-bff5baed05f2\" alt=\"화면-기록-2023-09-15-오후-7 24 06\"></p>",
            "url": "https://nostrss.me/164-next-darkmode-toggle",
            "title": "Next.js 다크모드 적용하기",
            "summary": "요새 많이 사용하는 다크모드를 적용해보자.",
            "date_modified": "2023-09-11T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "next",
                "darkmode",
                "toggle"
            ]
        },
        {
            "id": "163-next-metadata",
            "content_html": "<p>작성된 블로그를 다른 개발자들이 볼 수 있도록 하려면 SEO 최적화라는 작업을 해야한다.</p>\n<p>대단한 건 아니고 구글같은 검색엔진에서 검색시 노출이 잘 될 수 있도록 웹사이트의 정보를 제공하는 것이다.</p>\n<h2>NEXT에서의 메타데이터 삽입</h2>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/optimizing/metadata\">Next.js metadata 공식문서 바로가기</a>를 참고하여 작성했다.</p>\n<p>Next에서는 메타데이터 추가를 위해 2가지 방법을 제공한다.</p>\n<ul>\n<li>Static Metadata</li>\n<li>Dynamic Metadata</li>\n</ul>\n<p>하나씩 살펴 보도록 하겠다.</p>\n<h2>Static Metadata</h2>\n<p>Static Metadata는 아래와 같이 <code>layout.js</code> 파일에 생성할 메타데이터 객체를 생성하면 된다.</p>\n<pre><code class=\"language-tsx\">import type { Metadata } from 'next';\n\nexport const metadata: Metadata = {\n  title: '...',\n  description: '...',\n};\n\nexport default function Page() {}\n</code></pre>\n<p>대신 이렇게 생성된 메타데이터는 정적 데이터로 변하지 않는다.</p>\n<p>그래서 <code>dynamic router</code>를 사용한 페이지에서 계속 변하는 <code>title, description</code>을 메타데이터에 적용할 수 는 없다. 만약 동적으로 변하는 메타데이터를 적용하고 싶다면 <code>Dynamic Metadata</code>를 사용해야 한다.</p>\n<h2>Dynamic Metadata</h2>\n<p>위에서 말한 것처럼 metadata에 계속 변하는 정보가 있다면, 아래처럼 <code>generateMetadata</code>함수를 사용해야 한다.</p>\n<pre><code class=\"language-tsx\">import type { Metadata, ResolvingMetadata } from 'next';\n\ntype Props = {\n  params: { id: string };\n  searchParams: { [key: string]: string | string[] | undefined };\n};\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise&#x3C;Metadata> {\n  // read route params\n  const id = params.id;\n\n  // fetch data\n  const product = await fetch(`https://.../${id}`).then((res) => res.json());\n\n  // optionally access and extend (rather than replace) parent metadata\n  const previousImages = (await parent).openGraph?.images || [];\n\n  return {\n    title: product.title,\n    openGraph: {\n      images: ['/some-specific-page-image.jpg', ...previousImages],\n    },\n  };\n}\n\nexport default function Page({ params, searchParams }: Props) {}\n</code></pre>\n<p>각 페이지에 맞는 메타데이터 객체를 return 값으로 넘겨 주면된다.</p>\n<p>이때 메타데이터 객체는 아래와 같은 형태로 구성되어 있다.</p>\n<pre><code class=\"language-ts\">interface ResolvedMetadata extends DeprecatedMetadataFields {\n  metadataBase: null | URL;\n  title: null | AbsoluteTemplateString;\n  description: null | string;\n  applicationName: null | string;\n  authors: null | Array&#x3C;Author>;\n  generator: null | string;\n  keywords: null | Array&#x3C;string>;\n  referrer: null | ReferrerEnum;\n  themeColor: null | ThemeColorDescriptor[];\n  colorScheme: null | ColorSchemeEnum;\n  viewport: null | string;\n  creator: null | string;\n  publisher: null | string;\n  robots: null | ResolvedRobots;\n  alternates: null | ResolvedAlternateURLs;\n  icons: null | ResolvedIcons;\n  openGraph: null | ResolvedOpenGraph;\n  manifest: null | string | URL;\n  twitter: null | ResolvedTwitterMetadata;\n  verification: null | ResolvedVerification;\n  appleWebApp: null | ResolvedAppleWebApp;\n  formatDetection: null | FormatDetection;\n  itunes: null | ItunesApp;\n  abstract: null | string;\n  appLinks: null | ResolvedAppLinks;\n  archives: null | Array&#x3C;string>;\n  assets: null | Array&#x3C;string>;\n  bookmarks: null | Array&#x3C;string>;\n  category: null | string;\n  classification: null | string;\n  other:\n    | null\n    | ({\n        [name: string]: string | number | Array&#x3C;string | number>;\n      } &#x26; DeprecatedMetadataFields);\n}\n</code></pre>\n<p>상당히 많은 값을 지원하는데, 자세한 내용은 Next.js 공식문서를 참고하여 추가해주면 된다.</p>\n<h2>실제 적용 코드</h2>\n<h3>src/app/layout.tsx</h3>\n<pre><code class=\"language-tsx\">export const metadata: Metadata = {\n  ...defaultMetaData,\n};\n</code></pre>\n<h3>src/defaultMetaData.ts</h3>\n<pre><code class=\"language-ts\">import { Metadata } from 'next';\nimport {\n  BASE_URL,\n  DEFAULT_APP_NAME,\n  DEFAULT_GENERATOR,\n  DEFAULT_META_AUTHOR_NAME,\n  DEFAULT_META_AUTHOR_URL,\n  DEFAULT_META_DESCRIPTION,\n  DEFAULT_META_KEYWORDS,\n  DEFAULT_META_TITLE,\n  DEFAULT_OG_IMAGE_URL,\n  DEFAULT_REFERRER,\n  LIGHT_MODE,\n  RSS_ATOM_URL,\n  RSS_JSON_URL,\n  RSS_XML_URL,\n} from './constant';\n\nexport const defaultMetaData: Metadata = {\n  title: {\n    template: `%s | ${DEFAULT_META_TITLE}`,\n    default: DEFAULT_META_TITLE,\n  },\n  description: DEFAULT_META_DESCRIPTION,\n  generator: DEFAULT_GENERATOR,\n  applicationName: DEFAULT_APP_NAME,\n  referrer: DEFAULT_REFERRER,\n  keywords: DEFAULT_META_KEYWORDS,\n  authors: {\n    name: DEFAULT_META_AUTHOR_NAME,\n    url: DEFAULT_META_AUTHOR_URL,\n  },\n\n  colorScheme: LIGHT_MODE,\n  creator: DEFAULT_META_AUTHOR_NAME,\n  publisher: DEFAULT_META_AUTHOR_NAME,\n  formatDetection: {\n    email: true,\n    address: false,\n    telephone: false,\n  },\n  metadataBase: new URL(BASE_URL),\n  alternates: {\n    canonical: BASE_URL,\n    types: {\n      'application/rss+xml': RSS_XML_URL,\n      'application/atom+xml': RSS_ATOM_URL,\n      'application/json': RSS_JSON_URL,\n    },\n  },\n  openGraph: {\n    title: `${DEFAULT_META_TITLE}`,\n    description: `${DEFAULT_META_DESCRIPTION}`,\n    url: BASE_URL,\n    siteName: `${DEFAULT_APP_NAME}`,\n    images: [\n      {\n        url: DEFAULT_OG_IMAGE_URL,\n        width: 1500,\n        height: 855,\n      },\n      {\n        url: DEFAULT_OG_IMAGE_URL,\n        width: 1500,\n        height: 855,\n        alt: DEFAULT_META_TITLE,\n      },\n    ],\n    locale: 'ko_KR',\n    type: 'website',\n  },\n  robots: {\n    index: false,\n    follow: true,\n    nocache: true,\n    googleBot: {\n      index: true,\n      follow: false,\n      noimageindex: true,\n      'max-video-preview': -1,\n      'max-image-preview': 'large',\n      'max-snippet': -1,\n    },\n  },\n  icons: {\n    icon: '/icon.png',\n    apple: '/apple-icon.png',\n  },\n  twitter: {\n    card: 'summary_large_image',\n    title: `${DEFAULT_META_TITLE} | twitter`,\n    description: `${DEFAULT_META_DESCRIPTION} | twitter`,\n  },\n};\n</code></pre>\n<h3>src/app/blog/[slug]/page.tsx</h3>\n<p>RootLayout과 다른 메타데이터가 필요한 정보만 객체로 return 해주면 된다.</p>\n<pre><code class=\"language-tsx\">export async function generateMetadata({\n  params: { slug },\n}: {\n  params: { slug: string };\n}) {\n  const { data } = await API.fetchBlogDetail(slug);\n  return {\n    title: data.title,\n    description: data.description || data.title,\n    keywords: data.tags.split(' '),\n    alternates: {\n      canonical: `${BASE_URL}/${slug}`,\n    },\n    openGraph: {\n      title: `${data.title}`,\n      description: `${data.description || data.title}`,\n      url: `${BASE_URL}/${slug}`,\n      alternates: {\n        canonical: `${BASE_URL}/${slug}`,\n      },\n      images: [\n        {\n          url:\n            data.images?.length > 0 ? data.images[0].url : DEFAULT_OG_IMAGE_URL,\n          width: 1550,\n          height: 800,\n        },\n        {\n          url:\n            data.images?.length > 0 ? data.images[0].url : DEFAULT_OG_IMAGE_URL,\n          width: 1550,\n          height: 800,\n          alt: data.title,\n        },\n      ],\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: `${data.title} | twitter_page`,\n      description: `${data.description || data.title} | twitter_page`,\n    },\n  };\n}\n</code></pre>\n<h2>결과 확인</h2>\n<blockquote>\n<p>크롬 개발자 도구로 확인</p>\n</blockquote>\n<blockquote>\n<p>카카오톡 og-image 확인</p>\n</blockquote>\n<blockquote>\n<p>카카오톡 dynamic metadata og-image 확인</p>\n</blockquote>",
            "url": "https://nostrss.me/163-next-metadata",
            "title": "Next.js meatadata 적용하기",
            "summary": "SEO 최적화를 위한 메타데이터 생성하기",
            "date_modified": "2023-09-10T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "next",
                "markdown",
                "view"
            ]
        },
        {
            "id": "162-markdown-view",
            "content_html": "<p>이제 블로그 본문의 상세페이지를 꾸밀 차례다.</p>\n<p>마크다운 파일 컨텐츠를 바로 렌더링 할 경우 마크다운 문법이 적용이 되어 보이질 않는다.</p>\n<p>그렇기 때문에 다른 패키지를 사용하여 보여줄 생각이다.</p>\n<h2>react-markdown 적용하기</h2>\n<p><a href=\"https://www.npmjs.com/package/react-markdown\">react-markdown 바로가기</a></p>\n<p>위의 패키지를 설치하고, 아래와 같이 사용하면 된다.</p>\n<pre><code class=\"language-tsx\">'use client';\nimport ReactMarkdown from 'react-markdown';\n\nxport default function MarkDownViewer({ content }: { content: string }) {\n  return (\n    &#x3C;ReactMarkdown>{content}&#x3C;/ReactMarkdown>\n  );\n}\n</code></pre>\n<p>설치 후 이렇게 마크다운 정보를 <code>children</code>으로 넘겨주기만 하면 끝이다.</p>\n<p><code>npm</code> 페이지에서 <code>react</code>로 예시로는 <code>Props</code>로 넘겨주도록 되어 있었는데, 에러가 발생해서 위와 같이 <code>children</code>으로 넘겨주었다.</p>\n<h2>remarkGfm 적용하기</h2>\n<p>그런데 결과물이 조금은 부족해보인다.</p>\n<p>기존에 <code>github</code>에서 보던 마크다운과는 다소 다르게 보인다.</p>\n<p>왜냐하면 우리가 github에서 보던 마크다운은 표준이 아니기 때문이다. <code>github</code>에서 보는 마크다운은 <code>github</code>에서 자체적으로 추가한 문법들이 추가되어 있다.</p>\n<p>그렇기 때문에 평소 깃허브와 동일하게 보이게 하려면 별도의 <code>plugin</code>을 이용해야 한다.</p>\n<p>이때 사용할 수 있는 플러그인으로 <code>remarkGfm</code>이 있다.</p>\n<p>여기서 <code>GFM</code>은 <code>Github Flavored Markdown</code>의 약자이며 이에 해당하는 문법은 아래와 같다.</p>\n<ul>\n<li>autolink literals</li>\n<li>footnotes</li>\n<li>strikethrough</li>\n<li>tables</li>\n<li>tasklists.</li>\n</ul>\n<p><a href=\"https://www.npmjs.com/package/remark-gfm\">remarkGfm 바로가기</a></p>\n<p><code>remarkGfm</code>을 <code>react-markdown</code>에 적용하는 방법은 아래와 같다.</p>\n<pre><code class=\"language-tsx\">'use client';\nimport ReactMarkdown from 'react-markdown';\n\nexport default function MarkDownViewer({ content }: { content: string }) {\n  return &#x3C;ReactMarkdown remarkPlugins={[remarkGfm]}>{content}&#x3C;/ReactMarkdown>;\n}\n</code></pre>\n<p>위와 같이 추가하고 결과물을 확인해봤다.</p>\n<p>약간의 변화가 있었지만, 여전히 부족해보인다.</p>\n<h2>CSS 커스텀하기</h2>\n<p>조금 더 이쁘게 보이게 하기 위해 <code>syntax-highlighting</code>을 적용해서 코드블럭 CSS를 수정해볼 생각이다.</p>\n<p><a href=\"https://www.npmjs.com/package/react-syntax-highlighter\">react-syntax-highlighter 바로가기</a></p>\n<p>코드블럭은 <code>&#x3C;code>&#x3C;/code></code> 태그이므로 아래와 같이 작성해줬다.</p>\n<pre><code class=\"language-tsx\">'use client';\n\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { materialDark } from 'react-syntax-highlighter/dist/esm/styles/prism';\n\nexport default function MarkDownViewer({ content }: { content: string }) {\n  return (\n    &#x3C;ReactMarkdown\n      remarkPlugins={[remarkGfm]}\n      components={{\n        code({ node, inline, className, children, ...props }) {\n          const match = /language-(\\w+)/.exec(className || '');\n\n          return !inline &#x26;&#x26; match ? (\n            &#x3C;SyntaxHighlighter\n              {...props}\n              style={materialDark}\n              language={match[1]}\n              PreTag='article'\n              showLineNumbers={true}\n            >\n              {String(children).replace(/\\n$/, '')}\n            &#x3C;/SyntaxHighlighter>\n          ) : (\n            &#x3C;code {...props} className={className}>\n              {children}\n            &#x3C;/code>\n          );\n        },\n      }}\n    >\n      {content}\n    &#x3C;/ReactMarkdown>\n  );\n}\n</code></pre>\n<p><code>ReactMarkdown</code> 은 <code>components</code>라는 <code>props</code>를 받을 수 있는데, 이것을 통해 커스터마이징을 할 수 있다.</p>\n<p>그리고 아래와 같이 코드블럭 부분이 이쁘게 변경된 것을 확인 할 수 있었다.</p>\n<p>이제 나머지 태그들도 커스터 마이징 해보자.</p>\n<pre><code class=\"language-tsx\">'use client';\n\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { materialDark } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport Image from 'next/image';\n\nexport default function MarkDownViewer({ content }: { content: string }) {\n  return (\n    &#x3C;ReactMarkdown\n      remarkPlugins={[remarkGfm]}\n      components={{\n        code({ node, inline, className, children, ...props }) {\n          const match = /language-(\\w+)/.exec(className || '');\n          return !inline &#x26;&#x26; match ? (\n            &#x3C;SyntaxHighlighter\n              {...props}\n              style={materialDark}\n              language={match[1]}\n              PreTag='div'\n              showLineNumbers={true}\n            >\n              {String(children).replace(/\\n$/, '')}\n            &#x3C;/SyntaxHighlighter>\n          ) : (\n            &#x3C;code {...props} className={className}>\n              {children}\n            &#x3C;/code>\n          );\n        },\n        img: (image) => (\n          &#x3C;Image\n            className='w-full h-auto object-cover'\n            src={image.src || ''}\n            alt={image.alt || ''}\n            width={500}\n            height={500}\n            placeholder='blur'\n          />\n        ),\n        h1: ({ children, ...props }) => (\n          &#x3C;h1 className='prose text-2xl dark:text-white' {...props}>\n            {children}\n          &#x3C;/h1>\n        ),\n        h2: ({ children, ...props }) => (\n          &#x3C;h2 className='prose text-xl dark:text-white' {...props}>\n            {children}\n          &#x3C;/h2>\n        ),\n        h3: ({ children, ...props }) => (\n          &#x3C;h3 className='prose text-lg dark:text-white' {...props}>\n            {children}\n          &#x3C;/h3>\n        ),\n        p: ({ children, ...props }) => (\n          &#x3C;p className='prose dark:text-white' {...props}>\n            {children}\n          &#x3C;/p>\n        ),\n        li: ({ children, ...props }) => {\n          const liProps = { ...props, ordered: 'false' };\n          return (\n            &#x3C;li className='prose dark:text-white' {...liProps}>\n              {children}\n            &#x3C;/li>\n          );\n        },\n        strong: ({ children, ...props }) => (\n          &#x3C;strong className='prose dark:text-white' {...props}>\n            {children}\n          &#x3C;/strong>\n        ),\n        a: ({ children, ...props }) => (\n          &#x3C;a className='prose dark:text-blue-300' {...props}>\n            {children}\n          &#x3C;/a>\n        ),\n      }}\n    >\n      {content}\n    &#x3C;/ReactMarkdown>\n  );\n}\n</code></pre>\n<p>커스텀한 태그들이 수정되었다.</p>\n<p>그런데 문제점이 있다. 내가 이미지 삽입을 위해 추가한 붉은 박스의 <code>html</code> 코드가 문자열로 그대로 노출되고 있다.</p>\n<h2>rehypeRaw 적용하기</h2>\n<p>마크다운 컨텐츠에 담겨있는 <code>html</code>을 그대로 렌더링 하기 위해서는 또 다시 추가 작업을 해야한다.</p>\n<p>여기서 정말 많은 검색과 시행착오를 겪었는데, 결론을 정리하면 <code>rehypeRaw</code> 이라는 플러그인을 설치하면 적용하면 된다.</p>\n<blockquote>\n<p>그리고 7.0버전의 경우 오류가 발생했는데, 6.1.0 버전으로 다운그레이드 하니 정상적으로 작동했다.</p>\n</blockquote>\n<p><a href=\"https://www.npmjs.com/package/rehype-raw/v/6.1.0\">rehype-raw 바로가기</a></p>\n<p>적용방법은 아래와 같다.</p>\n<pre><code class=\"language-tsx\">&#x3C;ReactMarkdown\n      className='prose max-w-none dark:text-white '\n      remarkPlugins={[remarkGfm]}\n      rehypePlugins={[rehypeRaw]}\n</code></pre>\n<p>후.. 생각보다 어려웠다. 그래도 이제 마크다운 뷰어를 완성했다.</p>\n<p>나머진 조금씩 수정해나가면 될 것 같다.</p>",
            "url": "https://nostrss.me/162-markdown-view",
            "title": "Next.js 13 react-markdown 적용하기",
            "summary": "이쁘게 만드는게 이렇게 어려운지 몰랐지...",
            "date_modified": "2023-09-09T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "next",
                "markdown",
                "view"
            ]
        },
        {
            "id": "161-next-google-analytics",
            "content_html": "<p>개인 블로그 작업이 거의 마무리 단계가 되어가고 있다. 그리고 오늘은 <code>Google Analytics</code>를 적용해보려고 한다.</p>\n<p>적용 방법은 링크를 따라 가면 자세하게 설명이 되어 있어서 따라하면 된다.</p>\n<p><a href=\"https://support.google.com/sites/answer/97459?hl=ko\">📌 사이트에 애널리틱스 사용하기 📌</a></p>\n<p>다만 <code>Next</code>에 직접 적용하는데 살짝 어려움이 있었다.</p>\n<p>일단, 위의 링크를 따라하면 아래와 같은 <code>script</code>를 구글에서 알려준다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- Google tag (gtag.js) -->\n&#x3C;script\n  async\n  src=\"https://www.googletagmanager.com/gtag/js?id=G-xxxxxxxxx\"\n>&#x3C;/script>\n&#x3C;script>\n  window.dataLayer = window.dataLayer || [];\n  function gtag() {\n    dataLayer.push(arguments);\n  }\n  gtag('js', new Date());\n\n  gtag('config', 'G-xxxxxxxxx');\n&#x3C;/script>\n</code></pre>\n<p>위의 코드를 이제 <code>Next</code> <code>head</code>에 적용하기만 하면 끝이다.</p>\n<p>모든 페이지에서 위의 스크립트가 호출되어야 하므로 일단 나는 <code>RootLayout</code>에 적용하기로 마음 먹었다.</p>\n<p>아래는 내가 작성 및 적용한 코드이다.</p>\n<p>먼저 위의 코드를 포함한 <code>Client</code> 컴포넌트를 하나 만들었다.</p>\n<pre><code class=\"language-tsx\">// Analytics.tsx\n'use client';\n\nimport Script from 'next/script';\n\nexport default function Analytics() {\n  return (\n    &#x3C;>\n      &#x3C;Script\n        async\n        src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_ID}`}\n        strategy='afterInteractive'\n      />\n      &#x3C;Script id='google-analytics' strategy='afterInteractive'>\n        {`window.dataLayer = window.dataLayer || []; \n        function gtag(){dataLayer.push(arguments);}\n        gtag('js', new Date());\n        gtag('config', '${process.env.NEXT_PUBLIC_GA_ID}');\n          `}\n      &#x3C;/Script>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그리고 <code>RootLayout</code>에는 아래와 같이 적용했다.</p>\n<pre><code class=\"language-tsx\">//layout.tsx\nexport default function RootLayout({ children }: IPropsChildren) {\n  return (\n    &#x3C;html lang='kr'>\n      &#x3C;Analytics />\n      &#x3C;QueryProviders>\n        &#x3C;body className={sans.className}>\n          &#x3C;Header menus={menus} />\n          &#x3C;div className='w-full flex flex-col items-center'>\n            &#x3C;section className='w-full max-w-[1192px] flex flex-row justify-center'>\n              {children}\n              &#x3C;TagBox />\n            &#x3C;/section>\n          &#x3C;/div>\n        &#x3C;/body>\n      &#x3C;/QueryProviders>\n    &#x3C;/html>\n  );\n}\n</code></pre>\n<p>그리고 <code>head</code>에 정상적으로 스크립트가 심어졌는지 확인해보자</p>\n<blockquote>\n<p>정상!!</p>\n</blockquote>\n<p>이제 배포 후 구글애널리틱스와 통신이 되면 끝나게 된다.</p>\n<p>모든게 정상적으로 작동하는 것을 확인할 수 있다.</p>\n<p>이제 구글애널리틱스가 내 블로그로 접속하는 유저들의 통계를 수집해 줄 것이다.</p>",
            "url": "https://nostrss.me/161-next-google-analytics",
            "title": "Next.js 13 App router에 Google Analytics 적용하기",
            "summary": "아직 Next13에 Google Analytics를 적용한 경우가 없는지 자료가 부실했다. 그래서 직접 정리한 내용",
            "date_modified": "2023-09-08T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "next",
                "google-analytics",
                "app-router",
                "layout"
            ]
        },
        {
            "id": "160-interview-review-closure3",
            "content_html": "<p>이론적인 내용을 정리하고 이제는 실제로 어떻게 쓰이는지 알아보자.<br>\npoiemaweb에서 클로저가 사용되는 예제가 있어서 가져와 봤다.<br>\n<a href=\"https://poiemaweb.com/js-closure\">🔗 poiemaweb 클로저 바로가기 🔗</a></p>\n<h2>1. 최신 상태유지</h2>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n&#x3C;body>\n  &#x3C;button class=\"toggle\">toggle&#x3C;/button>\n  &#x3C;div class=\"box\" style=\"width: 100px; height: 100px; background: red;\">&#x3C;/div>\n\n  &#x3C;script>\n    var box = document.querySelector('.box');\n    var toggleBtn = document.querySelector('.toggle');\n\n    var toggle = (function () {\n      var isShow = false;\n\n      // ① 클로저를 반환\n      return function () {\n        box.style.display = isShow ? 'block' : 'none';\n        // ③ 상태 변경\n        isShow = !isShow;\n      };\n    })();\n\n    // ② 이벤트 프로퍼티에 클로저를 할당\n    toggleBtn.onclick = toggle;\n  &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>위의 코드는 버튼을 클릭하면 박스가 사라지고 나타나는 코드이다.</p>\n<p>일반적으로 함수는 반환하고 즉시 소멸하기 때문에, 이때 함수 내부의 변수의 값도 소멸하게 된다.</p>\n<p>하지만 위의 코드는 클로저를 사용하여 함수 내부의 변수를 최신으로 유지하고 있다.</p>\n<p>그런데 그 기능이 마치 React에서 쓰던 useState와 비슷한 것 같다.</p>\n<p>클로저로 useState를 구현 할 수 있지 않을까?</p>\n<p>아래는 간단한 기능의 useState를 클로저로 구현해본 코드이다.</p>\n<p>버튼을 클릭하면 console에 true, false가 번갈아가며 출력되도록 작업해봤다.</p>\n<blockquote>\n<p>isState값이 변경될 때 렌더링을 다시 일으키고 isColor값도 없데이트를 해줘야 하는데, 방법을 찾지 못해서 일단은 이렇게라도 흉내를 내보았다.</p>\n</blockquote>\n<pre><code class=\"language-jsx\">export default function UseStateByClosure() {\n  function useCustomState(initialState: any) {\n    let state = initialState;\n\n    const isState = () => state;\n    const setState = () => {\n      state = !isState();\n      console.log(state);\n    };\n\n    return [isState(), setState];\n  }\n\n  const [isColor, setIsColor] = useCustomState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;button type='button' onClick={() => setIsColor()}>\n        클릭\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>2. 전역변수 사용의 억제</h2>\n<p>전역변수의 경우 누구나 접근할 수 있기 때문에, 의도치 않게 값이 변경이 될 수 있다.</p>\n<p>따라서 전역변수를 클로저를에 넣어서 사용하게 되면 외부에서 접근이 불가능하기 때문에 의도치 않은 값의 변경을 막을 수 있다.</p>\n<h2>3. 정보의 은닉화</h2>\n<p>이번에는 조금 다른 방식으로 클로저를 이용하는 방법에 대해서 알아보자.</p>\n<p>아래는 생성자함수를 선언하고 new 연산자를 통해 새로운 객체를 생성하는 코드이다.</p>\n<blockquote>\n<p>생성자 함수와 일반 함수에 기술적차이는 없다. 다만 생성자 함수는 아래 두 관례를 따른다고 한다.\n함수이름의 첫글자는 대문자로 시작한다.\n반드시 new 연산자를 사용하여 실행한다.</p>\n</blockquote>\n<pre><code class=\"language-js\">function Counter() {\n  // 카운트를 유지하기 위한 자유 변수\n  let hiddenCounter = 0;\n\n  // 클로저\n  this.increase = function () {\n    return ++hiddenCounter;\n  };\n\n  // 클로저\n  this.decrease = function () {\n    return --hiddenCounter;\n  };\n}\n\nconst myCounter = new Counter();\n\nconsole.log(myCounter); // Counter { increase: f, decrease: f }\nconsole.log(myCounter.increase()); // 1\nconsole.log(myCounter.decrease()); // 0\n</code></pre>\n<p>위의 console.log에서 보듯이 직접 Counter 내부에 생성된 변수 hiddenCounter에 외부에서 직접 접근을 할 수가 없게 된다.</p>\n<p>이렇게 되면 외부에서는 increase, decrease 함수를 통해서만 hiddenCounter에 접근이 가능하게 된다.</p>\n<p>이를 통해 다른 클래스 기반의 언어에서 말하는 정보의 은닉화를 어느정도 구현할 수가 있다.</p>\n<blockquote>\n<p>주의 : 아래와 같이 this에 바인딩되어 있으면 외부에서 접근이 가능해진다.</p>\n</blockquote>\n<pre><code class=\"language-js\">function Counter() {\n  // 카운트를 유지하기 위한 자유 변수\n  this.hiddenCounter = 0;\n\n  // 클로저\n  this.increase = function () {\n    return ++this.hiddenCounter;\n  };\n\n  // 클로저\n  this.decrease = function () {\n    return --this.hiddenCounter;\n  };\n}\n\nconst myCounter = new Counter();\n\nconsole.log(myCounter); // Counter { hiddenCounter: 0, increase: f, decrease: f }\nconsole.log(myCounter.increase()); // 1\nconsole.log(myCounter.decrease()); // 0\n</code></pre>\n<p>알아두면 유용할 기법인 것 같다. 나중에 기억해두었다가 사용할 경우가 있으면 적용해봐야겠다.</p>",
            "url": "https://nostrss.me/160-interview-review-closure3",
            "title": "[면접리뷰]클로저(Closure)란? (3)",
            "summary": "클로저는 언제 사용하는가? 자주 사용해서 익숙해지자.",
            "date_modified": "2023-09-06T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "interview",
                "javascript",
                "closure"
            ]
        },
        {
            "id": "159-interview-review-closure2",
            "content_html": "<p>이번에는 여러 사이트들의 예제들을 보면서 클로저에 대해 조금 더 이해해보려고 한다.</p>\n<h2>MDN 예제</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures\">🔗 MDN 클로저 바로가기 🔗</a></p>\n<pre><code class=\"language-js\">function makeAdder(x) {\n  return function (y) {\n    // debugger; 브라우저에서 실행 시 중단점\n    return x + y;\n  };\n}\n\nconst add5 = makeAdder(5);\nconst add10 = makeAdder(10);\n\nconsole.log(add5(2)); // 7\nconsole.log(add10(2)); // 12\n</code></pre>\n<p>특이한 코드이다. 이런 식으로 코드가 작성가능하구나 싶었다.</p>\n<p>위 코드의 클로저를 확인해보자.</p>\n<p>add5(2) 클로저가 생성된 모습이다.\n클로저에 x: 5가 저장되어 있고, y: 2가 인자로 전달는 모습을 볼 수 있다.</p>\n<p>이번에는 add10(2) 클로저가 생성된 모습이다.\n위와 마찬가지로 클로저에 x: 10이 저장되어 있고, y: 2가 인자로 전달는 모습을 볼 수 있다.\n</p>\n<h2>javascript.info 예제</h2>\n<p><a href=\"https://ko.javascript.info/closure\">🔗 javascript.info 클로저 바로가기🔗</a></p>\n<p>다음 예제에서 sayHi()의 결과는 John일까 Pete일까?</p>\n<pre><code class=\"language-js\">let name = 'John';\n\nfunction sayHi() {\n  alert('Hi, ' + name);\n}\n\nname = 'Pete';\n\nsayHi(); // what will it show: \"John\" or \"Pete\"?\n</code></pre>\n<p>나는 처음에 John이라고 생각했다가 결과를 보고 깜짝 놀랐다.<br>\n정답은 Pete이다.</p>\n<p>왜 그런지 위의 코드를 시간 순으로 브라우저에서 살펴보자.</p>\n<ul>\n<li>name에 John이 할당된다.</li>\n<li>name에 Pete가 할당된다.</li>\n<li>sayHi()가 호출된다.</li>\n<li>name 변수에 접근하여 alert을 띄운다.</li>\n</ul>\n<p>즉, sayHi()가 호출되는 시점에 name 변수에는 Pete가 할당되어 있기 때문에 Pete가 출력되는 것을 볼 수 있었다.</p>",
            "url": "https://nostrss.me/159-interview-review-closure2",
            "title": "[면접리뷰]클로저(Closure)란? (2)",
            "summary": "다양한 예제를 보고 클로저에 대해 조금 더 이해해보자.",
            "date_modified": "2023-09-06T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "interview",
                "javascript",
                "closure"
            ]
        },
        {
            "id": "158-interview-review-closure",
            "content_html": "<p>오늘 면접을 보면서 내가 이론 공부에 대해 개념적으로만 간단히 알고있다는 느낌을 받았다.</p>\n<p>그래서 면접 질문에 대해서 복습차원에서 정리해보려고 한다.</p>\n<h2>Step1: 클로저(Closure)란 무엇인가?</h2>\n<ul>\n<li>\n<p>MDN</p>\n<blockquote>\n<p>클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다. 즉, 클로저는 내부 함수에서 외부 함수의 범위에 대한 접근을 제공합니다. JavaScript에서 클로저는 함수 생성 시 함수가 생성될 때마다 생성됩니다.</p>\n</blockquote>\n</li>\n<li>\n<p>javascript.info</p>\n<blockquote>\n<p>클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다.</p>\n</blockquote>\n</li>\n<li>\n<p>poiemaweb</p>\n<blockquote>\n<p>클로저(closure)는 자바스크립트에서 중요한 개념 중 하나로 자바스크립트에 관심을 가지고 있다면 한번쯤은 들어보았을 내용이다. execution context에 대한 사전 지식이 있으면 이해하기 어렵지 않은 개념이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(Functional Programming language: 얼랭(Erlnag), 스칼라(Scala), 하스켈(Haskell), 리스프(Lisp)…)에서 사용되는 중요한 특성이다.</p>\n</blockquote>\n</li>\n</ul>\n<p>내가 Javascript를 공부할때 자주 참고하는 사이트에서 클로저에 대한 설명을 가져왔다.</p>\n<p>일단 위 내용의 주요 키워드는 이렇다.</p>\n<ul>\n<li>외부함수, 외부변수, 내부함수, 내부함수</li>\n<li>어휘적 환경(Lexical Scope)</li>\n<li>자바스크립트 뿐만 아니라 다른 언어에서도 쓰이는 기법이자 개념이다.</li>\n</ul>\n<pre><code class=\"language-js\">function init() {\n  // 외부 함수\n  var name = 'Mozilla'; // 외부 변수\n  function displayName() {\n    // 내부 함수, 클로저\n    console.log(name); // 내부 함수에서 외부 변수 접근\n  }\n  displayName();\n}\n\ninit(); // Mozilla\n</code></pre>\n<p>위의 코드에서 init() 함수가 실행되면 displayName() 함수가 실행된다.</p>\n<p>이 때 외부 변수인 name에 접근하여 Mozilla가 출력된다.</p>\n<p>이렇게 외부함수의 변수에 접근할 수 있는 내부함수를 클로저라고 부른다.</p>\n<p>여기까지 이해한 내용은 이렇다.</p>\n<blockquote>\n<p>클로저는 외부함수의 변수에 접근하는 내부함수이다.</p>\n</blockquote>\n<h2>Q : 함수가 외부 변수에 접근하는 것은 당연한 것 아닌가?</h2>\n<p>위의 내용만 보면 단순히 내부 함수가 외부 함수의 변수에 접근하는 당연한 내용처럼만 보인다.</p>\n<p>그런데 왜 클로저라는 별도의 네이밍을 하면서 이 개념을 정의해 놓은 것일까?</p>\n<p>조금 더 클로저에 대해 알아보자</p>\n<h2>Step2: 클로저 = 외부 변수 + 내부 함수</h2>\n<p>위의 코드를 아래와 같이 조금 변형해 보았다.</p>\n<pre><code class=\"language-js\">function init() {\n  // 외부 함수\n  var name = 'Mozilla'; // 외부 변수\n  function displayName() {\n    // 내부 함수, 클로저\n    console.log(name); // 내부 함수에서 외부 변수 접근\n  }\n  return displayName;\n}\n\nconst showName = init();\nconsole.log(showName);\n\n// console.log 결과\n// ƒ displayName() {\n//     // 내부 함수, 클로저\n//     console.log(name); // 내부 함수에서 외부 변수 접근\n//   }\n\nshowName(); // Mozilla\n</code></pre>\n<p>console.log를 살펴보면 showName 변수에는 init함수의 return 값인 displayName 함수가 담겨있다.</p>\n<p>그리고 showName을 실행하면 Mozilla가 출력되고 있다.</p>\n<p>조금만 생각해보면 말이 안되는 상황인 것이다.</p>\n<p>showName 함수에 name 변수가 없는데도 Mozilla가 출력되고 있는 것이다.</p>\n<p>위 코드의 결과는 아래와 같이 해석할 수 있다.</p>\n<pre><code class=\"language-js\">function displayName() {\n  console.log(name);\n}\ndisplayName(); // Mozilla\n</code></pre>\n<p>name 변수가 선언도 되지 않았고, 할당도 되지 않았는데 Mozilla가 출력되고 있는 것이다.</p>\n<p>앞서 클로저의 정의를 다시 살펴보자.</p>\n<blockquote>\n<p>클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다.<br>\n클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다.</p>\n</blockquote>\n<p>단순히 외부함수에 접근하는 내부 변수가 아니라, 외부함수의 변수를 기억한다는 내용이 있다.</p>\n<p>name 변수를 showName 함수가 기억하고 있기 때문에 Mozilla가 출력되고 있다고 말하고 있다.</p>\n<p>즉, 클로저는 아래와 같은 모습이라는 것이다.</p>\n<pre><code class=\"language-js\">const name = 'Mozilla';\n\nfunction displayName() {\n  console.log(name);\n}\n</code></pre>\n<h2>Step3. 디버거로 클로저 직접 확인해보기</h2>\n<p>위에서는 클로저가 외부함수의 변수를 기억한다고 했다.</p>\n<p>이걸 눈으로 직접 확인해보고 싶어졌다.</p>\n<p>그래서 아래와 같이 디버거를 추가하고 브라우저에서 실행해보았다.</p>\n<pre><code class=\"language-js\">function init() {\n  // 외부 함수\n  var name = 'Mozilla'; // 외부 변수\n  function displayName() {\n    // 내부 함수, 클로저\n    debugger; // 디버거 추가!!\n    console.log(name); // 내부 함수에서 외부 변수 접근\n  }\n  return displayName;\n}\n\nconst showName = init();\nshowName();\n</code></pre>\n<p>크롬브라우저 > 개발자도구 > Sources 탭에서 위와 같이 Closure 값을 확인할 수 있었다.</p>\n<h2>Q : 모든 변수의 값이 클로저에 저장되는 것일까?</h2>\n<p>어떤 변수값에 대한 참조값이 클로저에 저장되는 것일까?</p>\n<p>모든 변수값이 저장되면 비효율적이지 않을까 해서 테스트를 해보았다.</p>\n<p>displayName 함수 외부에 age변수와 counter라는 함수를 선언하고 실행해보았다.\n</p>\n<p>내부에서 사용하지 않는 변수는 클로저에 저장되지 않는 것을 확인할 수 있었다.</p>\n<p>그럼 이번에는 displayName 함수안에서 age 변수와 counter 함수를 console.log로 출력해보았다. 예상대로라면 콜러저에 age와 counter가 포함되어 있을 것이다.</p>\n<p>예상대로 클로저에 age변수와 함수까지 저장되는 것을 확인할 수 있었다.</p>\n<p>이제 여기까지 이해한 내용을 다시 정리해 봐야겠다.</p>\n<blockquote>\n<p>클로저란 : 외부함수 안에서 내부 함수가 선언될 때, 내부함수에서 사용되는 외부함수의 Lexical scope(어휘적 환경)를 함께 저장하는 것을 클로저라고 한다.</p>\n</blockquote>\n<p>이전보다 조금 더 명확하게 정리가 되는 느낌이다.</p>\n<p>다음에는 조금 더 심화된 내용을 정리해봐야 할 것 같다.</p>",
            "url": "https://nostrss.me/158-interview-review-closure",
            "title": "[면접리뷰]클로저(Closure)란?",
            "summary": "어설프게 알고 면접보다 망했다. 다음엔 실수하지 말자!",
            "date_modified": "2023-09-06T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "interview",
                "javascript",
                "closure"
            ]
        },
        {
            "id": "157-react-query-inifinite-scroll",
            "content_html": "<p>그동안 <code>무한스크롤</code>을 구현하기 위해 몇가지 라이브러리를 사용해봤다.</p>\n<p>그런데 이번에 <code>React-Query</code> 문서를 보던 중 <code>useInfiniteQuery</code>를 제공하는 것을 알았고 이를 통해 무한스크롤을 구현해보기로 했다.</p>\n<h2>무한스크롤의 구현원리</h2>\n<p>무한 스크롤을 구현하기 위해서는 2가지가 준비되어야 한다.</p>\n<ol>\n<li>\n<p>일정 단위(개수)별로 컨텐츠를 불어올수 있는 API가 필요하다. (ex. 10개씩)</p>\n</li>\n<li>\n<p>페이지 스크롤이 끝에 도달했을 때, 추가적인 데이터를 불러오기 위한 트리거를 만들어야 한다.</p>\n</li>\n</ol>\n<p>예를 들어 설명하면 이렇다.</p>\n<ul>\n<li>10개의 컨텐츠를 불러온다.</li>\n<li>스크롤을 내리다 끝에 도달하면 트리거를 발동한다.</li>\n<li>트리거가 발동되면 10개의 컨텐츠를 추가로 불러온다.</li>\n</ul>\n<p>위 과정을 더이상의 컨텐츠가 없을때까지 반복하면 무한스크롤이 완성된다.</p>\n<h2>Next.js Api Route를 이용한 무한스크롤 API 만들기</h2>\n<p>별도 데이터베이스를 사용하지 않고 프로젝트에 있는 마크다운 파일을 읽어와서 무한스크롤 API를 만들었다.</p>\n<p>그래서 마크다운 파일을 읽어와서 가공하는 과정이 있기 때문에 코드가 다소 길다.</p>\n<p>그리고 api 응답값에서 <code>중요</code>한 건 <code>다음페이지</code>가 있는지 여부를 나타내는 값이다.</p>\n<p>나중에 <code>react-query</code>의 <code>useInfiniteQuery</code>를 사용할 때 이 값을 이용해 다음 페이지가 있는지 여부를 판단할 것이다.</p>\n<pre><code class=\"language-ts\">import { UTIL } from '@/util';\nimport { readFile, readdir } from 'fs/promises';\nimport { NextRequest, NextResponse } from 'next/server';\nimport path from 'path';\nimport parse from 'node-html-parser';\nimport { ImgesArrayItem } from '@/type/common';\n\n// 예시 : /api/posts?page=1&#x26;limit=10\nexport async function GET(req: NextRequest) {\n  // 파싱할 req.url을 이용해 URL 객체 생성\n  const url = new URL(req.url);\n\n  // page, limit 쿼리스트링 파라미터가 없을 경우 기본값 1, 10으로 설정\n  const page = Number(url.searchParams.get('page')) || 1;\n  const limit = Number(url.searchParams.get('limit')) || 10;\n\n  // 파일경로를 생성하고 파일리스트를 읽어온다.\n  const filePath = path.join(process.cwd(), 'posts');\n  const fileList = await readdir(filePath);\n\n  // 파일리스트를 순회하며 각 파일의 정보를 읽고 가공한다.\n  const markdowmMetaData = await Promise.all(\n    fileList.map(async (file) => {\n      const fileData = await readFile(`${filePath}/${file}`, 'utf-8');\n      const currentPostId = {\n        currentPostId: file.replace('.md', ''),\n      };\n      const markDownContent = UTIL.removeMetaData(fileData);\n\n      const imgArr = getImageSrc(markDownContent);\n\n      return {\n        ...UTIL.getMarkDownMetaData(fileData, currentPostId),\n        images: imgArr,\n      };\n    })\n  );\n\n  // 가공된 컨텐츠 배열을 타이틀, 날짜 순으로 정렬하고 페이지와 limit을 이용해 데이터를 자른다.\n  const sortDataByTitle = UTIL.sortByTitle(markdowmMetaData);\n  const sortDataByDate = UTIL.sortByDate(sortDataByTitle);\n  const sliceData = UTIL.slicePerPage(sortDataByDate, page, limit);\n\n  return NextResponse.json({\n    data: sliceData,\n    total: markdowmMetaData.length,\n    // 중요! 다음 페이지가 있는지 여부를 나타내는 값\n    // 다음 페이지가 있으면 페이지 number, 없ㅇ면 null\n    nextPage: UTIL.getNextpage(page, limit, markdowmMetaData.length),\n  });\n}\n\nconst getImageSrc = (htmlElement: string | undefined) => {\n  if (!htmlElement) return [];\n  const imgHtml = parse(htmlElement).getElementsByTagName('img');\n  const imgUrl: Array&#x3C;ImgesArrayItem> = [];\n  imgHtml.forEach((img) => {\n    const imgParse = img.getAttribute('src');\n    imgUrl.push({ url: imgParse });\n  });\n\n  const result = imageUrlValidate([...imgUrl]);\n\n  return [...result];\n};\n\nconst imageUrlValidate = (images: ImgesArrayItem[]) => {\n  const validateImages = images.filter((image) => {\n    if (image.url?.includes('http')) {\n      return image.url;\n    }\n  });\n  return [...validateImages];\n};\n</code></pre>\n<h3>API 응답 예시</h3>\n<pre><code class=\"language-json\">{\n  \"data\": [\n    {\n      \"currentPostId\": \"2023-08-23-144-nestjs\",\n      \"layout\": \"post\",\n      \"title\": \"'[Nest.js] - 소개'\",\n      \"author\": \"'Nostrss'\",\n      \"comments\": \"true\",\n      \"tags\": \"nestjs node express javascript typescript\",\n      \"excerpt_separator\": \"\",\n      \"sticky\": \"\",\n      \"hidden\": \"\",\n      \"date\": \"2023-08-23\",\n      \"images\": []\n    }\n    // (... 생략)\n  ],\n  \"total\": 25,\n  \"nextPage\": 2 // 중요!\n}\n</code></pre>\n<h2>useInfiniteQuery 적용하기</h2>\n<p><a href=\"https://tanstack.com/query/latest/docs/react/guides/infinite-queries\">🔗 Tanstack Infinite Queries 문서보기 🔗</a></p>\n<p>아래는 공식문서의 일부를 발췌한 것이다.<br>\n<code>Query</code>와 사용법이 비슷하지만 다소 다르게 생겼다. 하나씩 살펴보자.</p>\n<pre><code class=\"language-tsx\">const {\n  data, // api 응답 객체\n  error,\n  fetchNextPage, // 다음 페이지(컨텐츠)를 불러오는 함수\n  hasNextPage, // Boolean 값, 다음 페이지가 있는지 여부를 나타낸다.\n  isFetching, // 로드가 진행중인지 여부를 나타낸다.\n  isFetchingNextPage // 추가로드가 진행중인지 여부를 나타낸다.,\n  status,\n} = useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n});\n</code></pre>\n<p>위 코드의 작동방식을 보면 다음과 같다.</p>\n<ul>\n<li><code>queryKey</code> : 쿼리의 키값을 나타낸다. 이 키값을 이용해 캐시를 관리한다.</li>\n<li><code>queryFn</code> : 쿼리를 실행하는 함수를 나타낸다. 이 함수는 <code>queryKey</code>를 인자로 받는다.</li>\n<li><code>getNextPageParam</code> : 다음 페이지를 불러오는 함수를 나타낸다. 이 함수는 <code>queryFn</code>의 결과값을 인자로 받으며, 다음 페이지가 있는 경우 실행된다.</li>\n</ul>\n<h2>실제 적용된 코드</h2>\n<pre><code class=\"language-tsx\">const { data, isFetching, fetchNextPage, hasNextPage } = useInfiniteQuery({\n  queryKey: ['post'],\n  queryFn: ({ pageParam = 1 }) => fetchPostList(pageParam, limit),\n  getNextPageParam: (lastPage) => {\n    console.log(lastPage);\n    return lastPage.nextPage;\n  },\n});\n</code></pre>\n<p>위에서 찍힌 <code>console.log</code>를 살펴볼 필요가 있다.</p>\n<pre><code class=\"language-json\">{\n  \"data\": [\n    //생략\n  ],\n  \"total\": 25,\n  \"nextPage\": 2\n}\n</code></pre>\n<p>getNextPageParam 함수의 인자로 들어온 lastPage는 위와 같은 형태이다.</p>\n<p>그리고 이 함수의 반환값은 다음 페이지의 <code>number</code>이며, 이 값은 <code>queryFn</code>의 <code>pageParam</code>으로 들어간다.</p>\n<p>그래서 만약 백엔드 개발자가 따로 있다면 응답값에 다음페이지의 number를 반환하도록 요청해야한다.</p>\n<h2>IntersectionObserver를 이용한 무한스크롤 구현하기</h2>\n<p><a href=\"https://simian114.gitbook.io/blog/undefined/react/intersectionobserverapi\">🔗 참고 블로그 🔗</a></p>\n<p>이제는 다음페이지를 불러오도록 하기 위해서 트리거를 구현해야한다.</p>\n<ul>\n<li>빈 <code>div</code>를 만들고 이 <code>div</code>를 <code>IntersectionObserver</code>의 <code>targe</code>t으로 지정해야한다.</li>\n<li>그래서 <code>useRef</code>를 이용해 위의 빈 div의 ref에 바인딩 해주었다.</li>\n<li>그리고 빈 div가 화면에 보이면 <code>fetchNextPage</code>를 실행한다.\n<blockquote>\n<p>주의사항 : IntersectionObserver는 Web API이기 때문에 SSR에서는 사용할 수 없다. 그러므로 useEffect를 이용해 빈 div가 화면에 보일때만 IntersectionObserver를 실행하도록 해야한다.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-tsx\">const ref = useRef&#x3C;HTMLDivElement | null>(null);\n\nuseEffect(() => {\n  if (!ref.current || !hasNextPage) return;\n\n  const observer = new IntersectionObserver((entries) => {\n    if (entries[0].isIntersecting) {\n      fetchNextPage();\n    }\n  });\n  observer.observe(ref.current);\n\n  return () => {\n    observer.disconnect();\n  };\n}, [hasNextPage]);\n\nreturn (\n  &#x3C;section className='flex flex-col gap-4 items-center px-4 pt-4'>\n    {renderData &#x26;&#x26;\n      renderData.map((post: Post, index: number) => (\n        &#x3C;PostCard key={index} {...post} />\n      ))}\n    {isFetching &#x26;&#x26; &#x3C;div>loading...&#x3C;/div>}\n\n    &#x3C;div ref={ref}>&#x3C;/div>\n  &#x3C;/section>\n);\n</code></pre>\n<p>위의 같이 코드를 작성하고 실행해보면 무한스크롤이 작동을 하지 않는다.</p>\n<p>그 이유는 <code>useInfiniteQuery</code>가 반환하는 data의 구조 때문이다.</p>\n<p>위의 이미지는 useInfiniteQuery가 반환하는 data의 구조이다.\n중첩된 구조로 되어있기 때문에 map을 두번 사용해야 렌더링이 가능한 형태이다.</p>\n<p>그래서 이를 한번에 렌더링할 수 있도록 데이터를 가공해주는 코드를 추가해주었다.</p>\n<pre><code class=\"language-tsx\">const renderData = data?.pages.map(({ data }) => data).flat();\n</code></pre>\n<h2>결과</h2>\n<p>10개마다 추가로 불러오도록 설정했는데 잘 작동하는 것을 확인할 수 있다.</p>\n<h2>최종 코드</h2>\n<pre><code class=\"language-tsx\">'use client';\n\nimport PostCard from '@/stories/PostCard';\nimport { Post } from '@/type/common';\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { useEffect, useRef } from 'react';\n\nconst fetchPostList = async (page: number, limit: number) => {\n  const data = await fetch(`/api/post?page=${page}&#x26;limit=${limit}`, {\n    method: 'GET',\n  });\n  return data.json();\n};\n\nexport default function PostList() {\n  const ref = useRef&#x3C;HTMLDivElement | null>(null);\n  const limit = 10;\n  const { data, isFetching, fetchNextPage, hasNextPage } = useInfiniteQuery({\n    queryKey: ['post'],\n    queryFn: ({ pageParam = 1 }) => fetchPostList(pageParam, limit),\n    getNextPageParam: (lastPage, pages) => {\n      return lastPage.nextPage;\n    },\n  });\n\n  const renderData = data?.pages.map(({ data }) => data).flat();\n\n  useEffect(() => {\n    if (!ref.current || !hasNextPage) return;\n\n    const observer = new IntersectionObserver((entries) => {\n      if (entries[0].isIntersecting) {\n        fetchNextPage();\n      }\n    });\n    observer.observe(ref.current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [hasNextPage]);\n\n  return (\n    &#x3C;section className='flex flex-col gap-4 items-center px-4 pt-4'>\n      {renderData &#x26;&#x26;\n        renderData.map((post: Post, index: number) => (\n          &#x3C;PostCard key={index} {...post} />\n        ))}\n      {isFetching &#x26;&#x26; &#x3C;div>loading...&#x3C;/div>}\n      &#x3C;div ref={ref}>&#x3C;/div>\n    &#x3C;/section>\n  );\n}\n</code></pre>",
            "url": "https://nostrss.me/157-react-query-inifinite-scroll",
            "title": "[React-Query] 무한 스크롤 구현하기",
            "summary": "별도의 무한스크롤 라이브러리 없이 useInfiniteQuery와 IntersectionObserver를 통해 무한 스크롤을 구현해보자",
            "date_modified": "2023-09-06T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "app",
                "storybook",
                "error",
                "tsconfig"
            ]
        },
        {
            "id": "156-next13-storybook-error",
            "content_html": "<p>외부에서 <code>상수</code>나 <code>컴포넌트</code>를 import 해왔을때 갑자기 <code>스토리북</code>에서 아래와 같은 에러가 발생했다.</p>\n<p><code>Next</code>의 <code>Alias</code> 설정과 <code>스토리북</code>의 <code>웹팩</code> 경로 설정상의 문제로 보인다.</p>\n<pre><code class=\"language-json\">// tsconfig.json\n\"paths\": {\n      \"@/*\": [\"./src/*\"]\n    },\n</code></pre>\n<h2>해결</h2>\n<p>검색을 해보니 관련한 이슈가 생각보다 많아 보였다.</p>\n<p>그중에서 내가 지금 쓰고 있는 7버전의 스토리북과 관련된 이슈를 발견했다.\n<a href=\"https://github.com/storybookjs/storybook/issues/21901\">🔗 스토리북 깃허브 이슈 바로가기 🔗</a></p>\n<p>next.js 최초 프로젝트 생성 시 <code>tsconfig</code>에 <code>baseurl</code>이 생성되지 않아서 밣생하는 것이 문제였던 것 같다.\n아래와 같이 <code>baseurl</code>을 <code>tsconfig</code>에 추가해주니 해결되었다.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    },\n    // 추가\n    \"baseUrl\": \".\"\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n</code></pre>",
            "url": "https://nostrss.me/156-next13-storybook-error",
            "title": "[Error] Storybook, Cannot find module",
            "summary": "스토리북에서 Cannot find module 에러가 발생했을 때 해결 방법",
            "date_modified": "2023-09-06T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "app",
                "storybook",
                "error",
                "tsconfig"
            ]
        },
        {
            "id": "155-next13-storybook",
            "content_html": "<p>이번에 <code>nextjs 13</code>으로 개인 블로그를 만드려는데 때마침 <code>스토리북</code>이 생각나서 사용해보려고 했다.</p>\n<h2>스토리북(Storybook)이란?</h2>\n<p>내가 <code>스토리북</code>을 적용해보려고 한 건 아래와 같은 이유에서 였다.</p>\n<blockquote>\n<ul>\n<li>UI 컴포넌트를 독립적인 환경에서 개발 및 확인 할 수 있다.</li>\n<li>UI 컴포넌트를 쉽게 테스트 할 수 있다.</li>\n<li>자연스럽게 컴포넌트를 독립적으로 쪼개서 개발하게 된다.</li>\n<li>UI 컴포넌트를 쉽게 문서화 할 수 있다.</li>\n<li>문서를 기획자,디자이너에게 쉽게 공유할 수 있다.</li>\n</ul>\n</blockquote>\n<p>특히 예전에 기획을 할때 현재 운영중인 서비스의 UI를 한눈에 볼 수 있는 문서가 있으면 참 좋겠다는 생각을 했었다.</p>\n<p>기획문서를 보면 되지만, 문서들이 관리가 되지 않는 경우가 많아 이를 파악하는데 시간이 많이 소요되는 경우가 많았다.</p>\n<p>그리고 이제는 개발을 하다보니 컴포넌트의 단위에 대해 많은 고민을 하게 되었다.</p>\n<p>그래서 <code>스토리북</code>을 사용해보려고 한다.</p>\n<h2>스토리북 설치</h2>\n<p>설치를 하기 전에 공식 문서를 살펴봤다. 그런데 스토리북에서 next에 대해 <code>zero-config support</code>를 제공한다고 한다는 문서를 보았다.</p>\n<blockquote>\n<p><a href=\"https://storybook.js.org/blog/integrate-nextjs-and-storybook-automatically/\">🔗 Integrate Next.js and Storybook automatically 바로가기 🔗</a></p>\n</blockquote>\n<p>위의 문서를 참고로 하여 설치를 진행했다.</p>\n<p>먼저 <code>app router</code>와 <code>tailwind</code>를 사용하는 next 프로젝트를 하나 생성해줬다.</p>\n<p>그리고 아래 명령어로 스토리북을 설치해줬다.</p>\n<pre><code class=\"language-bash\">npx storybook@next init\n</code></pre>\n<p>설치가 완료되자 마자 스토리북이 실행되면서 아래와 같은 화면을 볼 수 있었다.</p>\n<h2>스토리북 살펴보기</h2>\n<p>설치 후 vscode로 프로젝트를 살펴봤다.</p>\n<ul>\n<li><code>.storybook</code> 이라는 폴더가 생기고, 그 안에 <code>main.js</code>와 <code>preview.js</code>가 생성되었다.</li>\n<li><code>package.json</code>을 살펴보니 스크립트 명령어가 2개 생겼다.</li>\n</ul>\n<pre><code class=\"language-json\">\"storybook\": \"storybook dev -p 6006\",\n\"build-storybook\": \"storybook build\"\n</code></pre>\n<ul>\n<li><code>src/stories</code> 라는 폴더가 생기고 그안에 각 컴포넌트에 대한 스토리 파일이 생성되어 있었다.</li>\n</ul>\n<h3>스토리북 실행, 빌드하기</h3>\n<pre><code class=\"language-bash\">yarn storybook\n// or npm run storybook\n</code></pre>\n<p>next 프로젝트를 실행할 때 처럼 스토리북도 위의 명령어로 실행을 해줘야 작성된 스토리북 페이지를 볼 수 있다. 기본 포트는 <code>6006</code>으로 되어 있다.</p>\n<pre><code class=\"language-bash\">yarn build-storybook\n// or npm run build-storybook\n</code></pre>\n<p>위의 빌드 명령어를 실행하면 `storybook-static`` 이라는 폴더가 생기면서 정적 파일이 생기는 것을 볼 수 있었다.</p>\n<h2>tailwindcss 적용하기</h2>\n<p>테스트로 아래와 같이 간단한 Textbox 컴포넌트를 생성해보았다.</p>\n<pre><code class=\"language-tsx\">export default function Textbox() {\n  return (\n    &#x3C;div className='w-full border border-red-700 '>\n      &#x3C;p className='text-lg font-bold'>Textbox 입니다.&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그런데 문제가 있었다. <code>tailwindcss</code>가 적용되지 않는 것 같았다.</p>\n<h3>tailwindcss.config.js 파일 수정</h3>\n<p><code>tailwind</code>가 적용될 경로에 <code>stories</code> 폴더가 없었다. 그래서 아래와 같이 수정해주었다.</p>\n<pre><code class=\"language-ts\">import type { Config } from 'tailwindcss';\n\nconst config: Config = {\n  content: [\n    // 수정 전\n    // './src/pages/**/*.{js,ts,jsx,tsx,mdx}',\n    // './src/components/**/*.{js,ts,jsx,tsx,mdx}',\n    // './src/app/**/*.{js,ts,jsx,tsx,mdx}',\n\n    // 수정 후\n    './src/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {\n      backgroundImage: {\n        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',\n        'gradient-conic':\n          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',\n      },\n    },\n  },\n  plugins: [],\n};\nexport default config;\n</code></pre>\n<h3>preview.ts 파일 수정</h3>\n<p>그리고 <code>preview.ts</code> 파일에 <code>global css</code>를 <code>import</code> 해주었다.</p>\n<pre><code class=\"language-ts\">import type { Preview } from '@storybook/react';\n\n// css 파일을 import 해준다.\nimport '../src/app/globals.css';\n\nconst preview: Preview = {\n  parameters: {\n    actions: { argTypesRegex: '^on[A-Z].*' },\n    controls: {\n      matchers: {\n        color: /(background|color)$/i,\n        date: /Date$/,\n      },\n    },\n  },\n};\n\nexport default preview;\n</code></pre>\n<p>수정 후 아래와 같이 잘 적용된 것을 볼 수 있었다.</p>",
            "url": "https://nostrss.me/155-next13-storybook",
            "title": "Nextjs 13에서 스토리북 사용하기(with tailwindcss)",
            "summary": "스토리북으로 UI 단위 컴포넌트를 문서화해보자",
            "date_modified": "2023-09-05T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "app",
                "storybook",
                "tailwindcss"
            ]
        },
        {
            "id": "154-next-yarnberry",
            "content_html": "<h2>설치 환경 버전 정보</h2>\n<blockquote>\n<p>node : 18.13.0</p>\n</blockquote>\n<blockquote>\n<p>yarn : 3.6.3</p>\n</blockquote>\n<blockquote>\n<p>next : 13.4.19</p>\n</blockquote>\n<h2>next.js 프로젝트 생성</h2>\n<p>먼저 <code>next.js</code> 프로젝트를 생성하자.</p>\n<p>일반적으로 가장 많이 설치하는 <code>npx create-next-app</code>을 사용하여 설치했다.</p>\n<pre><code class=\"language-bash\">npx create-next-app@latest yarnberry-next13\n</code></pre>\n<h2>node_modules 삭제</h2>\n<p>설치가 완료되면 next.js 프로젝트를 <code>vscode</code>로 열어보자.</p>\n<p><code>yarnberry</code>를 사용하면 앞으로 <code>node_modules</code>를 사용하지 않게 되기 때문에, 기존에 설치된 <code>node_modules</code>를 삭제해줬다.</p>\n<h2>yarnberry 버전으로 전환</h2>\n<p>이제 <code>yarn berry</code> 버전으로 전환해보자. 아래의 명령어를 실행해줬다.</p>\n<pre><code class=\"language-bash\">yarn set version berry\n</code></pre>\n<p>위 커맨드를 실행하면 아래와 같이 실행되면서 <code>yarnberry</code> 버전으로 전환된다.</p>\n<p>조금은 생소한 실행화면과 함께 아래와 같이 진행된다.</p>\n<h2>yarnberry 모드에서 패키지 재설치</h2>\n<p>자 이제 삭제한 패키지를 <code>yarnberry</code> 모드에서 재설치 해보자. 설치 명령어는 기존과 동일하다.</p>\n<pre><code class=\"language-bash\">yarn install\n</code></pre>\n<p>설치가 완료되어 <code>vscode</code>를 다시 확인해봤다.</p>\n<p>이제는 패키지를 설치하여도 <code>node_modules</code>가 생성되지 않는 것을 확인할 수 있었다.</p>\n<p>그리고 생성된 <code>.yarn/cache</code> 폴더를 살펴봤다.</p>\n<p>패키지들이 압축파일로 저장되어 있는 것을 확인할 수 있었다.</p>\n<p>기존에는 <code>node_modules</code> 폴더 용량이 커서 <code>github</code>에 푸쉬하지 않는것이 일반적이었다.</p>\n<p>그렇기 때문에 공동작업자가 있을 경우, 소스코드를 받아서 실행하기 위해서는 패키지를 npm에서 재설치 해야했다.</p>\n<p>그리고 만약 이 과정에서 npm 패키지에서 사라진 것이 있다면, 소스코드를 실행할 수 없는 상황이 발생할 수도 있었다.</p>\n<p><em><strong>하지만 <code>yarnberry</code> 모드에서 패키지들은 압축되어 용량이 작기 때문에, github에 설치된 패키지들을 함께 푸쉬한다고 한다. 이로서 공동작업자는 소스코드를 받아서 바로 실행할 수 있는 것이다.</strong></em></p>\n<h2>gitignore에 코드 추가</h2>\n<p><code>yarnberry</code> 모드에 맞게 <code>gitignore</code>에 코드를 추가해줬다.</p>\n<pre><code># yarn berry\n\n.yarn/\\*\n!.yarn/cache\n!.yarn/patches\n!.yarn/plugins\n!.yarn/releases\n!.yarn/sdks\n!.yarn/versions\n</code></pre>\n<h2>typescript 설정</h2>\n<blockquote>\n<p>이 부분은 링크의 도움을 받아 진행했다.</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.dramancompany.com/2023/02/%EB%A6%AC%EB%A9%A4%EB%B2%84-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A2%8C%EC%B6%A9%EC%9A%B0%EB%8F%8C-yarn-berry-%EB%8F%84%EC%9E%85%EA%B8%B0/\">🔗 리멤버 웹 서비스 좌충우돌 Yarn Berry 도입기 바로가기 🔗</a></p>\n</blockquote>\n<p>현재 상태에서 작성되어 있는 코드를 보면 <code>typescript</code> 에러가 발생하고 있었다.</p>\n<p>기존에 node_modules에서 모듈을 가져오던 방식이 아닌, yarnberry에서 모듈을 가져오는 방식으로 변경되었기 때문에 발생하는 에러이다.</p>\n<pre><code class=\"language-bash\">yarn dlx @yarnpkg/sdks vscode\n</code></pre>\n<p>위의 커맨드를 실행하면 아래와 같이 vscode 오른쪽 하단에 얼럿이 뜬다.</p>\n<p>여기서 허용을 해줘도 되고 아래처럼 별도로 <code>타입스크립트 버전</code>을 설정해줘도 된다.</p>\n<blockquote>\n<p>타입스크립트 버전 검색</p>\n</blockquote>\n<blockquote>\n<p>타입스크립트 버전 선택</p>\n</blockquote>\n<h2>테스트</h2>\n<h3>개발모드 테스트 (yarn dev) : 성공</h3>\n<h3>빌드 테스트 (yarn build) : 성공</h3>\n<h3>공동 작업자 시점에서 테스트</h3>\n<p>먼저 생성한 프로젝트를 github에 푸쉬해 두었다.</p>\n<blockquote>\n<p><a href=\"https://github.com/nostrss/yarnberry-next13\">🔗 yarnberry-next13 레파지토리 바로가기 🔗</a></p>\n</blockquote>\n<p>이제 공동작업자 입장에서 소스코드를 받아서 실행해보자.</p>\n<p>위 레파지토리를 <code>git clone</code> 받고, <code>yarn dev</code>를 실행해봤다.</p>\n<p>터미널에서 정상적으로 실행이 되고 local:3000에서도 정상적으로 실행이 되는 것을 확인할 수 있었다.</p>",
            "url": "https://nostrss.me/154-next-yarnberry",
            "title": "Next.js 13 프로젝트 yarn berry로 전환하기",
            "summary": "Next 프로젝트 인스톨 없이 클론받아 바로 써보기",
            "date_modified": "2023-09-04T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "yarnberry",
                "migration"
            ]
        },
        {
            "id": "153-nestjs-dto",
            "content_html": "<h2>DTO(Data Transfer Object)란?</h2>\n<p>nest.js를 공부하면서 생소한 용어들이 있었는데, 그중 하나가 바로 DTO(Data Transfer Object)였다.</p>\n<blockquote>\n<p>데이터 전송 객체(data transfer object, DTO)는 프로세스 간에 데이터를 전달하는 객체이다. 프로세스 간 통신이 일반적으로 원격 인터페이스(예: 웹 서비스)로 재정렬하면서 이루어지게 되는데 여기에서 각 호출의 비용이 많다는 점을 동기로 하여 이용하게 된다. 각 호출의 비용이 큰 것이 클라이언트와 서버 간 왕복 시간과 관련되기 때문에 호출의 수를 줄이기 위해 여러 호출에 의해 전송되는 데이터를 축적하면서 오직 하나의 호출만으로 서비스되는 객체인 DTO를 사용하는 것이다.</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%A0%84%EC%86%A1_%EA%B0%9D%EC%B2%B4\">🔗 위키피디아 바로가기 🔗</a></p>\n</blockquote>\n<p>즉, 클라이언트, 서버, 데이터베이스 간에 통신하기 전에 <code>유효성</code> 검사를 하고, <code>데이터</code>를 변환하는 역할을 하는 것 같다.</p>\n<p>프론트 개발자 입장에서 이해를 해보면 <code>interface</code>로 <code>타입</code>만 지정해주는 것이 아니라, 요청을 보내거나 받을 때 <code>interface</code>로 지정된 타입으로 <code>형변환</code>까지 해주는 역할을 한다고 생각하면 될 것 같다.</p>\n<h2>DTO를 사용하는 이유</h2>\n<blockquote>\n<p><a href=\"https://dev.to/bivor/why-dtos-are-a-must-have-in-nestjs-api-development-3j2j\">🔗 관련글 바로가기 🔗</a></p>\n</blockquote>\n<p>위 링크의 글을 읽어보니 DTO를 사용하는 이유는 아래와 같다.</p>\n<blockquote>\n<ul>\n<li>DTO는 클라이언트와 서버 간의 문제를 명확하게 분리할 수 있다.</li>\n<li>API의 복잡성을 줄이고 유지 관리를 더 쉽게 만드는 데 도움이 될 수 있다.</li>\n</ul>\n</blockquote>\n<p>리액트에서 타입스크립트를 사용하는 것과 비슷한 이유라고 생각하면 될 것 같다.</p>\n<p>좀 더 안정적이고, 통신간에 타입으로 인한 오류를 사전에 방지할 수 있는 장점이 있기 때문에 사용하는 것으로 보인다.</p>\n<h2>DTO 예시</h2>\n<pre><code class=\"language-ts\">import { ApiProperty } from '@nestjs/swagger';\nimport { IsNotEmpty, IsNumber } from 'class-validator';\n\nexport class CreateBoardDto {\n  @IsNumber()\n  @IsNotEmpty()\n  @ApiProperty({\n    description: '작성자 아이디',\n    required: true,\n    example: '1',\n  })\n  userId: number;\n\n  @IsNotEmpty()\n  @ApiProperty({\n    description: '내용',\n    required: true,\n    example: '안녕하세요',\n  })\n  content: string;\n}\n</code></pre>\n<p>위의 코드에서 <code>CreateBoardDto</code>는 <code>userId</code>와 <code>content</code>라는 두개의 속성을 가지고 있는데, 위 코드를 React 코드로 표현하면 아래와 비슷할 것 같다.</p>\n<pre><code class=\"language-ts\">interface ICreateBoardDto {\n  userId: number;\n  content: string;\n}\n\nexport default function CreateBoardDto(dto: ICreateBoardDto) {\n  return {\n    userId: Number(dto.userId),\n    content: String(dto.content),\n  };\n}\n</code></pre>\n<p>그리고 Service 코드에서는 위에 지정한 DTO의 형식으로 데이터를 가져 올수 있게 된다.</p>\n<pre><code class=\"language-ts\">async create(data: CreateBoardDto) {\n    return this.boardRepository.save(data);\n  }\n</code></pre>\n<h2>class-validator와 class-transformer</h2>\n<p>위의 역할을 하기 위해서는 추가적인 npm 패키지가 필요하다.</p>\n<p>찾아보니 아래 2개의 패키지를 많이 사용하는 것 같다.</p>\n<blockquote>\n<p><a href=\"https://www.npmjs.com/package/class-validator\">🔗 npm class-validator 바로가기 🔗</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.npmjs.com/package/class-transformer\">🔗 npm class-transformer 바로가기 🔗</a></p>\n</blockquote>\n<p><code>class-validator</code>는 <code>DTO</code>의 유효성 검사를 해주고, <code>class-transformer</code>는 <code>DTO</code>의 형변환을 해주는 역할을 한다.</p>\n<p>위의 패키지를 설치하고, <code>main.ts</code>에 아래와 같이 ValidationPipe를 설정해주면 DTO에서 지정한 유효성 검사와 형변환을 자동으로 해준다.</p>\n<pre><code class=\"language-ts\">import { ValidationPipe } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const port = 3000;\n  const app = await NestFactory.create(AppModule);\n\n  // ValidationPipe 전역 적용\n  app.useGlobalPipes(\n    new ValidationPipe({\n      // class-transformer 적용\n      transform: true,\n    })\n  );\n\n  await app.listen(port);\n  console.info(`listening on port ${port}`);\n}\nbootstrap();\n</code></pre>",
            "url": "https://nostrss.me/153-nestjs-dto",
            "title": "[Nest] DTO, 그게 뭐야? 왜쓰는데? 어떻게 쓰는데?",
            "summary": "이름도 생소한 DTO, 그것이 알고 싶다.",
            "date_modified": "2023-09-01T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nestjs",
                "dto",
                "validator",
                "transformer"
            ]
        },
        {
            "id": "152-nextjs-middleware-edge",
            "content_html": "<p>얼마 전 팀프로젝트에 <code>Next.js</code>의 <code>Middleware</code> 파일을 사용하여 github 로그인 관련 기능을 구현하려고 했었다.</p>\n<blockquote>\n<p><a href=\"https://nextjs.org/docs/pages/building-your-application/routing/middleware\">🔗 Next.js Middleware 공식문서 🔗</a></p>\n</blockquote>\n<p>기능 설명</p>\n<ul>\n<li>로그인 버튼 클릭</li>\n<li>깃헙에서 리다이렉트 url로 페이지를 다시 보내준다.</li>\n<li>리다이렉트 url 쿼리스트링 중에서 code값을 받아온다.</li>\n<li>받아온 code값을 이용하여 api 통신을 하여 토큰 값을 받아온다.</li>\n<li>토큰 값으로 쿠키를 생성한다.</li>\n</ul>\n<h2>구현코드</h2>\n<p><code>root</code> 위치에 <code>middleware.ts</code> 파일을 생성하고 아래와 같이 작성해주었다.</p>\n<pre><code class=\"language-tsx\">// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport {\n  BLOGRASS_API_BASE_URL,\n  BLOGRASS_AUTH_GET_TOKEN,\n} from './constants/api';\nimport { ACCESS_TOKEN, REFRESH_TOKEN } from './constants/common';\n\n// This function can be marked `async` if using `await` inside\nexport async function middleware(request: NextRequest) {\n  const url = new URL(request.url);\n  const code = new URLSearchParams(url.search).get('code') || '';\n  let accessToken = request.cookies.get(ACCESS_TOKEN)?.value;\n  let refreshToken = request.cookies.get(REFRESH_TOKEN)?.value;\n\n  const getAuthToken = async () => {\n    const data = await fetch(\n      `${BLOGRASS_API_BASE_URL}${BLOGRASS_AUTH_GET_TOKEN}${code}`\n    );\n    const jsonData = await data.json();\n    return jsonData.result[0];\n  };\n\n  if (code &#x26;&#x26; !accessToken &#x26;&#x26; !refreshToken) {\n    const data = await getAuthToken();\n    accessToken = data.accessToken;\n    refreshToken = data.refreshToken;\n    const response = NextResponse.next();\n    if (accessToken &#x26;&#x26; refreshToken) {\n      response.cookies.set(ACCESS_TOKEN, accessToken);\n      response.cookies.set(REFRESH_TOKEN, refreshToken);\n    }\n    return response;\n  }\n}\n\nexport const config = {\n  matcher: '/',\n};\n</code></pre>\n<h2>문제 발생</h2>\n<p>개발모드에서는 상관없었는데, 배포 후에 문제가 발생했다.</p>\n<p><code>vercel</code>을 프론트 서버로 사용하고 있는데, 배포 후에 <code>edge runtime</code> 에러가 발생해서 롤백을 한 적이 있다.</p>\n<p>그래서 <code>edge runtime</code>에 대해서 알아보았다.</p>\n<h2>Edge runtime이란?</h2>\n<p><code>Next</code>에서 런타임은 2가지가 존재한다.</p>\n<ul>\n<li><code>Node.js Runtime</code>(우리가 일반적으로 사용하는 런타임)</li>\n<li><code>Edge Runtime</code></li>\n</ul>\n<p>Next.js에서 <code>Edge</code> 런타임은 경량화된 <code>Node.js</code> <code>API</code>의 <em>하위 집합</em>이라 <code>Node.js</code> <code>API</code>의 일부 기능만 사용할 수 있다.</p>\n<p>사용가능한 <code>API</code>는 아래 링크에서 확인할 수 있다.</p>\n<blockquote>\n<p><a href=\"https://nextjs.org/docs/pages/api-reference/edge\">🔗 edgeruntime api 바로가기 🔗</a></p>\n</blockquote>\n<p>링크에서 보듯 사용할 수 있는 API가 한정되어 있으며 <em>npm 패키지를 사용할 수 없다</em>.</p>\n<blockquote>\n<p>그래서 <code>edge runtime</code>에서는 <code>axios</code>를 사용할 수 없었다.</p>\n</blockquote>\n<p>또한 vercel에서도 사용할 때 여러가지 제약이 있다.</p>\n<blockquote>\n<p><a href=\"https://vercel.com/docs/functions/edge-functions/limitations\">🔗 vercel edge function 제한 바로가기 🔗</a></p>\n</blockquote>\n<p>그래서 개발모드에서는 작동을 했으나 vercel에 배포 후에는 에러가 발생한 것으로 추측이 된다.</p>\n<h2>결론</h2>\n<blockquote>\n<ul>\n<li>next.js middleware는 edge runtime에서 작동한다.</li>\n<li>edge runtime은 경량화된 node.js API의 하위 집합이다.</li>\n<li>edge runtime에서는 npm 패키지를 사용할 수 없다.</li>\n<li>그리고 vercel에서도 사용할 때 여러가지 제약이 있다.</li>\n<li>middleware에서는 간단한 로직만 사용하는 것이 좋을 것 같다.</li>\n</ul>\n</blockquote>",
            "url": "https://nostrss.me/152-nextjs-middleware-edge",
            "title": "[NEXT] Middleware와 Edge Functions",
            "summary": "새로운 걸 사용하기 전에는 사전학습을 충분히 하자. Next.js Middleware를 사용하면서 발생한 문제점과 해결방법",
            "date_modified": "2023-08-31T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nestjs",
                "edge",
                "vercel",
                "runtime",
                "middleware"
            ]
        },
        {
            "id": "151-error-nest-no-metadata",
            "content_html": "<p><code>Nest.js</code>에서 <code>typeorm</code>을 연결하여 사용하려고 하던 중 아래와 같은 에러가 발생했다.</p>\n<pre><code class=\"language-bash\">[Nest] 87109  - 2023. 08. 29. 오후 9:41:15   ERROR [ExceptionsHandler] No metadata for \"Board\" was found.\nEntityMetadataNotFoundError: No metadata for \"Board\" was found.\n    at DataSource.getMetadata (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/data-source/DataSource.ts:444:30)\n    at Repository.get metadata [as metadata] (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/repository/Repository.ts:53:40)\n    at Repository.find (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/repository/Repository.ts:524:39)\n    at BoardService.findAll (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/board/board.service.ts:35:33)\n    at BoardController.findAll (/Users/jintaekwoo/github/private/fastcampus/simple-board/src/board/board.controller.ts:24:30)\n    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-execution-context.js:38:29\n    at InterceptorsConsumer.intercept (/Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/interceptors/interceptors-consumer.js:11:20)\n    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-execution-context.js:46:60\n    at /Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/@nestjs/core/router/router-proxy.js:9:23\n    at Layer.handle [as handle_request] (/Users/jintaekwoo/github/private/fastcampus/simple-board/node_modules/express/lib/router/layer.js:95:5)\n</code></pre>\n<h2>해결을 위한 시도</h2>\n<h3>@Entity() 누락</h3>\n<ul>\n<li><code>entitiy</code> 파일에 <code>@Entity()</code> 데코레이터가 누락여부 확인</li>\n<li><code>Module</code>에 해당 <code>Entity</code>가 등록되어있는지 확인</li>\n<li><code>typeorm</code> 버전 낮추기(0.3.17 => 0.2.X)\n<ul>\n<li>버전을 낮추지 않고 수정해보기 위해 변경하지 않았다.</li>\n</ul>\n</li>\n<li>typeorm <code>DataSource</code>의 entities 경로가 잘못되었는지 확인</li>\n</ul>\n<h3>해결(app.module.ts 수정)</h3>\n<pre><code class=\"language-ts\">// app.module.ts\n// 변경전\n\n@Module({\n  imports: [\n    ConfigModule(),\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: 'localhost',\n      port: 5432,\n      username: 'admin',\n      password: '**********',\n      database: 'postgres',\n      entities: [__dirname + '/**/*.entity.{.ts,.js}'],\n      synchronize: false,\n    }),\n    BoardModule,\n  ],\n    controllers: [AppController],\n  providers: [AppService],\n})\n\n// 변경후\n@Module({\n  imports: [\n    ConfigModule(),\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: process.env.DB_HOST,\n      port: parseInt(process.env.DB_PORT),\n      username: process.env.DB_USERNAME,\n      password: process.env.DB_PASSWORD,\n      database: process.env.DB_NAME,\n      entities: [__dirname + '/**/*.entity{.ts,.js}'],\n      synchronize: false,\n      logging: true,\n    }),\n    BoardModule,\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\n\n</code></pre>\n<p>위와 같이 환경변수를 사용하도록 수정하니 정상적으로 동작하였다.</p>\n<h2>해결 됐지만 여전한 궁금증</h2>\n<blockquote>\n<p>환경변수를 사용하는 것과 하드코딩하는 것의 차이는 무엇일까</p>\n</blockquote>",
            "url": "https://nostrss.me/151-error-nest-no-metadata",
            "title": "[Nest] ERROR [ExceptionsHandler] No metadata",
            "summary": "해결이 됐는데도 이유를 모르는 이 찝찝함이란..",
            "date_modified": "2023-08-30T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nestjs",
                "typeorm",
                "express",
                "error",
                "repository",
                "datasource"
            ]
        },
        {
            "id": "147-toast-next-2",
            "content_html": "<blockquote>\n<ul>\n<li><a href=\"https://nostrss.github.io/2023-08-25/146-toast-next-1\">1.TOAST Editor에 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/147-toast-next-2\">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/148-toast-next-3\">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/149-toast-next-4\">4.TOAST Editor Viewer 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/150-toast-next-5\">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>\n</ul>\n</blockquote>\n<h2>Toast Editor에 작성한 글 내용을 불러오기</h2>\n<pre><code>src\n ┣ components\n ┃ ┣ newpost\n ┃ ┃ ┗ PostEditor.tsx // 에디터 컴포넌트\n ┣ pages\n ┃ ┣ newpost\n ┃ ┃ ┗ index.tsx // 에디터의 내용을 api 요청으로 서버에 전송\n ┃ ┗ index.tsx\n</code></pre>\n<p>에디터에 글을 작성하고, 서버에 저장하기 위해서는 먼저 에디터에 작성된 글 내용을 불러와야 한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/newpost/index.tsx\nconst editorRef = useRef&#x3C;Editor>(null);\n\nconst onSubmitNewPost = (e: FormEvent) => {\n  e.preventDefault();\n  // 마크다운 형식으로 작성한 글 내용을 불러온다.\n  const markDownContent = editorRef.current?.getInstance().getMarkdown();\n  console.log(markDownContent);\n};\n\nreturn (\n  &#x3C;section>\n    &#x3C;form onSubmit={onSubmitNewPost}>\n      &#x3C;PostEditor editorRef={editorRef} />\n    &#x3C;/form>\n  &#x3C;/section>\n);\n</code></pre>\n<p><code>useRef</code>를 사용하여 <code>editorRef</code>를 선언하였고, <code>editorRef</code>를 <code>PostEditor</code>에 <code>Props</code>로 전달하게 되면 유저가 작성한 글정보가 <code>editorRef</code>에 담기게 될 것이다.</p>\n<blockquote>\n<p><code>useState</code>가 아닌 <code>useRef</code>를 사용한 이유는, <code>useState</code>를 사용하면 <code>onChange</code> 이벤트가 발생할 때마다 렌더링이 일어나기 때문에, 글자를 입력하는 동안에도 렌더링이 일어나게 될 것이다. 이를 방지하고자 <code>useRef</code>를 사용하였다.</p>\n</blockquote>\n<p><code>editorRef</code>에서 작성된 글 내용을 뽑아내기 위해서는 <code>getInstance()</code>를 사용하였다.</p>\n<p>여기서 <code>Toast Editor</code>는 2가지 모드를 제공하는데, <code>markdown</code>과 <code>wysiwyg</code>이다.</p>\n<ul>\n<li><code>markdown</code> : README.md 파일처럼 작성하는 에디터이다. 이런 형식으로 불러오기 위해서는 getMarkdown()을 사용하면된다.</li>\n<li><code>wysiwyg</code> : 일반적인 글쓰기 편집기 형식의 에디터이다. 이런 형식으로 불러오기 위해서는 getHtml()을 사용하면 된다.</li>\n</ul>\n<p>나는 마크다운 형식만 사용할 것이기 때문에 <code>getMarkdown()</code>을 사용하였다.</p>\n<p>이제는 <code>Props</code>를 받는 <code>PostEditor</code> 컴포넌트를 수정해야겠다.</p>\n<pre><code class=\"language-tsx\">//src/components/newpost/PostEditor.tsx\nimport { Editor } from '@toast-ui/react-editor';\nimport '@toast-ui/editor/dist/toastui-editor.css';\nimport '@toast-ui/editor/dist/i18n/ko-kr';\nimport { RefObject } from 'react';\n\nexport default function PostEditor({\n  editorRef,\n}: {\n  editorRef: RefObject&#x3C;Editor>;\n}) {\n  return (\n    &#x3C;Editor\n      ref={editorRef}\n      previewStyle='vertical'\n      height='800px'\n      initialEditType='markdown'\n      placeholder='Write Something'\n      hideModeSwitch={true}\n      language='ko-KR'\n    />\n  );\n}\n</code></pre>\n<p><code>Props</code>로 전달받은 <code>editorRef</code>를 <code>Editor</code> 컴포넌트의 <code>ref</code>로 전달해주었다.</p>\n<p>이제 테스트를 해보자.</p>\n<p>콘솔에 정상적으로 글 내용이 출력되는 것을 확인할 수 있었다.</p>",
            "url": "https://nostrss.me/147-toast-next-2",
            "title": "[NEXT] TOAST Editor에서 작성한 글정보 불러오기(useRef)",
            "summary": "에디터에 적어놓은 글을 어떻게 불러올까? useState or useRef?",
            "date_modified": "2023-08-25T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "javascript",
                "typescript",
                "toast",
                "editor"
            ]
        },
        {
            "id": "148-toast-next-3",
            "content_html": "<blockquote>\n<ul>\n<li><a href=\"https://nostrss.github.io/2023-08-25/146-toast-next-1\">1.TOAST Editor에 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/147-toast-next-2\">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/148-toast-next-3\">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/149-toast-next-4\">4.TOAST Editor Viewer 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/150-toast-next-5\">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>\n</ul>\n</blockquote>\n<h2>Toast Editor에서 이미지 업로드 하기</h2>\n<p><code>Toast Editor</code>는 이미지 업로드를 위한 UI를 아래와 같이 제공하고 있다.</p>\n<p>그리고 이미지를 선택하고 OK 버튼을 누르면 이미지가 아래와 같이 노출되게 된다.</p>\n<p>좌측에 노출된 복잡한 코드는 base64로 인코딩된 이미지 코드인데,유저가 이렇게 실사용하기는 어려울 것 같다.</p>\n<p>그래서 아래와 같이 수정을 해보려고 한다.</p>\n<blockquote>\n<ol>\n<li>업로드할 이미지를 선택한다.</li>\n<li>OK버튼을 누르면 선택한 이미지를 서버에 업로드한다.</li>\n<li>업로드가 완료되면, 업로드된 이미지의 주소를 받는다.</li>\n<li>업로드 된 이미지의 주소를 에디터에 노출한다.</li>\n</ol>\n</blockquote>\n<p>1번은 이미 구현되어 있다. 2번부터 직접 구현해보도록 하자.</p>\n<h2>OK버튼을 누르면 이미지 업로드 함수를 실행하기</h2>\n<p>그런데 OK 버튼을 눌렀을 때 내가 작성한 이미지 업로드 함수가 바로 실행되도록 어떻게 해야할까?</p>\n<p>이전에 <code>EditorOptions</code>의 문서에서 <code>hooks</code>라는 <code>Props</code>를 본적이 있었다.</p>\n<blockquote>\n<p><a href=\"https://nhn.github.io/tui.editor/latest/ToastUIEditorCore\">🔗 EditorOptions 문서 바로가기 🔗</a></p>\n</blockquote>\n<p>설명에 이미지 업로드를 위한 <code>hooks</code>라고 당당히 기재되어 있는 것을 볼 수 있다. 역시 문서는 잘 써놓은 것 같다.</p>\n<p><code>hooks</code>를 사용하면 되지 않을까 예상은 되는데 사용하는 방법은 어떻게 될까?</p>\n<p>조금 더 알아봐야겠다.</p>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/editor/types/editor.d.ts\nexport interface EditorOptions {\n (...)\n  hooks?: HookMap;\n  (...)\n}\n\nexport type HookMap = {\n  addImageBlobHook?: (blob: Blob | File, callback: HookCallback) => void;\n};\n\ntype HookCallback = (url: string, text?: string) => void;\n</code></pre>\n<p><code>hooks</code>에 대한 타입을 확인해보니, <code>addImageBlobHook</code>이라는 함수가 있고, 이 함수는 <code>blob</code>과 <code>callback</code>을 인자로 받는다.</p>\n<p>그리고 <code>callback</code>은 <code>url</code>과 <code>text</code>를 인자로 받는다.</p>\n<p>이제 <code>blob</code>과 <code>callback</code>을 인자로 받는 이미지 업로드 함수를 만들어서 연결 해주면 될 것 같다.</p>\n<h3>이미지 업로드 함수</h3>\n<pre><code class=\"language-ts\">export const imageAPI = {\n  postUploadImage: async (image: File | Blob, callback: HookCallback) => {\n    // 이미지 업로드를 위한 formData 생성\n    const formData = new FormData();\n    formData.append('file', image);\n\n    try {\n      // 이미지 업로드 후 이미지 id 받기\n      const result = await axios({\n        method: 'post',\n        url: BLOGRASS_IMAGE_UPLOAD,\n        data: formData,\n      });\n\n      // 이미지 id를 이용하여 이미지 url 생성\n      const imageUrl =\n        await `${BLOGRASS_IMAGE_BUCKET_URL}/${result.data.result[0]}`;\n\n      // callback에 이미지 url과 alt_text를 인자로 넣어준다.\n      callback(imageUrl, 'alt_text');\n    } catch (error) {\n      console.error(error);\n    }\n  },\n};\n</code></pre>\n<blockquote>\n<ol>\n<li><code>image</code>와 <code>callback</code>을 인자로 받는다.</li>\n<li><code>image</code>를 서버에 업로드 한다.</li>\n<li>업로드가 완료되면, 업로드된 이미지의 <code>URL</code>을 받는다.</li>\n<li><code>callback</code>에 이미지의 <code>URL</code>과 텍스트를 인자로 넣어준다.</li>\n</ol>\n</blockquote>\n<h3>hooks에 이미지 업로드 함수 연결하기</h3>\n<p>아래와 같이 <code>hooks</code>에 이미지 업로드 함수를 연결해주면 된다.</p>\n<pre><code class=\"language-tsx\">export default function PostEditor({\n  editorRef,\n}: {\n  editorRef: RefObject&#x3C;Editor>;\n}) {\n  return (\n    &#x3C;Editor\n      ref={editorRef}\n      previewStyle='vertical'\n      height='800px'\n      initialEditType='markdown'\n      placeholder='Write Something'\n      hideModeSwitch={true}\n      language='ko-KR'\n      hooks={{ addImageBlobHook: imageAPI.postUploadImage }}\n    />\n  );\n}\n</code></pre>\n<blockquote>\n<p>테스트를 해보니 아래와 같이 이미지가 업로드 되는 것을 확인 할 수 있었다.</p>\n</blockquote>",
            "url": "https://nostrss.me/148-toast-next-3",
            "title": "[NEXT] TOAST Editor에서 이미지 업로드하기(hooks)",
            "summary": "블로그에 이미지가 없으면 섭섭하니깐, Toast에서 제공하는 hooks에 이미지 업로드 함수를 연결해보자.",
            "date_modified": "2023-08-25T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "javascript",
                "typescript",
                "toast",
                "editor"
            ]
        },
        {
            "id": "146-toast-next-1",
            "content_html": "<blockquote>\n<ul>\n<li><a href=\"https://nostrss.github.io/2023-08-25/146-toast-next-1\">1.TOAST Editor에 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/147-toast-next-2\">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/148-toast-next-3\">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/149-toast-next-4\">4.TOAST Editor Viewer 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/150-toast-next-5\">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>\n</ul>\n</blockquote>\n<h2>버전 정리</h2>\n<ul>\n<li><code>Next.js</code> : 13.4.10\n<ul>\n<li><code>pages Router</code>를 사용하였다.</li>\n</ul>\n</li>\n<li><code>@toast-ui/editor</code> - 3.2.2</li>\n<li><code>@toast-ui/react-editor</code> - 3.2.3</li>\n</ul>\n<h2>대략적인 폴더 구조</h2>\n<pre><code>src\n ┣ components\n ┃ ┣ newpost\n ┃ ┃ ┗ PostEditor.tsx\n ┣ pages\n ┃ ┣ newpost\n ┃ ┃ ┗ index.tsx\n ┃ ┗ index.tsx\n</code></pre>\n<h2>사용법 익히기</h2>\n<blockquote>\n<p><a href=\"https://ui.toast.com/tui-editor\">🔗 Toast Editor 소개 바로가기 🔗</a></p>\n</blockquote>\n<p><code>Toast Editor</code>는 <code>NHN</code>이 만든 오픈소스 에디터이다.</p>\n<p>그래서 한국에서 많이 사용하고, 검색 시에도 한국어 결과가 많이 나오는 편이었다.</p>\n<p>나는 Next.js를 사용하고 있기 때문에 React 버전의 사용법을 찾아보았다.</p>\n<blockquote>\n<p><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/react-editor#-usage\">🔗 @toast-ui/react-editor 깃허브 바로가기 🔗</a></p>\n</blockquote>\n<p>위의 링크에서 소개한 사용법은 아래와 같았다.</p>\n<pre><code class=\"language-tsx\">import '@toast-ui/editor/dist/toastui-editor.css';\n\nimport { Editor } from '@toast-ui/react-editor';\n\nconst MyComponent = () => (\n  &#x3C;Editor\n    initialValue='hello react editor world!'\n    previewStyle='vertical'\n    height='600px'\n    initialEditType='markdown'\n    useCommandShortcut={true}\n  />\n);\n</code></pre>\n<p>위와 같이 <code>Editor</code>를 <code>import</code>하고 컴포넌트에 필요한 props를 전달해 주면 된다.</p>\n<p>그렇다면 <code>Editor</code>컴포넌트는 어떤 <code>props</code>를 가지고 있을까?</p>\n<h2>Editor 컴포넌트 살펴보기</h2>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/react-editor/index.d.ts\nexport class Editor extends Component&#x3C;EditorProps> {\n  getInstance(): ToastuiEditor;\n\n  getRootElement(): HTMLElement;\n}\n</code></pre>\n<p><code>Editor</code> 컴포넌트는 <code>Component&#x3C;EditorProps></code>타입을 상속받고 <code>getInstance</code>와 <code>getRootElement</code>라는 메서드를 가지고 있었다.</p>\n<p><code>props</code>를 알아보기 위해서 이번엔 상속받은 <code>EditorProps</code>를 살펴보았다.</p>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/react-editor/index.d.ts\nexport type EditorProps = Omit&#x3C;EditorOptions, 'el'> &#x26; Partial&#x3C;EventMapping>;\n</code></pre>\n<ol>\n<li>\n<p><code>Omit&#x3C;EditorOptions, 'el'></code>는 <code>EditorOptions</code>에서 <code>el</code>을 제외한 나머지 속성들을 상속받는다는 뜻이다.</p>\n</li>\n<li>\n<p><code>Partial&#x3C;EventMapping></code>는 <code>EventMapping</code>의 속성들을 선택적으로 상속받는다는 뜻이다.</p>\n</li>\n<li>\n<p>그리고 위의 두 타입을 합쳐서 <code>EditorProps</code>를 만들었다.</p>\n</li>\n</ol>\n<p>이중에 <code>EditorOptions</code>를 먼저 살펴보았다.</p>\n<h3>EditorOptions</h3>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/editor/types/editor.d.ts\nexport interface EditorOptions {\n  el: HTMLElement; // 이건 제외하고 상속을 받는다.\n  height?: string;\n  minHeight?: string;\n  initialValue?: string;\n  previewStyle?: PreviewStyle;\n  initialEditType?: EditorType;\n  events?: EventMap;\n  hooks?: HookMap;\n  language?: string;\n  useCommandShortcut?: boolean;\n  usageStatistics?: boolean;\n  toolbarItems?: (string | ToolbarItemOptions)[][];\n  hideModeSwitch?: boolean;\n  plugins?: EditorPlugin[];\n  extendedAutolinks?: ExtendedAutolinks;\n  placeholder?: string;\n  linkAttributes?: LinkAttributes;\n  customHTMLRenderer?: CustomHTMLRenderer;\n  customMarkdownRenderer?: ToMdConvertorMap;\n  referenceDefinition?: boolean;\n  customHTMLSanitizer?: Sanitizer;\n  previewHighlight?: boolean;\n  frontMatter?: boolean;\n  widgetRules?: WidgetRule[];\n  theme?: string;\n  autofocus?: boolean;\n  viewer?: boolean;\n}\n</code></pre>\n<p>엄청나게 많은 옵션들이 있다.</p>\n<p>하지만 다행히 문서로 잘 정리가 되어 있어서 각 옵션들이 어떤 역할을 하는지 확인할 수 있었다.</p>\n<blockquote>\n<p><a href=\"https://nhn.github.io/tui.editor/latest/ToastUIEditorCore\">🔗 EditorOptions 문서 바로가기 🔗</a></p>\n</blockquote>\n<p>위의 링크를 보면서 나에게 필요한 옵션들이 무엇인지 알 수 있었다.</p>\n<h3>EventMapping</h3>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/react-editor/index.d.ts\nexport interface EventMapping {\n  onLoad: EventMap['load'];\n  onChange: EventMap['change'];\n  onCaretChange: EventMap['caretChange'];\n  onFocus: EventMap['focus'];\n  onBlur: EventMap['blur'];\n  onKeydown: EventMap['keydown'];\n  onKeyup: EventMap['keyup'];\n  onBeforePreviewRender: EventMap['beforePreviewRender'];\n  onBeforeConvertWysiwygToMarkdown: EventMap['beforeConvertWysiwygToMarkdown'];\n}\n\nexport interface EventMap {\n  load?: (param: Editor) => void;\n  change?: (editorType: EditorType) => void;\n  caretChange?: (editorType: EditorType) => void;\n  focus?: (editorType: EditorType) => void;\n  blur?: (editorType: EditorType) => void;\n  keydown?: (editorType: EditorType, ev: KeyboardEvent) => void;\n  keyup?: (editorType: EditorType, ev: KeyboardEvent) => void;\n  beforePreviewRender?: (html: string) => string;\n  beforeConvertWysiwygToMarkdown?: (markdownText: string) => string;\n}\n</code></pre>\n<p><code>EventMapping</code>이라는 단어 그대로 사용 가능한 이벤트 함수와 이벤트 함수의 파라미터 타입을 정의하고 맵핑한 것 이었다.</p>\n<h2>컴포넌트 만들기</h2>\n<p>글작성 페이지는 <code>pages/newpost/index.tsx</code> 경로에 만들려고 한다.</p>\n<p>하지만 <code>index.tsx</code> 파일이 너무 커질것 같아 <code>components/newpost/PostEditor.tsx</code>파일에 <code>PostEditor</code>라는 컴포넌트를 별도로 만들고, <code>index.tsx</code>에서 import 하여 사용하려고 한다.</p>\n<p><code>PostEditor</code> 컴포넌트는 아래와 같이 작성했다.</p>\n<pre><code class=\"language-tsx\">// components/newpost/PostEditor.tsx\nimport { Editor } from '@toast-ui/react-editor';\nimport '@toast-ui/editor/dist/toastui-editor.css';\nimport '@toast-ui/editor/dist/i18n/ko-kr';\n\nexport default function PostEditor() {\n  return (\n    &#x3C;Editor\n      previewStyle='vertical'\n      height='800px'\n      initialEditType='markdown'\n      placeholder='Write Something'\n      hideModeSwitch={true}\n      language='ko-KR'\n    />\n  );\n}\n</code></pre>\n<p>그리고 <code>pages/newpost/index.tsx</code>에 import해서 사용하였다.</p>\n<blockquote>\n<p>📌 Toast에디터는 ssr을 지원하지 않기 때문에 <code>next/dynamic</code>을 사용하여 ssr을 하지 않도록 설정해주었다. 아마 React로 작업하는 경우에는 사용할 필요가 없을 것 같다.</p>\n</blockquote>\n<pre><code class=\"language-tsx\">import dynamic from 'next/dynamic';\n\nconst PostEditor = dynamic(() => import('@/components/newpost/PostEditor'), {\n  ssr: false,\n});\n</code></pre>\n<p>정상적으로 잘 나오는 것을 확인할 수 있었다.</p>",
            "url": "https://nostrss.me/146-toast-next-1",
            "title": "[NEXT] TOAST Editor 사용하기",
            "summary": "국산을 애용하자. 한국 에디더 Toast Editor를 사용해보자.",
            "date_modified": "2023-08-25T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "javascript",
                "typescript",
                "toast",
                "editor"
            ]
        },
        {
            "id": "150-toast-next-5",
            "content_html": "<blockquote>\n<ul>\n<li><a href=\"https://nostrss.github.io/2023-08-25/146-toast-next-1\">1.TOAST Editor에 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/147-toast-next-2\">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/148-toast-next-3\">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/149-toast-next-4\">4.TOAST Editor Viewer 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/150-toast-next-5\">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>\n</ul>\n</blockquote>\n<h2>TOAST Editor customHTMLSanitizer 사용하기</h2>\n<p>에디터의 경우 유저가 악의적인 용도로 스크립트를 삽입하여 공격할 위험이 있다.</p>\n<p>이를 방지하기 위해서는 HTML 요소에 공격을 하는 스크립트등을 삭제해야 한다.</p>\n<p>이런 기능을 하는 npm 패키지가 있는데, <code>Dompurify</code>이다.</p>\n<blockquote>\n<p><a href=\"https://www.npmjs.com/package/dompurify?activeTab=readme\">🔗 dompurify npm 페이지 바로가기 🔗</a></p>\n</blockquote>\n<h2>TOAST Editor 자체적인 Sanitizer</h2>\n<p>앞서 EditorOptions을 살펴봤을때 <code>customHTMLSanitizer</code>라는 Props가 존재하는 것을 확인할 수 있었다.</p>\n<blockquote>\n<p><a href=\"https://nhn.github.io/tui.editor/latest/ToastUIEditorCore\">🔗 EditorOptions 문서 바로가기 🔗</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://ui.toast.com/weekly-pick/ko_monthly_202004\">🔗 customHTMLSanitizer 옵션 기능 추가 🔗</a></p>\n</blockquote>\n<pre><code class=\"language-ts\">// node_modules/@toast-ui/editor/types/editor.d.ts\nexport interface EditorOptions {\n  (...)\n  customHTMLSanitizer?: Sanitizer;\n  (...)\n}\n</code></pre>\n<p><code>customHTMLSanitizer</code>라는 표현이 있는 것으로 보아 이런 생각이 들었다.</p>\n<blockquote>\n<p>혹시 Toast Editor에는 이미 Sanitizer가 적용되어 있는게 아닐까</p>\n</blockquote>\n<p>테스트를 해봐야겠다.</p>\n<p><code>dompurify</code> 페이지에 샘플코드가 있어서 이를 가져와서 테스트를 해봤다.\n<code>Markdown</code>, <code>wysiwyg</code> 모드 둘다 테스트를 해봤다.</p>\n<pre><code class=\"language-tsx\">const onSubmitNewPost = (e: FormEvent) => {\n  e.preventDefault();\n  const markDownContent = editorRef.current?.getInstance().getMarkdown();\n  const htmlContent = editorRef.current?.getInstance().getHTML();\n  console.log('1️⃣', markDownContent);\n  console.log('2️⃣', htmlContent);\n};\n</code></pre>\n<p>에디터에 샘플코드를 입력하고 어떻게 값이 반환되는지 확인해보았다.</p>\n<pre><code class=\"language-javascript\">DOMPurify.sanitize('&#x3C;img src=x onerror=alert(1)//>');\n// dompurify : &#x3C;img src=\"x\">\n// Markdown :  &#x3C;img src=x onerror=alert(1)//>\n// wysiwyg : &#x3C;p>&#x3C;img src=\"x\" contenteditable=\"false\">&#x3C;br>&#x3C;/p>\n\nDOMPurify.sanitize('&#x3C;svg>&#x3C;g/onload=alert(2)//&#x3C;p>');\n// dompurify : &#x3C;svg>&#x3C;g>&#x3C;/g>&#x3C;/svg>\n// Markdown : &#x3C;svg>&#x3C;g/onload=alert(2)//&#x3C;p>\n// wysiwyg : &#x3C;p>&#x26;lt;g/onload=alert(2)//&#x3C;/p>\n\nDOMPurify.sanitize('&#x3C;p>abc&#x3C;iframe//src=jAva&#x26;Tab;script:alert(3)>def&#x3C;/p>');\n// dompurify : &#x3C;p>abc&#x3C;/p>\n// Markdown : &#x3C;p>abc&#x3C;iframe//src=jAva&#x26;Tab;script:alert(3)>def&#x3C;/p>\n// wysiwyg : &#x3C;p>abc&#x3C;/p>\n\nDOMPurify.sanitize('&#x3C;math>&#x3C;mi//xlink:href=\"data:x,&#x3C;script>alert(4)&#x3C;/script>\">');\n// dompurify : &#x3C;math>&#x3C;mi>&#x3C;/mi>&#x3C;/math>\n// Markdown : &#x3C;math>&#x3C;mi//xlink:href=\"data:x,&#x3C;script>alert(4)&#x3C;/script>\">\n// wysiwyg : &#x3C;p>&#x26;lt;mi//xlink:href=\"data:x,alert(4)\"&#x26;gt;&#x3C;/p>\n\nDOMPurify.sanitize('&#x3C;TABLE>&#x3C;tr>&#x3C;td>HELLO&#x3C;/tr>&#x3C;/TABL>');\n// dompurify : &#x3C;table>&#x3C;tbody>&#x3C;tr>&#x3C;td>HELLO&#x3C;/td>&#x3C;/tr>&#x3C;/tbody>&#x3C;/table>\n// Markdown : &#x3C;TABLE>&#x3C;tr>&#x3C;td>HELLO&#x3C;/tr>&#x3C;/TABL>\n// wysiwyg : &#x3C;table>&#x3C;thead>&#x3C;tr>&#x3C;td>&#x3C;p>HELLO&#x3C;/p>&#x3C;/td>&#x3C;/tr>&#x3C;/thead>&#x3C;tbody>&#x3C;tr>&#x3C;/tr>&#x3C;/tbody>&#x3C;/table>\n\nDOMPurify.sanitize('&#x3C;UL>&#x3C;li>&#x3C;A HREF=//google.com>click&#x3C;/UL>');\n// dompurify : &#x3C;ul>&#x3C;li>&#x3C;a href=\"//google.com\">click&#x3C;/a>&#x3C;/li>&#x3C;/ul>\n// Markdown : &#x3C;UL>&#x3C;li>&#x3C;A HREF=//google.com>click&#x3C;/UL>\n// wysiwyg : &#x3C;ul>&#x3C;li>&#x3C;p>&#x3C;a href=\"//google.com\">click&#x3C;/a>&#x3C;/p>&#x3C;/li>&#x3C;/ul>\n</code></pre>\n<p><code>dompurify</code>와 방식은 다르지만 <code>wysiwyg</code> 모드에서는 Toast 에디터 자체적으로 <code>Sanitizer</code>가 적용되어 있는 것을 확인할 수 있었다.</p>\n<h2>Custom Sanitizer 사용하기</h2>\n<p>이제는 customHTMLSanitizer를 사용해보려고 한다.</p>\n<pre><code class=\"language-ts\">export type Sanitizer = (content: string) => string;\n</code></pre>\n<p><code>customHtmlSanitizer</code>는 <code>Sanitizer</code>라는 타입을 가지고 있고, <code>Sanitizer</code>는 <code>content</code>라는 <code>string</code>을 받아서 <code>string</code>을 반환하는 함수이다.</p>\n<p>일단 간단히 테스트를 해보기 위해서 아래와 같이 함수를 하나 작성하여 <code>customHTMLSanitizer</code>와 연결해보았다.</p>\n<pre><code class=\"language-tsx\">export default function PostEditor({\n  editorRef,\n}: {\n  editorRef: RefObject&#x3C;Editor>;\n}) {\n  // 테스트용 Sanitizer 함수\n  const testSanitizer = (text: string) => {\n    console.log(text);\n    return text;\n  };\n\n  return (\n    &#x3C;Editor\n      ref={editorRef}\n      previewStyle='vertical'\n      height='800px'\n      initialEditType='markdown'\n      placeholder='Write Something'\n      hideModeSwitch={true}\n      language='ko-KR'\n      customHTMLSanitizer={testSanitizer}\n    />\n  );\n}\n</code></pre>\n<p><code>testSanitizer</code> 함수가 잘 연결되어 작동을 한다면, <code>console.log(text)</code>가 실행되어 콘솔에 <code>text</code>가 출력될 것이다.</p>\n<p>텍스트를 입력할때 마다 직접 생성한 <code>testSanitizer</code> 함수를 실행하는 것을 확인할 수 있었다.</p>\n<blockquote>\n<p>즉, Toast Editor에는 이미 Sanitizer가 적용되어 있다. 그리고 별도의 Sanitizer를 적용하려면 customHTMLSanitizer에 string을 매개변수로 받아서 string을 반환하는 함수를 넣어주면 된다.</p>\n</blockquote>\n<h2>dompurify 적용하기</h2>\n<p>Toast Editor 자체적으로 Sanitizer가 적용되어 있지만, <code>dompurify</code>를 적용해보기로 했다.</p>\n<p>일단 글을 작성하는 에디터에 적용을 해주었다. 방법은 간단했다.</p>\n<pre><code class=\"language-tsx\">// dompurify Import\nimport * as DOMPurify from 'dompurify';\n\nexport default function PostEditor({\n  editorRef,\n}: {\n  editorRef: RefObject&#x3C;Editor>;\n}) {\n  const customSanitizer = DOMPurify.sanitize;\n\n  return (\n    &#x3C;Editor\n      ref={editorRef}\n      previewStyle='vertical'\n      height='800px'\n      initialEditType='markdown'\n      placeholder='Write Something'\n      hideModeSwitch={true}\n      language='ko-KR'\n      // customHTMLSanitizer에 dompurify 적용\n      customHTMLSanitizer={customSanitizer}\n    />\n  );\n}\n</code></pre>\n<p>그리고 <code>Viewer</code>에도 동일하게 적용을 해주었다.</p>\n<p>작성할때 이미 dompurify가 적용되어 있긴 하지만, <code>Viewer</code>에서도 <code>dompurify</code>를 적용해주는 것이 보안에 좋을 것 같아서 적용해주었다.</p>\n<pre><code class=\"language-tsx\">import { Viewer } from '@toast-ui/react-editor';\nimport * as DOMPurify from 'dompurify';\n\nexport default function EditorViewer({\n  initialValue,\n}: {\n  initialValue: string;\n}) {\n  const customSanitizer = DOMPurify.sanitize;\n\n  return (\n    &#x3C;Viewer initialValue={initialValue} customHTMLSanitizer={customSanitizer} />\n  );\n}\n</code></pre>",
            "url": "https://nostrss.me/150-toast-next-5",
            "title": "[NEXT] TOAST Editor customHTMLSanitizer 사용하기",
            "summary": "dangeroulySetInnerHTML을 사용하지 않고 dompurify를 Toast Editor에 적용해보자.",
            "date_modified": "2023-08-25T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "javascript",
                "typescript",
                "toast",
                "dompurify"
            ]
        },
        {
            "id": "149-toast-next-4",
            "content_html": "<blockquote>\n<ul>\n<li><a href=\"https://nostrss.github.io/2023-08-25/146-toast-next-1\">1.TOAST Editor에 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/147-toast-next-2\">2.TOAST Editor에 작성한 글정보 불러오기(useRef)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/148-toast-next-3\">3.TOAST Editor에서 이미지 업로드하기(hooks)</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/149-toast-next-4\">4.TOAST Editor Viewer 사용하기</a></li>\n<li><a href=\"https://nostrss.github.io/2023-08-25/150-toast-next-5\">5.TOAST Editor customHTMLSanitizer 사용하기</a></li>\n</ul>\n</blockquote>\n<h2>TOAST Editor Viewer 사용하기</h2>\n<p>예전에 <code>React Quill</code>의 경우에는 <code>Viewer</code>를 따로 제공하지 않고, <code>readOnly</code> 속성을 통해 편집기와 뷰어를 구분하여 사용할 수 있었다.</p>\n<p>하지만 <code>TOAST Editor</code>의 경우에는 아예 <code>Viewer</code>를 따로 제공하고 있었다.</p>\n<p>문서에서는 찾지 못했는데, 타입에 아래와 같이 정의가 되어 있어서 사용해봤다.</p>\n<pre><code class=\"language-ts\">export class Viewer extends Component&#x3C;ViewerProps> {\n  getInstance(): ToastuiEditorViewer;\n\n  getRootElement(): HTMLElement;\n}\n</code></pre>\n<p>이제 상세 페이지에 Viewer를 적용해보자.</p>\n<pre><code class=\"language-tsx\">import { Viewer } from '@toast-ui/react-editor';\n\nexport default function EditorViewer({\n  initialValue,\n}: {\n  initialValue: string;\n}) {\n  return &#x3C;Viewer initialValue={initialValue} />;\n}\n</code></pre>\n<p>상위 컴포넌트에서 <code>Props</code>로 <code>initialValue</code>에 컨텐츠 정보를 받아오고, 이것을 단순히 <code>Viewer</code>에 전달해주기만 하면 된다.</p>\n<p><code>Viewer</code>의 경우에도 <code>import</code>시 아래와 같이 <code>dynamic import</code>를 사용해야한다.</p>\n<pre><code class=\"language-tsx\">const EditorViewer = dynamic(() => import('@/components/post/EditorViewer'), {\n  ssr: false,\n});\n</code></pre>\n<p>적용한 결과는 아래와 같다.</p>",
            "url": "https://nostrss.me/149-toast-next-4",
            "title": "[NEXT] TOAST Editor Viewer 사용하기",
            "summary": "보여주기만 할 땐 Viewer를 사용하면 된다.",
            "date_modified": "2023-08-25T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "javascript",
                "typescript",
                "toast",
                "editor"
            ]
        },
        {
            "id": "145-postgre-install-error",
            "content_html": "<p>Nest.js를 공부하면서 Brew로 PostgresSQL을 설치하고 DB를 연결하려고 했는데 아래와 같은 에러가 발생했다.</p>\n<pre><code class=\"language-bash\">psql postgres\n\npsql: error: connection to server on socket \"/tmp/.s.PGSQL.5432\" failed: No such file or directory\n</code></pre>\n<p>검색을 해보니 다양한 결과들이 나왔다.</p>\n<ul>\n<li>삭제 후 재설치 하는 방법</li>\n<li>재부팅 하는 방법</li>\n<li>postgresql@13을 설치하는 방법(나는 14버전을 사용하고 싶었다.)</li>\n</ul>\n<p>chatgpt도 사용해봤으나 전부 실패했다.</p>\n<p>그러다 stackoverflow에서 아래와 같은 답변을 찾았다.</p>\n<p><a href=\"https://stackoverflow.com/questions/69754628/psql-error-connection-to-server-on-socket-tmp-s-pgsql-5432-failed-no-such\">stack overflow 원본링크</a></p>\n<p>위의 링크 중간에 보면 아래와 같은 답변이 있었다.</p>\n<pre><code class=\"language-bash\">brew services start postgresql\n</code></pre>\n<p>위의 명령어를 실행하고 다시 psql을 실행하니 정상적으로 실행되었다.</p>\n<pre><code>psql postgres\n</code></pre>\n<p>개발은 처음에 설치와 환경설정이 제일 어렵다..</p>",
            "url": "https://nostrss.me/145-postgre-install-error",
            "title": "PostgresSQL 설치 시 \"/tmp/.s.PGSQL.5432\" 에러",
            "summary": "설치 에러가 제일 무서운 개발자",
            "date_modified": "2023-08-24T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nestjs",
                "node",
                "express",
                "javascript",
                "typescript"
            ]
        },
        {
            "id": "144-nestjs",
            "content_html": "<blockquote>\n<p><a href=\"https://docs.nestjs.com/\">Nest.js 공식 문서</a>를 참고하였습니다.</p>\n</blockquote>\n<h2>Nest.js란?</h2>\n<ul>\n<li>Node.js 서버 측 애플리케이션을 구축하기 위한 프레임 워크</li>\n</ul>\n<h2>특징</h2>\n<ul>\n<li><code>Angular</code>와 비슷한 구조이며 이에 영감을 받은 것으로 알려져 있습니다.</li>\n<li><code>Typescript</code>를 기본 언어로 사용합니다.</li>\n<li><code>Express</code>를 기본값으로 사용하며 <code>Fastify</code>도 사용할 수 있습니다.</li>\n<li>객체지향 개념을 도입하였습니다.</li>\n</ul>\n<h2>장점</h2>\n<h3>Angular와 비슷한 구조</h3>\n<ul>\n<li>모듈/컴포넌트 기반으로 프로그램을 작성함으로써 재사용성을 높여줍니다.\n<blockquote>\n<p>프론트 엔드를 먼저 시작한 나로서는 모듈기반이라는 말이 잘 와닿지 않았다.</p>\n</blockquote>\n</li>\n</ul>\n<h3>Express의 단점을 보완</h3>\n<ul>\n<li>\n<p>expresss는 훌륭한 프레임워크이지만, 과도한 유연함으로 인해 SW의 품질이 일정하지 않고 알맞은 라이브러리를 찾기 위해 사용자가 많은 시간을 할애해야 합니다.</p>\n</li>\n<li>\n<p>하지만 Nest.js는 데이터베이스, ORM, 설정(Configuration), 유효성 검사 등 수많은 기능을 기본 제공하고 있다. 그러면서도 필요한 라이브러리를 쉽게 설치하여 기능을 확장할 수 있는 Node.js 장점은 그대로 가지고 있다고 한다.</p>\n</li>\n</ul>\n<blockquote>\n<p>즉, Express는 React, Nest.js는 Next.js, Nuxt.js와 같은 프론트엔드 프레임워크와 비슷한 역할을 한다고 이해하면 될 것 같다.</p>\n</blockquote>\n<h2>설치 및 설정</h2>\n<p>아래 2개의 명령어를 터미널에서 실행하여 설치와 새 프로젝트를 설정 할 수 있다.</p>\n<pre><code class=\"language-bash\">npm i -g @nestjs/cli\nnest new project-name\n\n</code></pre>\n<h3>핵심 파일</h3>\n<p>설치를 완료하면 src 폴더에 아래와 같은 파일들이 생성된다.</p>\n<p>|                          |                                                                                                                                                             |\n| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| <code>app.controller.ts</code>      | 클라이언트로 부터 들어오는 요청을 <code>service</code>애 위임하고 처리된 결과를 다시 클라이언트에게 반환하는 일을 담당한다. HTTP 요청 메서드(GET, POST 등)를 정의한다. |\n| <code>app.controller.spec.ts</code> | 컨트롤러에 대한 단위 테스트 파일 이다.                                                                                                                      |\n| <code>app.module.ts</code>          | 애플리케이션의 루트 모듈. Nest.js에서는 모듈을 사용하여 애플리케이션을 구성한다. 모듈은 기능과 비즈니스 로직을 담당하는 컴포넌트의 집합이라 할 수 있다.     |\n| <code>app.service.ts</code>         | <code>controller</code>로부터 위임받은 요청을 실제로 처리하고 반환하는 역할을 한다. 즉,비즈니스 로직을 구현하는 역할이라고 볼 수 있다.                                 |\n| <code>main.ts</code>                | Nest.js의 진입점, NestFactory핵심 기능을 사용하여 Nest 애플리케이션 인스턴스를 생성하는 애플리케이션의 항목 파일이다. HTTP 서버를 시작하는 역할을 한다.     |</p>\n<h2>실행</h2>\n<pre><code class=\"language-bash\">npm run start\nnpm run start:dev // 개발 모드\n</code></pre>",
            "url": "https://nostrss.me/144-nestjs",
            "title": "[Nest.js] - 소개",
            "summary": "올해 안에 Nest.js 서버를 만들어 보자!!",
            "date_modified": "2023-08-23T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nestjs",
                "node",
                "express",
                "javascript",
                "typescript"
            ]
        },
        {
            "id": "142-javascript-reduce",
            "content_html": "<p>좀 처럼 프론트엔드 실무를 하면서는 자주 사용할 기회가 없었던 메소드가 바로 reduce였다.</p>\n<p>얼마 전 지인의 코드를 수정해주다가 reduce를 사용한 부분이 있어서 정리해봤다.</p>\n<h2>등차수열</h2>\n<p>갑자기 등차수열이 왜 나오냐고? 라고 생각할 수 있지만, reduce를 사용하면서 등차수열을 공식과 연관지어 생각하니 이해가 쉬워져서 예시를 들었다.</p>\n<h3>등차수열 공식</h3>\n<pre><code class=\"language-text\">a(n) = a(1) + (n - 1) * d\n</code></pre>\n<p>등차 수열의 공식은 위와 같다.</p>\n<p>수열의 첫 항 a(1)이 있고 공차 d가 있다면, n번째 항은 위와 같이 구할 수 있다.</p>\n<p>이것을 reduce와 비교해보자.</p>\n<h3>reduce</h3>\n<p>리듀스의 구문은 아래와 같다.</p>\n<pre><code class=\"language-js\"> arr.reduce(callback[, initialValue])\n</code></pre>\n<p>callback은 필수값이고, initialValue는 옵션이다.</p>\n<p>reduce 메소드는 initialValue 값에 callback 함수를 적용하여 하나의 결과값을 만들어낸다.</p>\n<p>즉, 등차수열의 첫항 a(1)이 initialValue이고, 공차 d가 callback 함수라고 생각하면 이해가 쉽다.</p>\n<p>mdn에 나와 있는 예시를 통해 살펴보자.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">mdn reduce 예시 </a></p>\n<pre><code class=\"language-js\">[0, 1, 2, 3, 4].reduce(function (\n  accumulator,\n  currentValue,\n  currentIndex,\n  array\n) {\n  return accumulator + currentValue;\n},\n10);\n</code></pre>\n<p>|  callback  | accumulator | currentValue | currentIndex |      array      | return value |\n| :--------: | :---------: | :----------: | :----------: | :-------------: | :----------: |\n| 1번째 호출 |     10      |      0       |      0       | [0, 1, 2, 3, 4] |      10      |\n| 2번째 호출 |     10      |      1       |      1       | [0, 1, 2, 3, 4] |      11      |\n| 3번째 호출 |     11      |      2       |      2       | [0, 1, 2, 3, 4] |      13      |\n| 4번째 호출 |     13      |      3       |      3       | [0, 1, 2, 3, 4] |      16      |\n| 5번째 호출 |     16      |      4       |      4       | [0, 1, 2, 3, 4] |      20      |</p>\n<p>위의 표를 보면 이해가 쉽다.</p>\n<p>initialValue가 10이고, callback 함수가 accumulator에 currentValue를 더해주는 형태이다.</p>\n<p>즉, 등차수열에서 공차 d가 1이라고 생각하면, initialValue는 a(1)이고, callback 함수는 d가 된다.</p>\n<p>물론 reduce가 등차수열로만 적용되는 것은 아니고 다양한 용도로 사용할 수 있지만, 이렇게 이해들 해두고 나머지는 응용을 하면 되겠다.</p>",
            "url": "https://nostrss.me/142-javascript-reduce",
            "title": "reduce 사용법 정리",
            "summary": "자주 쓰지 않아서 까먹은 reduce 사용법을 정리",
            "date_modified": "2023-07-11T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "javascript",
                "reduce"
            ]
        },
        {
            "id": "141-next-page-app-router",
            "content_html": "<h2>Props</h2>\n<p>NEXT.JS에서는 기본적으로 컴포넌트에 Props로 params와 searchParams를 전달해준다.</p>\n<p>상위 컴포넌트에서 아무런 Props를 전달하지 않아도 params와 searchParams를 사용할 수 있다.</p>\n<pre><code class=\"language-js\">export default function Page({\n  params,\n  searchParams,\n}: {\n  params: { slug: string }\n  searchParams: { [key: string]: string | string[] | undefined }\n}) {\n  return &#x3C;h1>My Page&#x3C;/h1>\n}\n</code></pre>\n<h2>params</h2>\n<p><code>params</code>: URL의 path에 있는 동적 경로 파라미터를 담고 있는 객체이다.</p>\n<p>예를 들면 아래와 같다.</p>\n<p>| Example                            | URL       | params                       |\n| :--------------------------------- | :-------- | :--------------------------- |\n| app/shop/[slug]/page.js            | /shop/1   | { slug: '1' }                |\n| app/shop/[category]/[item]/page.js | /shop/1/2 | { category: '1', item: '2' } |\n| app/shop/[...slug]/page.js         | /shop/1/2 | { slug: ['1', '2'] }         |</p>\n<p>예전에 나는 useRouter를 사용해서 params를 가져왔었는데, 이제는 이렇게 간단하게 가져올 수 있다.</p>\n<h2>searchParams</h2>\n<p><code>searchParams</code>: URL의 query string에 있는 파라미터를 담고 있는 객체</p>\n<p>| URL           | searchParams       |\n| :------------ | :----------------- |\n| /shop?a=1     | { a: '1' }         |\n| /shop?a=1&#x26;b=2 | { a: '1', b: '2' } |\n| /shop?a=1&#x26;a=2 | { a: ['1', '2'] }  |</p>\n<h2>useRouter 변경사항</h2>\n<p>그리고 이와 관련하여 몇가지 달라진 점이 있다. 특히 내가 많이 사용하던 것들 중에 달라진 사항이 있어 정리해봤다.</p>\n<blockquote>\n<p>새로운 useRouter는 import시 next/navigation에서 가져와야한다.(기존 next/router)</p>\n</blockquote>\n<blockquote>\n<p>문자열 pathname은 usePathname()으로 대체되었다.</p>\n</blockquote>\n<blockquote>\n<p>문자열 query는 useQuery()로 대체되었다.</p>\n</blockquote>",
            "url": "https://nostrss.me/141-next-page-app-router",
            "title": "[NEXT] page.js (with App Router)",
            "summary": "NEXT.JS에서 page.js에 기본적으로 제공되는 Props를 알아보자.",
            "date_modified": "2023-07-11T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "nextjs",
                "react",
                "app-router",
                "pagejs"
            ]
        },
        {
            "id": "143-react-nextjs-server-component",
            "content_html": "<p>React 18 버전에서 새로 추가된 기능 중 하나가 바로 server component이다.</p>\n<p>아직 많이 쓰이는 것 같지는 않지만, Next.js에서도 app router가 정식 버전으로 나오면서 server component를 지원한다고 한다.</p>\n<p>그래서 이에 대해 조금 공부해보았다.</p>\n<h2>React server component는 왜 나왔을까?</h2>\n<h3>번들 사이즈 최적화</h3>\n<p>React18 이전의 리액트 컴포넌트는 한마디로 '클라이언트' 컴포넌트였다.</p>\n<p>그래서 모든 것이 브라우저에서 실행되었다.(CSR인 경우)</p>\n<p>코드를 다운로드 하고, DOM에 렌더링하고, Data를 fetch하고, 이벤트를 처리하는 것까지 모두 브라우저에서 수행되었다.</p>\n<p>이는 번들 사이즈가 커지는 원인이 되었다.</p>\n<p>하지만 서버에서 렌더링을 할 수 있게 된다면, 브라우저에서 수행할 작업을 줄일 수 있고, 번들 사이즈를 줄일 수 있게 된다.</p>\n<p>즉, 그동안 브라우저에서 하던 일을 서버와 브라우저가 나눠서 작업을 할 수 있게 되는 것이다.</p>\n<h3>서버 리소스 리소스 접근</h3>\n<p>서버는 데이터 베이스, GraphQL, 파일시스템 등 데이터 리소스에 빠르게 접근할 수 있고, 이를 클라이언트 컴포넌트에 Props로 전달할 수 있다.</p>\n<h3>서버 컴포넌트와 SSR</h3>\n<p>나도 착각 했던 것 중 하나인데 RSC는 SSR과는 다르다.</p>\n<p><code>server</code>라는 단어가 둘다 들어가서 딱 착각하기 좋은 듯하다.</p>\n<p>좋은 내용이 있어서 아래에 인용해봤다.</p>\n<blockquote>\n<p>Does this(RSC) replace SSR?</p>\n</blockquote>\n<blockquote>\n<p>No, they’re complementary. SSR is primarily a technique to quickly display a non-interactive version of client components. You still need to pay the cost of downloading, parsing, and executing those Client Components after the initial HTML is loaded.\nYou can combine Server Components and SSR, where Server Components render first, with Client Components rendering into HTML for fast non-interactive display while they are hydrated. When combined in this way you still get fast startup, but you also dramatically reduce the amount of JS that needs to be downloaded on the client.</p>\n</blockquote>\n<h2>Next.js에서의 RSC</h2>\n<p>얼마전에 app router가 정식 버전으로 나왔다.</p>\n<p>많은 변화가 있었지만 가장 큰 변화는 아마 app 폴더가 생긴 것이 아닐까 싶다.</p>\n<p>기존 버전의 Next.js에서는 pages 폴더에 있는 컴포넌트를 전부 클라이언트 컴포넌트로 취급하였다.</p>\n<p>그리고 이번 버전에 추가된 app 폴더는 디폴트로 모든 컴포넌트를 서버 컴포넌트 취급을 한다.</p>\n<blockquote>\n<p>당분간은 pages폴더와 app폴더를 같이 사용할 수 있다고 한다.</p>\n</blockquote>\n<h3>무엇이 달라지는가?</h3>\n<p>서버 컴포넌트와 클라이언트 컴포넌트를 구분하여 사용할 줄 알아야 할 것 같다.</p>\n<p>서버 컴포넌트는 Node.js 환경에서 실행되고, 클라이언트 컴포넌트는 브라우저 환경에서 실행된다.</p>\n<p>그렇기 때문에 서버 컴포넌트에서는 기존에 우리가 사용했던 Browser APIs, 이벤트, React Lifecycle Effect, Hooks 등을 사용할 수 없다.</p>\n<p>기존처럼 사용하기 위해서는 아래와 같이 최상단에 <code>use client</code>를 선언해주면 된다.</p>\n<pre><code class=\"language-js\">'use client';\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;div>\n      &#x3C;p>You clicked {count} times&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>Click me&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md\">https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md</a></li>\n<li><a href=\"https://tech.kakaopay.com/post/react-server-components/\">https://tech.kakaopay.com/post/react-server-components/</a></li>\n<li><a href=\"https://yceffort.kr/2022/01/how-react-server-components-work\">https://yceffort.kr/2022/01/how-react-server-components-work</a></li>\n</ul>",
            "url": "https://nostrss.me/143-react-nextjs-server-component",
            "title": "React server component와 Next.js",
            "summary": "Server Component 참 신기한 컴포넌트네요",
            "date_modified": "2023-07-11T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "react",
                "rsc",
                "next.js"
            ]
        },
        {
            "id": "140-frontend-of-term",
            "content_html": "<h1>렌더링의 종류와 용어 정리</h1>\n<p>현업에서 CSR만 사용해봐서 다른 렌더링 방식에 대해서 알아보다가 용어 정리가 좀 필요한 것 같아서 정리해봤다.</p>\n<h2>CSR : client side rendering</h2>\n<ul>\n<li>렌더링의 주체 : Browser</li>\n<li>렌더링의 과정\n<ul>\n<li>빈 HTML 파일을 받아온다</li>\n<li>JS 파일을 받아온다</li>\n<li>JS 파일을 실행한다</li>\n<li>데이터를 받아온다</li>\n<li>DOM Tree를 만든다</li>\n<li>HTML을 렌더링한다</li>\n</ul>\n</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>한번만 로딩(HTML, JS)이 되면 이후에는 빠르게 렌더링이 가능하다</li>\n<li>서버의 부하가 적다</li>\n<li>변경되는 일부분만 렌더링이 가능하다</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>\n<p>TTV, FCP 시간이 길다.</p>\n<blockquote>\n<p>TTV : time to view, 유저가 화면을 볼때까지의 시간\nFCP : first contentful paint, 유저가 화면에 처음으로 무언가를 볼 수 있는 시간</p>\n</blockquote>\n</li>\n<li>\n<p>SEO 최적화가 어렵다.</p>\n</li>\n</ul>\n<h2>SSG : static site generation</h2>\n<ul>\n<li>렌더링의 과정 : 빌드할 때 HTML 파일을 렌더링하여 정적 사이트를 생성한다.</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>페이지 로딩이 빠르다.</li>\n<li>SEO 최적화가 가능하다.</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>데이터가 정적이고 실시간 데이터가 아니다.</li>\n</ul>\n<h2>ISR : incremental static regeneration</h2>\n<ul>\n<li>렌더링 과정 - SSG 처럼 빌드 시 HTML 파일을 렌더링하여 정적 사이트를 생성한다. 그리고 정해진 주기에 따라 정적 사이트를 재생성한다.</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>SSG + 데이터가 업데이트 된다.</li>\n<li>SEO 최적화가 가능하다.</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>하지만 실시간 데이터가 아니다.</li>\n</ul>\n<h2>SSR : server side rendering</h2>\n<ul>\n<li>렌더링의 주체 : Server</li>\n<li>렌더링의 과정\n<ul>\n<li>유저의 요청을 받는다.</li>\n<li>Server가 요청을 받아서 데이터를 받아온다.</li>\n<li>Server가 HTML을 렌더링한다.</li>\n<li>Server가 렌더링된 HTML을 유저에게 전달한다.</li>\n</ul>\n</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>TTV, FCP 시간이 짧다.</li>\n<li>SEO 최적화가 가능하다.</li>\n<li>실시간 데이터를 사용한다.</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>SSG, ISR과 비교했을 때 비교적 느릴 수 있다</li>\n<li>서버의 부하(Overhead)가 크다.</li>\n</ul>",
            "url": "https://nostrss.me/140-frontend-of-term",
            "title": "[정리] 렌더링의 종류와 용어 정리",
            "summary": "렌더링 사전이 필요해..",
            "date_modified": "2023-07-10T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "rendering",
                "csr",
                "isr",
                "ssg",
                "ssr"
            ]
        },
        {
            "id": "139-algorithm",
            "content_html": "<p>최근 알고리즘 문제를 풀다가 최대공약수와 최소공배수를 활용하는 문제가 있었다.</p>\n<p>문제를 풀긴 풀었지만, 최대공약수와 최소공배수의 경우에는 공식이 이미 존재하기 때문에</p>\n<p>잘 알아두면 시간을 절약하기 좋을 것 같아서 정리해 보았다.</p>\n<h2>최대 공약수(greatest common divisor)</h2>\n<p>유클리드 호제법을 이용하여 최대 공약수를 구하는 방법을 코드로 구현해 보았다.</p>\n<pre><code class=\"language-javascript\">const getGcd = (a, b) => {\n  while (b > 0) {\n    let temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n};\n</code></pre>\n<p>재귀적으로도 구현 가능할 것 같아 작성을 해봤다.</p>\n<pre><code class=\"language-javascript\">const getGcd = (a, b) => {\n  if (b === 0) {\n    return a;\n  }\n  return getGcd(b, a % b);\n};\n</code></pre>\n<h2>최소 공배수(least common multiple)</h2>\n<p>최소 공배수는 위의 최대 공약수를 이용하면 쉽게 구할 수 있다.</p>\n<pre><code class=\"language-javascript\">const lcm = (a, b) => {\n  return (a * b) / gcd(a, b);\n};\n</code></pre>",
            "url": "https://nostrss.me/139-algorithm",
            "title": "[알고리즘]최대공약수와 최소공배수",
            "summary": "알아두면 쓸모 있을 것 같은 수학",
            "date_modified": "2023-06-23T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "algorithm",
                "javascript",
                "gcd",
                "lcm"
            ]
        },
        {
            "id": "138-refactoring-1",
            "content_html": "<h2>샘플 코드</h2>\n<ul>\n<li>\n<p><a href=\"https://github.com/nostrss/book-refactoring/tree/ef7e94134633027ad7a61d140184751e64422a16/chapter-01\">리팩토링 전 코드</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nostrss/book-refactoring/tree/main/chapter-01\">리팩토링 후 코드</a></p>\n</li>\n</ul>\n<h2>챕터 1</h2>\n<p>저자는 자기가 명명한 리팩터링의 규칙과 기법(?)을 의거하며 샘플 코드를 리팩토링을 하는 법을 단계별로 보여준다.</p>\n<p>예시를 통해서 리팩터링이 무엇인지 감을 잡는 챕터이다. 하지만..</p>\n<blockquote>\n<p>아니 챕터1 부터 왜 이렇게 복잡하지?</p>\n</blockquote>\n<p>라는 생각이 들게 한다.</p>\n<p>그리고 눈으로만 코드를 보니 괄호가 눈에 잘 들어오지 않아서, 나는 저자의 코드를 직접 작성하면서 책을 정독했다.</p>\n<p>챕터1만 보는데 반나절은 걸린 것 같다...</p>\n<h2>리팩터링 기법</h2>\n<p>저자는 앞으로 뒷장에서 더 자세히 리팩터링의 기법에 대해서 다룰 예정이라고 했지만, 몇가지 인상적인 내용이 있었다.</p>\n<h3>변수 인라인하기</h3>\n<p><strong>리팩터링 전</strong></p>\n<pre><code class=\"language-javascript\">for (let perf of invoice.performances) {\n  const play = playFor(perf);\n  let thisAmout = amountFor(perf, play);\n}\n</code></pre>\n<p><strong>리팩터링 후</strong></p>\n<pre><code class=\"language-javascript\">for (let perf of invoice.performances) {\n  // const play = playFor(perf);\n  let thisAmout = amountFor(perf, playFor(perf));\n}\n</code></pre>\n<p>저자는 위의 방식 대신 아래의 방식으로 리팩터링을 진행하며 이를 <code>변수 인라인하기</code>라고 부른다.</p>\n<p>변수 <code>play</code>가 하나 제거 되기는 장점이 있긴 한데, 개인적으로는 그동안 위의 방식이 보기 좋아서 많이 사용했던 방식이었다.</p>\n<p>왜 저자가 이렇게 수정을 하는지 궁금해지는 부분이다.</p>\n<h3>조건부 로직을 다형성으로 바꾸기</h3>\n<p><strong>리팩터링 전</strong></p>\n<pre><code class=\"language-javascript\">function amountFor(aPerformance) {\n  let result = 0;\n  switch (aPerformance.play.type) {\n    case 'tragedy': // 비극\n      result = 40000;\n      if (aPerformance.audience > 30) {\n        result += 1000 * (aPerformance.audience - 30);\n      }\n      break;\n    case 'comedy': // 희극\n      result = 30000;\n      if (aPerformance.audience > 20) {\n        result += 10000 + 500 * (aPerformance.audience - 20);\n      }\n      result += 300 * aPerformance.audience;\n      break;\n    default:\n      throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`);\n  }\n  return result;\n}\n</code></pre>\n<p><strong>리팩터링 후</strong></p>\n<pre><code class=\"language-javascript\">class PerformanceCalculator {\n  constructor(aPerformance, aPlay) {\n    this.performance = aPerformance;\n    this.play = aPlay;\n  }\n\n  get amount() {\n    throw new Error('서브클래스에서 처리하도록 설계되었습니다.');\n  }\n\n  get volumeCredits() {\n    return Math.max(this.performance.audience - 30, 0);\n  }\n}\n\nclass TragedyCalculator extends PerformanceCalculator {\n  get amount() {\n    let result = 40000;\n    if (this.performance.audience > 30) {\n      result += 1000 * (this.performance.audience - 30);\n    }\n    return result;\n  }\n}\nclass ComedyCalculator extends PerformanceCalculator {\n  get amount() {\n    let result = 30000;\n    if (this.performance.audience > 20) {\n      result += 10000 + 500 * (this.performance.audience - 20);\n    }\n    result += 300 * this.performance.audience;\n    return result;\n  }\n  get volumeCredits() {\n    return super.volumeCredits + Math.floor(this.performance.audience / 5);\n  }\n}\n</code></pre>\n<p>저자는 switch를 이용한 조건부 로직을 다형성(polymorphism)을 활용하여 수정하였다.</p>\n<p>현업에서도 조건에 따른 분기마다 별도의 로직을 적용해야 하는경우가 아주 많다.</p>\n<p>그럴때면 if else 의 지옥에 빠져 엄청나게 긴 코드를 봐야 하는 경우가 많았다.</p>\n<p>class 문법이 익숙하지 않은 나지만 현실적으로 아주 와 닿는 리팩터링 방법이었다.</p>\n<h2>후기</h2>\n<p>생각보다 단계별로 설명이 알차게 되어 있다. 무언가 책이 단단하고 알찬 느낌이다.</p>\n<p>오래 걸릴 것 같긴한데 완독 해보자 ㅎㅎ</p>",
            "url": "https://nostrss.me/138-refactoring-1",
            "title": "[책읽기]refactoring - 챕터 1",
            "summary": "사수가 없으니 책이라도 읽어보자.",
            "date_modified": "2023-05-07T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "book",
                "refactoring",
                "javascript"
            ]
        },
        {
            "id": "137-refactoring-0",
            "content_html": "<h2>좋은 코드란 어떤걸까?</h2>\n<p>회사를 다니기 전에 좋은 코드에 대한 나의 생각은 아래와 같았다.</p>\n<blockquote>\n<p>짧고 간결한 코드</p>\n</blockquote>\n<blockquote>\n<p>최적화가 잘 되어 있는 코드</p>\n</blockquote>\n<p>하지만 회사를 다니면서 추가된 내용이 있다.</p>\n<blockquote>\n<p>알아보기 쉬운 코드</p>\n</blockquote>\n<blockquote>\n<p>유지 보수가 쉬운 코드</p>\n</blockquote>\n<blockquote>\n<p>기능 추가가 쉬운 코드</p>\n</blockquote>\n<p>기존의 생각과는 조금 다른 방향성이 생겨 난 것이다.</p>\n<h3>왜?</h3>\n<p>혼자 개발을 한다면 이런 생각이 들지 않았을 것 같다.</p>\n<p>하지만 회사에서 동료들과 함께 일을 하다보니 누군가가 작성한 코드를 봐야 하는 일이 자주 생겼다. 그리고 반대로 내가 작성한 코드를 다른 사람이 수정해야 하는 일도 있었다.</p>\n<p>이때 서로 다른 스타일의 코드를 보면서 분석하는데 많은 시간을 들였던 기억이 있다.</p>\n<p>또한 동료가 작성한 코드를 수정하다 보면 예상치 못한 사이드 이펙트가 발생하는 경우가 발생하는 일도 많았다. 여기에 정말 간단한 기능을 추가하는데, 예상보다 수정의 범위가 넓어져서 당황스러운 경우도 있었다.</p>\n<p>회사에 시니어 개발자가 없다 보니 이에 대한 갈증이 생겨날 수 밖에 없었는데 마땅한 해결방법을 찾기 어려웠다. chat-gpt, 구글검색, 유튜브를 아무리 들여봐도 깊이가 느껴지지 않았고, 정보를 탐색하는 시간만 길어지는 느낌이 들었다.</p>\n<h2>책 한번 읽어 볼까?</h2>\n<p>그러다 회사 업무 때문에 대표님이 얇은 책 한 권을 읽어 오라고 했다.</p>\n<p><a href=\"http://www.yes24.com/Product/UsedShopHub/Hub/92456411\">프로그레시브 웹 앱</a></p>\n<p>정말 오랜 만에 읽는 책을 읽어 봤는데, 그래서 인지 느낌이 남달랐다. 유튜브나, 블로그와 달리 작가의 내공이 느껴졌다고 해야할까?</p>\n<p>책이 앏야서, 아니면 작가의 필력이 좋아서 그랬을지 모르지만 그 느낌이 너무 좋았다.</p>\n<p>그래서 이번에는 조금 더 두껍고 어려운 책을 읽어 보려고 한다.</p>\n<h3>리팩터링</h3>\n<p><a href=\"http://www.yes24.com/Product/UsedShopHub/Hub/89649360\">리팩터링 2판</a></p>\n<p>이 책을 선택한 이유</p>\n<ul>\n<li>유튜브에서 추천 영상이 많았다..</li>\n<li>1판의 경우 java로 예제 코드가 작성되어 있었는데, 2판에서는 javascript로 되어 있다.</li>\n<li>1판에 대한 좋은 평가 글이 많았다.</li>\n</ul>\n<p>자, 책은 준비했고 한번 읽어보자.</p>",
            "url": "https://nostrss.me/137-refactoring-0",
            "title": "[책읽기]refactoring",
            "summary": "이 책이 그렇게 유명하다며? 그런데 어려워 보이는데?",
            "date_modified": "2023-05-05T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "book",
                "refactoring",
                "javascript"
            ]
        },
        {
            "id": "136-typedoc-gh-pages",
            "content_html": "<p>회사에서든, 개인적으로 집에서 코드를 볼 때마다</p>\n<blockquote>\n<p>이 변수는 뭐지?</p>\n</blockquote>\n<blockquote>\n<p>이 함수는 무슨 작동을 하는거지?</p>\n</blockquote>\n<p>라는 생각을 하면서 코드를 살펴보곤 한다.</p>\n<p>그래서 다음에 볼때는 좀 더 알아 보기 쉽게 하려고 주석을 열심히 달기도 한다.</p>\n<p>그러다 API 명세처럼 프론트 소스코드들도 문서화 해주는 방법이 없을까 해서 알아보다가 typedoc을 통해서 문서화 할 수 있는 방법을 찾아서 적용해 봤다.</p>\n<h2>typedoc이란?</h2>\n<p><a href=\"https://typedoc.org/\">typedoc 공식 홈페이지 바로가기</a></p>\n<p><a href=\"https://typedoc.org/example/\">typedoc 예제</a></p>\n<p>typedoc은 소스코드에 포함된 주석으로 html 문서를 만들어주는 패키지이다.</p>\n<p>별도로 문서를 작성하는 시간을 들일 필요없이 소스코드에 작성하면 바로 빌드하여 문서화 할 수 있는 장점이 있다.</p>\n<h2>typedoc 설치하기</h2>\n<pre><code class=\"language-bash\">// Install\n\nnpm install --save-dev typedoc\n</code></pre>\n<h2>typedoc 설정하기</h2>\n<p>tsconfig.json에 아래와 같이 entryPoints를 지정해줘야 한다.</p>\n<p>entryPoints는 TypeDoc이 문서화할 TypeScript 파일의 진입점을 지정하는 데 사용되고, 진입점이 여러 곳일 경우에는 배열로 여러개 지정해줄 수 있다.</p>\n<p>out은 빌드파일이 생성될 경로이다.</p>\n<pre><code class=\"language-json\"> \"typedocOptions\": {\n    \"entryPoints\": [\"src/pages/index.tsx\"],\n    \"out\": \"docs\"\n  }\n</code></pre>\n<h2>typedoc 문서 생성하기</h2>\n<p>문서를 생성하는 명령어는 아래와 같다.</p>\n<pre><code class=\"language-bash\">npx typedoc src/index.ts\n</code></pre>\n<p>하지만, 위와 같이 작성하면 하위에 있는 소스코드 파일의 주석들은 문서로 만들어지지 않는 단점이 있었다.</p>\n<p>그래서 찾은 방법이 아래의 명령어이다. 이렇게 입력하면, entrypoints부터 시작하여 하위 폴더의 파일들까지 전부 문서로 만들어 준다.</p>\n<pre><code class=\"language-bash\">npx typedoc --entryPointStrategy expand ./src\n</code></pre>\n<h2>결과물</h2>\n<p>나 같은 경우 빌드된 문서를 언제든지 웹에서 볼 수 있도록 gh-pages를 이용해 git-hub page에 배포를 해두었다.</p>\n<p><a href=\"https://nostrss.github.io/nextjs-blog/\">typedoc 으로 생성한 문서 보기</a></p>",
            "url": "https://nostrss.me/136-typedoc-gh-pages",
            "title": "typedoc으로 프론트엔드 문서 만들기",
            "summary": "AI가 문서를 만들어주는 세상이 빨리 왔으면 좋겠다.",
            "date_modified": "2023-03-13T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "react",
                "nextjs",
                "typedoc"
            ]
        },
        {
            "id": "135-github-template",
            "content_html": "<p>매번 새로운 프로젝트를 시작할 때 마다 똑같이 반복해서 작업하는 일이 있다.</p>\n<pre><code class=\"language-bash\">// 설치하기..\nnpx create-react-app\nnpx create-next-app\nnpx eslint init\n(등등등)\n\n// 설정하기\npackage.json\ntsconfig.json\n.eslintrc.js\n.gitignore\nnext.config.js\n(등등등)\n</code></pre>\n<p>이렇게 setting 하는 것도 사실 한 번에 잘 되지 않으면 상당히 시간을 소모하는 작업이 되는 경우가 있다. (바로 오늘 내가 그랬다..)</p>\n<p>그래서 나만의 boilerplate를 만들어서 git-hub에 템플릿으로 만들어두고 사용해보려고 한다.</p>\n<h2>Boilerplate 준비하기</h2>\n<blockquote>\n<p>boilerplate는 다른 프로젝트에서 재사용할 수 있는 코드와 파일들의 집합입니다. 예를 들어, React 프로젝트를 시작할 때마다 같은 파일들을 만들어야 한다면, 이 파일들을 boilerplate에 추가하여 다음에 프로젝트를 시작할 때 boilerplate를 사용하면 됩니다. 이렇게 boilerplate를 사용하면 새로운 프로젝트를 시작할 때 시간을 절약할 수 있습니다.</p>\n</blockquote>\n<p>내가 만들 Boilerplate 내용은 아래와 같다</p>\n<ul>\n<li>Next.js</li>\n<li>typescript</li>\n<li>eslint : airbnb</li>\n<li>prettier</li>\n</ul>\n<p>최소한의 세팅 내용이다.</p>\n<p>css, 상태관리 라이브러리 등등은 상황을 보면서 추가할 예정이다.</p>\n<p>준비가 된 코드는 github에 푸쉬해 두자.</p>\n<p><a href=\"https://github.com/nostrss/next-lint-airbnb\">Boilerplate 소스코드 보러가기</a></p>\n<h2>Github Template Repository 설정하기</h2>\n<ul>\n<li>Repository > setting</li>\n</ul>\n<ul>\n<li>Template Repository 체크박스 On</li>\n</ul>\n<p>이게 끝이다. 앞으로 이 Repository를 Template로 바로 사용할 수 있다.</p>\n<h2>Template 사용하기</h2>\n<p>새로운 Repository를 생성해보자.</p>\n<p>그때 select box를 클릭 해보면, 방금 설정한 Template Repository가 옵션으로 나오게 된다.</p>\n<p>옵션을 선택하고 Repository를 만들게 되면 똑같은 Repository가 생성이 되고 바로 이어서 추가 설정 및 작업을 시작 하면 된다.</p>\n<h2>fork와의 차이점</h2>\n<p>Repolistory를 fork해서 그냥 사용하는 것과 차이가 없게 느껴질 수 있는데, 몇가지 다른 점이 있다.</p>\n<ul>\n<li>새 포크에는 부모 리포지토리의 전체 커밋 기록이 포함되며 템플릿에서 만든 리포지토리는 단일 커밋으로 시작합니다.</li>\n<li>포크에 대한 커밋은 기여 그래프에 표시되지 않지만 템플릿에서 만든 리포지토리에 대한 커밋은 기여 그래프에 표시됩니다.</li>\n<li>포크는 템플릿에서 리포지토리를 만들면 새 프로젝트를 빠르게 시작하는 동시에 기존 프로젝트에 코드를 기여하는 임시 방법이 될 수 있습니다.</li>\n</ul>\n<p><a href=\"https://docs.github.com/ko/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template\">자세한 내용보러가기</a></p>",
            "url": "https://nostrss.me/135-github-template",
            "title": "나만의 Boilerplate를 github template로 만들기",
            "summary": "한번 잘 만들어두면 계속 사용할 수 있는 boilerplate를 github template로 만들어보자.",
            "date_modified": "2023-03-12T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "github",
                "template",
                "boilerplate"
            ]
        },
        {
            "id": "134-nextjs-vercel-3",
            "content_html": "<p><a href=\"https://github.com/nostrss/next-render\">전체 소스코드</a></p>\n<p><a href=\"https://next-render-hjuyogs9h-nostrss.vercel.app/\">DEMO</a></p>\n<p>이제 소스코드를 <code>vercel</code>에 배포해 볼 차례이다.</p>\n<p>먼저 지금까지의 소스코드를 Git-hub에 <code>Push</code> 해두도록 하자.</p>\n<h2>Vercel 회원가입</h2>\n<p><a href=\"https://vercel.com/\">Vercel 바로가기</a></p>\n<h2>Git-hub 계정 연결, Repository 연결하기</h2>\n<p>먼저 자신의 Git-Hub 계정을 연결,선택 해준다.</p>\n<p>그러면 아래와 같이 Git-hub에 있는 나의 Repository들이 쭉 나오게 된다.</p>\n<p>그 중에 배포하고자 하는 Repository를 선택, import 해보자.</p>\n<h3>Repository가 보이지 않는 경우</h3>\n<p>깃허브에서 Vercel Application 설정을 확인해보자</p>\n<ul>\n<li>Github > setting > applications > Configure</li>\n</ul>\n<p>나 같은 경우에는 여기서 <code>All Repositories</code>에 접근 가능하도록 허용하니 해결이 되었다.</p>\n<h2>Build &#x26; Deploy</h2>\n<p>위와 같이 설정을 하면 화면이 바뀌면서 자동으로 배포가 진행되기 시작한다.</p>\n<p>배포가 완료되면 아래 사진과 같이 결과를 볼 수 있다.</p>\n<p>배포 결과를 볼수 있는 url, 연결된 branch 등을 확인 할 수 있다.</p>\n<p>나 같은 경우에는 현재 main 브랜치를 연결해 두었다.</p>\n<h2>후속 배포</h2>\n<p>Vercel에 연결되어 있는 branch에 소스코드가 푸쉬되는 순간 vercel에서 자동으로 빌드하여 배포가 진행된다.</p>\n<p>별도로 사용자가 npm run build 와 같은 명령어를 사용할 필요가 없다.</p>\n<p>터미널에서 빌드 오류가 나듯 vercel에서도 빌드 오류가 발생 하면 배포가 진행되지 않으니, 코드를 push 하고 build와 배포가 끝까지 완료 되었는지 확인 할 필요가 있다.</p>",
            "url": "https://nostrss.me/134-nextjs-vercel-3",
            "title": "Next.js SSR, SSG를 Vercel에 배포하기(3)",
            "summary": "배포가 가장 쉬웠어요 라고 할 뻔 했다.",
            "date_modified": "2023-03-11T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "Next",
                "ssr",
                "ssg",
                "vercel",
                "deploy"
            ]
        },
        {
            "id": "133-nextjs-vercel-2",
            "content_html": "<p><a href=\"https://github.com/nostrss/next-render\">전체 소스코드</a></p>\n<p><a href=\"https://next-render-hjuyogs9h-nostrss.vercel.app/\">DEMO</a></p>\n<p>작품 리스트를 <code>SSR</code>로 구현해봤으니, 이번에는 <code>SSG</code>를 구현해보려고 한다.</p>\n<p>리스트 중에 하나를 클릭 했을 때 상세 화면으로 넘어가고</p>\n<p>상세화면은 <code>SSG</code>로 렌더링 되도록 할 예정이다.</p>\n<h2>작품 상세 페이지 SSG 구현</h2>\n<h3>API</h3>\n<blockquote>\n<p>사용할 API : <a href=\"https://api.artic.edu/docs/\">Art Institute of Chicago API</a></p>\n</blockquote>\n<h3>SSG 구현 코드</h3>\n<blockquote>\n<p><a href=\"https://github.com/nostrss/next-render/blob/main/src/pages/%5Bid%5D/index.jsx\">SSG로 구현된 전체 소스코드</a></p>\n</blockquote>\n<h2>구현 내용</h2>\n<h3>getStaticProps</h3>\n<p><a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-static-props\">getStaticProps 문서 보러가기</a></p>\n<ul>\n<li><code>getStaticProps</code>는 빌드 시 api 통신 응답값을 받아 미리 html 파일을 생성해둔다.</li>\n<li>즉, 운영에 배포 되면 유저는 백엔드 서버와의 통신 결과물을 보는 것이 아니라, 이미 빌드되어 있는 <code>html</code> 정적파일을 브라우저로 다운 받아 보는 것이다</li>\n<li>따라서 빌드시 api 통신이 성공하지 않으면 당연히 빌드 에러가 발생한다.</li>\n<li>그리고 해당 페이지 접속 시 로딩이 엄청나게 빠르다.(당연히 이미 렌더링되어 있었으니깐..)</li>\n<li>또 당연하지만 페이지 소스를 보면 api응답 값들이 이미 채워져 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">export async function getStaticProps(context) {\n  const id = context.params.id;\n  const apiUrl = `https://api.artic.edu/api/v1/artworks/${id}`;\n  const res = await fetch(apiUrl);\n  const data = await res.json();\n  return {\n    props: {\n      detailData: data.data,\n    },\n  };\n}\n</code></pre>\n<p>위의 코드는 빌드 시 api 통신 응답값을 클라이언트 컴포넌트에 props로 전달하는 역할을 한다.</p>\n<p><code>SSR</code>과 다른 점은 이것이 <code>빌드(build)</code>시 이루어진다는 것이다.</p>\n<p><code>npm run build</code> 또는 <code>yarn build</code> 커맨드를 입력하는 순간 이미 페이지가 만들어지는 것이다.</p>\n<p>하지만 내가 작성한 코드에서는 위와 같이 작성하면 에러가 발생하였다.</p>\n<p>이유는 getStaticProps가 <code>dynamic routing</code>페이지는 렌더링 하지 못하기 때문이다.</p>\n<p>이 때 필요한 것이 <code>getStaticPaths</code>이다.</p>\n<h3>getStaticPaths</h3>\n<p><a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-static-paths\">getStaticPaths 문서 보러가기</a></p>\n<ul>\n<li><code>getStaticPaths</code>는 <code>dynamic routing</code>으로 동적으로 변하는 path 정보를 <code>getStaticProps</code>에 전달하는 역할을 한다.</li>\n<li>이 path 정보로 <code>getStaticProps</code>는 빌드 시 api를 호출하고 응답값을 받아 정적인 페이지를 생성하는 것이다.</li>\n</ul>\n<pre><code class=\"language-javascript\">export async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: '14556' } },\n      { params: { id: '11434' } },\n      { params: { id: '16487' } },\n    ],\n    fallback: true,\n  };\n}\n</code></pre>\n<p>위의 코드를 보면 id 3개를(14556, 11434, 16487) path 정보로 <code>getStaticProps</code>에 전달하고 있다.\n그렇다면 빌드 시 <code>getStaticProps</code>는 3개의 id로 api 통신을 하고 응답값을 받아 정적인 페이지를 생성할 것이다.</p>\n<p>빌드를 해보자.</p>\n<p>정적 페이지 3개가 빌드 되었다고 빌드 결과에서 확인 할 수 있다.</p>\n<p>실제 빌드 폴더에서 확인해보자.</p>\n<p>빌드 폴더에 내가 지정한 14556, 11434, 16487 html 파일이 생성된 것을 볼 수 있었다.</p>\n<p>그렇다면 여기서 또 다른 의문이 생기게 된다...</p>\n<blockquote>\n<p>작품의 개수가 100개라면, getStaticPaths에 100개의 정보를 입력해야 하는건가?</p>\n</blockquote>\n<h4>fallback(Generating paths on-demand)</h4>\n<p>다시 한번 <code>getStaticPaths</code> 코드를 살펴보자.</p>\n<pre><code class=\"language-javascript\">    fallback: true, // 이건 무엇을 하는 걸까??\n</code></pre>\n<p><code>Next.js</code>에서는 우리의 이런 요구를 예상한듯 이미 준비를 해두었는데, 바로 <code>fallback</code>을 이용하는 것이다.</p>\n<p>모든 페이지를 전부 빌드하는 것이 아니라 필요할 때 마다 정적 페이지를 생성하는 것이다.</p>\n<p>위의 코드를 다시 풀어서 설명하면</p>\n<blockquote>\n<p>id 3개는 미리 페이지를 정적 생성하고</p>\n</blockquote>\n<blockquote>\n<p>나머지 dynamic routing 페이지는 유저가 접속하면 그때 그때 페이지를 생성해줘</p>\n</blockquote>\n<p>라는 의미로 이해하면 된다.</p>\n<p>여기서 <code>fallback:true</code>는 필요할 때마다 정적 페이지를 생성한다라는 옵션인 것이다.</p>\n<p>실제로 생성 되는 지 확인 해보자.</p>\n<p>빌드 후 <code>Production</code> 모드로 실행을 하자</p>\n<blockquote>\n<p>yarn build</p>\n</blockquote>\n<blockquote>\n<p>yarn start</p>\n</blockquote>\n<p>그리고 몇몇 페이지를 방문해봤다.</p>\n<p>내가 지정한 3개의 id외 2개의 페이지가 새롭게 생겨난 것을 볼 수 있었다.</p>\n<p>신기한 기능이긴 한데 몇가지 의문점이 들었다.</p>\n<blockquote>\n<p>서비스를 운영하다 보니 약 10,000개의 정적 페이지들이 생겼다.</p>\n</blockquote>\n<blockquote>\n<p>용량적으로 문제는 없는 건가?</p>\n</blockquote>\n<blockquote>\n<p>만약 새롭게 build를 하게 되는 경우 기존에 쌓여있던 정적 페이지들은 전부 사라지는 건가?</p>\n</blockquote>\n<p>실무에서는 SSG를 어떻게 쓰고 있을까..</p>",
            "url": "https://nostrss.me/133-nextjs-vercel-2",
            "title": "Next.js SSR, SSG를 Vercel에 배포하기(2)",
            "summary": "이래서 Next Next 하는구나..",
            "date_modified": "2023-03-05T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "Next",
                "ssr",
                "ssg",
                "vercel",
                "deploy"
            ]
        },
        {
            "id": "132-nextjs-vercel",
            "content_html": "<p><a href=\"https://github.com/nostrss/next-render\">전체 소스코드</a></p>\n<p><a href=\"https://next-render-hjuyogs9h-nostrss.vercel.app/\">DEMO</a></p>\n<p>최근 공부의 목적에 대해 갈팡질팡하다가 rendering에 대해 부쩍 관심이 생겼다.</p>\n<p>그래서 공부할 겸 Next.js의 SSR(server siede rendering)과 SSG 렌더링을 간단히 구현해서 배포를 해봤다.</p>\n<h2>프로젝트 준비하기</h2>\n<h3>API</h3>\n<p>먼저 렌더링할 데이터를 fetch할 api가 필요했다.</p>\n<p>최대한 간단히 구현하고 싶어서 auth,cors를 신경 쓸 필요 없는 api를 하나 찾았다.</p>\n<blockquote>\n<p>사용할 API : <a href=\"https://api.artic.edu/docs/\">Art Institute of Chicago API</a></p>\n</blockquote>\n<h3>구현할 페이지</h3>\n<ul>\n<li>작품 리스트 페이지 : SSR</li>\n<li>작품 상세 페이지 : SSG</li>\n</ul>\n<p>이렇게 2개의 페이지만 있으면 될 듯 하다.</p>\n<p>페이지 1개는 SSR, 다른 나머지 페이지는 SSG로 구현해볼 생각이다.</p>\n<h2>작품 리스트 페이지 SSR 구현</h2>\n<blockquote>\n<p><a href=\"https://github.com/%3Enostrss/next-render/blob/main/src/pages/index.js\">SSR로 구현된 전체 소스코드</a></p>\n</blockquote>\n<h3>SSR 구현 전 코드</h3>\n<pre><code class=\"language-javascript\">import Head from 'next/head';\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/router';\n\nexport default function Home() {\n  const router = useRouter();\n  const [dataList, setDataList] = useState([]);\n\n  useEffect(() => {\n    fetch(`https://api.artic.edu/api/v1/artworks?limit=20`)\n      .then((res) => res.json())\n      .then((data) => {\n        setDataList([...data.data]);\n      });\n  }, []);\n\n  const onClickItem = (id) => () => {\n    router.push(`/${id}`);\n  };\n\n  return (\n    &#x3C;>\n      {dataList === undefined ? (\n        &#x3C;div>loading...&#x3C;/div>\n      ) : (\n        &#x3C;>\n          &#x3C;Head>\n            &#x3C;title>Next.js Rendering Test&#x3C;/title>\n            &#x3C;meta\n              name='description'\n              content='Next Server Sider Rendering Page'\n            />\n            &#x3C;meta\n              name='viewport'\n              content='width=device-width, initial-scale=1'\n            />\n            &#x3C;link rel='icon' href='/favicon.ico' />\n          &#x3C;/Head>\n          &#x3C;main>\n            &#x3C;h1>This page is implemented with SSR&#x3C;/h1>\n            {dataList?.map((item) => (\n              &#x3C;fieldset\n                key={item.id}\n                onClick={onClickItem(item.id)}\n                style={{ cursor: 'pointer' }}\n              >\n                &#x3C;legend>Artwork {item.id}&#x3C;/legend>\n                &#x3C;ul>\n                  &#x3C;li>title : {item.title}&#x3C;/li>\n                &#x3C;/ul>\n              &#x3C;/fieldset>\n            ))}\n          &#x3C;/main>\n        &#x3C;/>\n      )}\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>위 코드의 과정을 간단히 설명하면 아래와 같다</p>\n<blockquote>\n<ul>\n<li>useEffect로 페이지가 최초 로딩 될 때 작품 리스트 api를 호출 한다.</li>\n<li>응답값을 useState로 dataList에 저장한다.</li>\n<li>dataList의 작품 리스트를 보여준다</li>\n</ul>\n</blockquote>\n<p>이 코드를 SSR로 렌더링하기 위해 아래와 같이 변경 했다.</p>\n<ul>\n<li>\n<p>useEffect로 페이지가 최초 로딩 될 때 작품 리스트 api를 호출 한다.</p>\n<blockquote>\n<p>getServerSideProps로 서버에서 api를 호출한다.</p>\n</blockquote>\n</li>\n<li>\n<p>응답값을 useState로 dataList에 저장한다.</p>\n<blockquote>\n<p>응답값을 props로 전달한다.</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">export async function getServerSideProps() {\n  // useEffect가 아니라 서버에서 api를 호출한다.\n  const res = await fetch(`https://api.artic.edu/api/v1/artworks?limit=20`);\n  const data = await res.json();\n\n  // Props로 응답값을 전달한다.\n  return {\n    props: {\n      dataList: data.data,\n    },\n  };\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// 서버에서 props로 api 응답값을 전달 받는다.\nexport default function Home({ dataList }) {\n(...생략)\n</code></pre>\n<h2>SSR 확인하기</h2>\n<p>페이지의 외관만 보면 SSR을 적용하기 전과 동일하게 보이기 때문에 제대로 적용이 된건지 알 수가 없다.</p>\n<p>이럴 땐 브라우저에서 cmd + opt + u(윈도우 ctrl + u)를 눌러보자.</p>\n<p>(또는 마우스 우클릭 > 페이지 소스 보기)</p>\n<p>SSR을 적용하기 전과 후의 차이점이 보이는가?</p>\n<blockquote>\n<p>SSR 적용 전</p>\n</blockquote>\n<p>SSR을 적용하기 전에는 api 응답으로 받은 작품 리스트의 내용이 보이지 않는다.</p>\n<blockquote>\n<p>SSR 적용 후</p>\n</blockquote>\n<p>SSR을 적용 한 뒤에는 api 응답값으로 받은 작품 타이틀명이 페이지 소스에 보이는 것을 확인 할 수 있다.</p>",
            "url": "https://nostrss.me/132-nextjs-vercel",
            "title": "Next.js SSR, SSG를 Vercel에 배포하기(1)",
            "summary": "오랜만에 사용해 보는 Next.js, 보고 싶었다 Next.js",
            "date_modified": "2023-03-05T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "Next",
                "ssr",
                "ssg",
                "vercel",
                "deploy"
            ]
        },
        {
            "id": "131-progressive-web-app-2",
            "content_html": "<h2>PWA 장점</h2>\n<p>프로그레시브 웹 앱(Progressive Web App, PWA)은 웹과 네이티브 앱의 기능을 결합한 형태의 애플리케이션이다.</p>\n<p>PWA는 온라인에서 쉽게 접근 가능하며, 브라우저를 통해 실행이 가능하고, 다운로드도 가능하다.\n즉, 앱 스토어에서 다운로드 및 설치를 필요로 하지 않으므로, 개발자는 플랫폼의 종속성에서 벗어날 수 있다.\n그리고 Native App을 별도로 개발할 필요가 없는 장점이 있다.</p>\n<p>이렇게 장점만 보면 모든 기업들이 앞다투어 도입을 할 것 같지만, 어떤 이유 인지 도입이 그렇게 빠르게 되고 있다는 생각이 들지는 않는다.\n아무래도 각 플랫폼의 이해타산이 맞물려 있기 때문이 아닐까 싶다.</p>\n<p>구글과 애플의 입장에선 인앱 결제를 통한 수수료 수익이 줄어들 가능성이 있기 때문이지 않을까 싶다.</p>\n<p>구글의 경우에는 그래도 크롬에서 지원하는 등의 노력이 보이는데, 애플은 아직 소극적인 느낌이다.</p>\n<h3>PWA의 기술적 정의</h3>\n<p><a href=\"https://adactio.medium.com/what-is-a-progressive-web-app-f1ca780f30e6\">What is a Progressive Web App?</a></p>\n<p>제레미 키스(Jeremy Keith)는 PWA의 기술적 특징을 이렇게 설명한다</p>\n<ol>\n<li>HTTPS</li>\n<li>Service-Worker</li>\n<li>Web App Manifest</li>\n</ol>\n<p>이전 블로그 포스팅에서 나도 간단히 React 프로젝트에 PWA를 적용해봤는데, 저 내용을 보니 구현 과정이 조금 이해가 되는 듯 하다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/56717167/222913262-adc55a93-e498-49d1-8cba-ceff24f4ddf6.png\" alt=\"pwabuilder\"></p>\n<blockquote>\n<p>PWA-Builder에서 검사 항목들(https://www.pwabuilder.com)</p>\n</blockquote>\n<h2>HTTPS</h2>\n<p>이건 굳이 말하지 않아도 보안 때문이지 않을까 하는 생각이 든다.\n(그리고 https가 아닐 경우 구글이 <code>안전하지 않음</code>이라는 문구를 노출하기 때문에..)</p>\n<h2>Service-Worker</h2>\n<blockquote>\n<p>웹 브라우저의 네트워크 요청과 자원관리를 개발자가 중간에서 직접 제어하도록 해주는 강력한 기술이다. 서비스 워커를 이용하면 안정적이고, 빠르고, 오프라인 기능에서도 작동하는 웹페이지를 제작할 수 있다. - 프로그레시브 웹 앱 (제이슨 그릭스비)</p>\n</blockquote>\n<p>책에서는 위와 같이 설명을 하고 있는데, 조금 단순화해서 정리하면 App이 오프라인으로 전환되더라도 계속 작동하는 PWA를 만드는 JS파일(?)이라고 생각하면 될 듯하다.\n우리나라에 워낙 모바일 네트워크가 잘 구축되어 있기 때문에, 스마트폰은 항상 통신이 되어야 한다고 생각한다.</p>\n<p>하지만 이건 우리나라가 특이한 경우고 해외의 경우 모바일 통신 상태가 불안정한 경우가 많다. 그리고 개발자들은 이를 고려해야 하는 경우도 있다.</p>\n<p>페이스북과 트위터가 라이트(lite)버전의 용량이 작은 앱을 별도로 출시 하는 것도 이런 이유일 것이다.</p>\n<p>즉, 서비스 워커는 PWA의 로컬 캐시 전략을 정의하는 역할을 한다고 볼 수 있다.</p>\n<h2>Web App Manifest</h2>\n<p><code>Manifest</code></p>\n<p>React 개발을 하다보면 어디선가 많이 봤을 법한 단어이다. 그렇다 public 폴더 안에 존재하는 <code>manifest.json</code> 파일을 말한다.</p>\n<p>사실 나는 <code>manifest.json</code> 파일이 프로젝트에 항상 있었지만 어떤 역할을 하는지 몰랐었다. 하지만 삭제를 하려고 해도 혹시 몰라서 항상 건드리지 않았던 파일이었는데, PWA에서는 중요한 역할을 하고 있었다..</p>",
            "url": "https://nostrss.me/131-progressive-web-app-2",
            "title": "React PWA 만들기(2)",
            "summary": "대표님 한마디에 이렇게까지 준비를 해야해나?",
            "date_modified": "2023-03-04T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "react",
                "pwa"
            ]
        },
        {
            "id": "130-progressive-web-app",
            "content_html": "<h2>PWA란?</h2>\n<ul>\n<li>Progressive Web Apps의 약자이다.</li>\n<li>html,css,javascript와 같은 웹기술로 만드는 App이라고 생각하면 된다. 마치 Web과 App의 경계사이에 있는 느낌이다.</li>\n<li>바탕화면에 웹페이지를 즐겨찾기 해둔 것처럼 간단해 보이기도 하고, Web을 패키징한 하이브리드 앱처럼 보이기도 한다.</li>\n<li>구글,MS에서는 PWA 사용과 보급에 적극적이지만 Apple은 이에 소극적이라고 한다.</li>\n</ul>\n<h3>Register Store(?)</h3>\n<ul>\n<li>직접 해보지는 않았지만 이렇게 생성한 App을 이론적(?)으로 구글플레이 스토어와 애플 앱 스토어에 등록 할 수 있다고 한다.</li>\n<li>검색을 해보니 구글은 사례가 많이 보였는데, 애플의 앱 스토어의 경우에는 찾을 수가 없었다. 애플은 심사통과가 되지 않을 수도 있을 것 같다.</li>\n</ul>\n<h3>reference</h3>\n<p><a href=\"https://www.pwabuilder.com/\">PWA-builder</a></p>\n<p><a href=\"https://developer.chrome.com/blog/getting-started-pwa/\">Getting started with Progressive Web Apps</a></p>\n<h3>PWA 예시</h3>\n<p>스타벅스 홈페이지가 PWA가 적용이 되어있다.</p>\n<p><a href=\"https://app.starbucks.com/\">Starbucks 바로가기</a></p>\n<p>위의 링크를 타고 접속하면 주소창 우측에 다운로드 버튼이 있는데, 클릭하면 PWA가 다운로드 된다.\n다운로드 된 PWA를 실행시키면 브라우저에서 실행되는 것이 아니라 마치 APP을 실행시킨듯한 화면이 나타난다.</p>\n<h2>REACT에 PWA 적용하기</h2>\n<h3>1.React Set up</h3>\n<blockquote>\n<p>npx create-react-app pwa</p>\n</blockquote>\n<h3>2.Install gh-pages and package.json setting</h3>\n<ul>\n<li>git-hub pages에 배포해서 보기 위하여 gh-pages를 설치하여 간단히 배포를 위한 세팅을 했다.</li>\n</ul>\n<blockquote>\n<p>npm i gh-pages</p>\n</blockquote>\n<ul>\n<li>package.json에 배포 script 추가</li>\n</ul>\n<pre><code class=\"language-json\">//package.json\n...\n\"homepage\": \"http://nostrss.github.io/pwa\", //추가\n...\n\"predeploy\": \"npm run build\", //추가\n\"deploy\": \"cp build/index.html build/404.html &#x26;&#x26; gh-pages -d build\" //추가\n</code></pre>\n<h3>3.Add service-worker</h3>\n<p>아래 2개의 파일을 root 위치에 작성하여 추가해줬다.</p>\n<ul>\n<li>service-worker.js<a href=\"https://github.com/nostrss/pwa/blob/main/src/service-worker.js\">(소스코드)</a></li>\n<li>serviceWorkerRegistration.js<a href=\"https://github.com/nostrss/pwa/blob/main/src/serviceWorkerRegistration.js\">(소스코드)</a></li>\n</ul>\n<p>그리고 index.js파일에 service-worker를 등록해주는 코드를 추가해줬다.</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n// 아래 코드 추가\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  &#x3C;React.StrictMode>\n    &#x3C;App />\n  &#x3C;/React.StrictMode>\n);\n\n// 아래 코드 추가\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n</code></pre>\n<h3>4.Deploy</h3>\n<blockquote>\n<p>npm run deploy</p>\n</blockquote>\n<ul>\n<li>배포 후 페이지에 접속해보면 아래와 같이 주소창 옆에 다운로드 버튼이 생기게 된다.</li>\n</ul>\n<ul>\n<li>다운로드 후 실행 해보면 아까 본 스타벅스 PWA처럼 내가 만든 PWA가 실행되는 것을 볼 수 있다.</li>\n</ul>\n<h3>5. PWA Analyze</h3>\n<ul>\n<li>안드로이드, iOS앱에 배포 시 심사를 받듯이, PWA도 조건을 충분이 충족하는지 검사하는 방법이 몇가지 존재한다.</li>\n</ul>\n<h4>Lighthouse</h4>\n<ul>\n<li>Chrome 개발자 도구 > Lighthouse 에서 직접 검사를 해볼 수 있다.</li>\n<li>검사 후 어떤 점이 부족한지 결과와 어떻게 수정해야하는지 가이드도 볼 수 있다.</li>\n</ul>\n<h4>Pwa-builder</h4>\n<p><a href=\"https://www.pwabuilder.com/\">PWA-builder</a></p>\n<ul>\n<li>링크에 접속하여, URL을 입력하면 아래와 같이 결과를 볼 수 있다.</li>\n</ul>\n<ul>\n<li>그리고 여기서 OS별(안드로이드,애플 등) 패키지를 다운로드 받을 수가 있다.</li>\n<li>이 패키지를 어떤 추가적인 과정을 거쳐서 스토어에 등록할 수 있다고 한다.</li>\n<li>실제 가능하다면, 어떤 서비스를 만들 때 초기에 Native App을 따로 만들지 않고 활용할 수 있을 듯하다.</li>\n</ul>\n<h3>ETC</h3>\n<ul>\n<li>나는 직접 service-worker를 생성했었는데, 알고보니 더 쉬운 방법이 있었다.</li>\n<li>아래의 커맨드로 react template를 설치하면 더 쉽게 PWA를 적용할 수 있다.</li>\n</ul>\n<p>JavaScript</p>\n<blockquote>\n<p>npx create-react-app my-app --template cra-template-pwa</p>\n</blockquote>\n<p>TypeScript</p>\n<blockquote>\n<p>npx create-react-app my-app --template cra-template-pwa-typescript</p>\n</blockquote>",
            "url": "https://nostrss.me/130-progressive-web-app",
            "title": "React PWA 만들기(1)",
            "summary": "대표님은 PWA가 하고 싶다고 하셨어.",
            "date_modified": "2023-03-04T00:00:00.000Z",
            "author": {
                "name": "Nostrss",
                "url": "https://github.com/nostrss"
            },
            "tags": [
                "react",
                "pwa"
            ]
        }
    ]
}